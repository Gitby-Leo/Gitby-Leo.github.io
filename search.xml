<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Marp用markdown制作PPT</title>
    <url>/2020/07/19/Marp%E7%94%A8markdown%E5%88%B6%E4%BD%9CPPT/</url>
    <content><![CDATA[<blockquote>
<p>Marp -&gt; ppt/pdf/html -&gt; with markdown</p>
</blockquote>
<a id="more"></a>

<p>最近需要搞一个技术分享，ppt的风格比较多，发现强大的md语法也能够生成ppt，就试试这种极简风格吧</p>
<p>下面是语法示例<br><code>xx.md</code>内容为之前博客文章内容</p>
<hr>
<h2 id="安装Marp-for-VS-Code插件"><a href="#安装Marp-for-VS-Code插件" class="headerlink" title="安装Marp for VS Code插件"></a>安装<code>Marp for VS Code</code>插件</h2><p>文件顶部必须有<code>marp: true</code>用于识别</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">marp: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>每页通过<code>---</code>分割，vscode编辑器通过按钮导出预览格式</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">marp: true</span><br><span class="line">style: |</span><br><span class="line">  section &#123;&#125;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- Global style --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line">section.sectionEnd &#123;</span><br><span class="line"><span class="code">    align-items: center;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- paginate: true--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _header: 技术分享 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _footer: - --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># 技术分享——搭建Jenkins</span></span><br><span class="line"></span><br><span class="line">Leo</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _header: 关于部署 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- class: section0 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- footer: Powered By [Marp][Marp] --&gt;</span></span></span><br><span class="line"><span class="section">## 关于前端部署</span></span><br><span class="line"></span><br><span class="line">之前开发时部署采用的是手动打包，上传服务器的方式</span><br><span class="line"></span><br><span class="line">加入公司后，看到技术团队用的是自动化部署，即更新master分支后自动编译发布</span><br><span class="line"></span><br><span class="line">本次介绍前端如何结合Jenkins进行自动化部署</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _header: Jenkins介绍 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- class: section1 --&gt;</span></span></span><br><span class="line"><span class="section">## Jenkins介绍</span></span><br><span class="line"></span><br><span class="line">CI持续集成 - 自动检测源代码、拉取、构建的过程，减少集成问题</span><br><span class="line">CD持续部署 - 随时推向生产环境，降低每次发布的风险，快速迭代</span><br><span class="line"></span><br><span class="line">Jenkins是一个CI工具，简化部署工作流程，丰富的插件生态，可视化的界面配置</span><br><span class="line"></span><br><span class="line">其他还有很多CI/CD工具可用于不同场景下</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _header: 环境准备 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- class: section2 --&gt;</span></span></span><br><span class="line"><span class="section">## 环境准备</span></span><br><span class="line"></span><br><span class="line"><span class="code">`Github/Gitlab`</span>、<span class="code">`Centos ECS`</span>、<span class="code">`Jnkins`</span></span><br><span class="line"></span><br><span class="line"><span class="code">```cmd</span></span><br><span class="line"><span class="code">$ yum install java  # 安装依赖</span></span><br><span class="line"><span class="code">$ yum install jenkins # 安装jenkins</span></span><br><span class="line"><span class="code">$ service jenkins start # 启动jenkins</span></span><br></pre></td></tr></table></figure>

<ul>
<li>访问server ip:8080</li>
<li>初始化jenkins并安装通用插件</li>
<li>配置完成后如右图<br><img src="Marp%E7%94%A8markdown%E5%88%B6%E4%BD%9CPPT/images/login.jpg" alt="bg right:40%"></li>
</ul>
<hr>
<!-- _header: 环境准备 -->

<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><ul>
<li>Rebuilder 用于重新执行构建命令</li>
<li>SafeRestart 用于重启</li>
<li>Webhook 触发器</li>
<li>Publish Over SSH 登录目标服务器</li>
<li>配置前端需要的node版本</li>
</ul>
<p><img src="Marp%E7%94%A8markdown%E5%88%B6%E4%BD%9CPPT/images/ManagePlugins.jpg" alt="bg vertical right 90%"><br><img src="Marp%E7%94%A8markdown%E5%88%B6%E4%BD%9CPPT/images/nodejs.jpg" alt="bg right 90%"></p>
<hr>
<!-- _header: 环境准备 -->

<h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p>创建任务后</p>
<ul>
<li>关联 GitHub 仓库</li>
<li>填写shell命令</li>
</ul>
<p><img src="Marp%E7%94%A8markdown%E5%88%B6%E4%BD%9CPPT/images/repository.jpg" alt="bg vertical right 90%"><br><img src="Marp%E7%94%A8markdown%E5%88%B6%E4%BD%9CPPT/images/build.jpg" alt="bg right 90%"></p>
<hr>
<!-- _header: 环境准备 -->
<h2 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h2><p>通过Publish Over SSH插件实现连接服务器部署</p>
<ul>
<li>Source files 打包后的文件</li>
<li>Remove prefix 删除的目录</li>
<li>Remote directory 连接服务器的目录</li>
</ul>
<p><img src="Marp%E7%94%A8markdown%E5%88%B6%E4%BD%9CPPT/images/sshServerConfig.jpg" alt="bg vertical right 90%"><br><img src="Marp%E7%94%A8markdown%E5%88%B6%E4%BD%9CPPT/images/sshConfig.jpg" alt="bg right 90%"></p>
<hr>
<!-- _header: 环境准备 -->
<h2 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h2><p>Jenkins任务的构建触发器处填写自定义的token，用于和github的Webhook绑定</p>
<p>再次提交代码，可以看到页面触发了新的任务，正在执行，还可以查看执行进度的具体log信息</p>
<p>至此就完成了Jenkins的配置</p>
<p><img src="Marp%E7%94%A8markdown%E5%88%B6%E4%BD%9CPPT/images/webhooks.jpg" alt="bg vertical right 90%"><br><img src="Marp%E7%94%A8markdown%E5%88%B6%E4%BD%9CPPT/images/progress.jpg" alt="bg right 90%"></p>
<hr>
<!-- _header: 回顾流程 -->
<!-- class: section6 -->

<h2 id="回顾流程"><a href="#回顾流程" class="headerlink" title="回顾流程"></a>回顾流程</h2><ul>
<li>push本地代码到远端仓库</li>
<li>Webhook监听自动触发jenkins上的构建动作</li>
<li>完成安装node依赖、打包</li>
<li>通过Publish Over SSH插件，将打包出来的文件，部署到目标服务器上</li>
</ul>
<hr>
<!-- _header: 关于Marp -->
<!-- _footer: '' -->
<h2 id="关于Marp"><a href="#关于Marp" class="headerlink" title="关于Marp"></a>关于Marp</h2><p>左下角的页尾有个Marp，是vs code中支持md语法的PPT制作插件，支持导出html,pdf,pptx</p>
<hr>
<!-- _paginate: false-->
<!-- _footer: '' -->
<!-- class: sectionEnd -->

<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><pre><code></code></pre>]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>持续集成之Github Actions</title>
    <url>/2020/07/17/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BGithub%20Actions/</url>
    <content><![CDATA[<blockquote>
<p>持续集成是指代码提到到仓库后的所有：服务器编译、测试、打包、部署自动执行</p>
</blockquote>
<a id="more"></a>

<p>上次，写了一篇关于Jenkins的搭建流程，也实现了推送后的webhooks钩子响应并编译发布</p>
<p>而本篇介绍的Github Actions则是代替Jenkins手工搭建，并节省服务器资源的一种新方式</p>
<hr>
<!-- https://zhuanlan.zhihu.com/p/93829286
 -->

<h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>熟悉vuex/redux的童鞋一定不陌生这个词</p>
<ul>
<li><p>vuex中表示保存异步修改状态的方法</p>
</li>
<li><p>redux中表示触发store中的数据更新的唯一来源</p>
<p>而这里，每一个操作/脚本可以理解为一个action，叠加起来很多操作就是actions</p>
<p>github有一个<a href="https://github.com/marketplace?type=actions" target="_blank" rel="noopener">官方市场</a>可以让你的项目添加不同的action</p>
</li>
</ul>
<h2 id="创建action工作流"><a href="#创建action工作流" class="headerlink" title="创建action工作流"></a>创建action工作流</h2><p>在仓库的actions选项卡中, set up a workflow yourself</p>
<p>发布到github则需要 GitHub 密钥，在仓库的Settings/Secrets新建一个</p>
<ul>
<li><p>github提供的服务器</p>
<ul>
<li>2核 CPU</li>
<li>7GB RAM</li>
<li>14GB SSD</li>
</ul>
</li>
<li><p>执行结果</p>
<ul>
<li>runner: github 分配的用来执行 CI/CD 的构建服务器 (也可以自建 runner)</li>
<li>workflow: CI/CD 的工作流</li>
<li>job: 任务，比如构建，测试和部署。每个 workflow 由多个 job 组成</li>
<li>step: 每个 job 由多个 step 组成</li>
</ul>
</li>
</ul>
<h2 id="编写action"><a href="#编写action" class="headerlink" title="编写action"></a>编写action</h2><p>配置文件在仓库的.github/workflows目录下，格式为yaml，像hexo就是这种.yml啦</p>
<p>在new时可以直接选择nodejs的action,</p>
<p><a href="https://help.github.com/en/articles/workflow-syntax-for-github-actions" target="_blank" rel="noopener">配置字段</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">demo</span> <span class="comment"># 脚本名</span></span><br><span class="line"><span class="attr">on:</span>        <span class="comment"># 触发条件为推送到master分支</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="attr">jobs:</span>      <span class="comment"># 需要执行的动作</span></span><br><span class="line">  <span class="attr">build:</span>   <span class="comment"># 用ubuntu执行构建，uses是用了什么库</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">build</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xxx</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span></span><br></pre></td></tr></table></figure>

<h2 id="ssh自动登陆服务器打包"><a href="#ssh自动登陆服务器打包" class="headerlink" title="ssh自动登陆服务器打包"></a>ssh自动登陆服务器打包</h2><p>推送后，自动拉取最新代码打包</p>
<p><a href="https://github.com/appleboy/ssh-action" target="_blank" rel="noopener">自动模拟ssh登录</a></p>
<p>进入服务器，进入目录，拉取代码，打包，完成</p>
<hr>
<!-- ## 失败

找了几个示例试了下，github fail了

Workflows:
Run failed for master (xxxx) 失败了呀 -->
]]></content>
      <categories>
        <category>ci/cd</category>
      </categories>
      <tags>
        <tag>ci/cd</tag>
      </tags>
  </entry>
  <entry>
    <title>API接口设计攻略</title>
    <url>/2020/07/15/API%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<blockquote>
<p>前端业务需要怎么样的接口，如何保证交互安全</p>
</blockquote>
<a id="more"></a>

<p>本篇不是RESTful风格的描述，提供思路仅供参考</p>
<hr>
<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>防抓包不用多说</p>
<h2 id="格式规范JSON"><a href="#格式规范JSON" class="headerlink" title="格式规范JSON"></a>格式规范JSON</h2><p>对一个项目来说，统一格式的返回数据，前后端可以进行优雅抽象，简洁处理业务代码<br>对一个团队来说，统一格式，可以封装通用类，作为沉淀</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code:<span class="built_in">Number</span>,</span><br><span class="line">    data:<span class="built_in">Array</span> | <span class="built_in">Object</span>,</span><br><span class="line">    msg:<span class="built_in">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>访问令牌字符串，用于标识客户端的身份</p>
<p>服务端返回appid和key，(这里的客户端是指接口的请求方，服务端是指接口的处理方)，这个key需要保存到客户端，并作安全处理</p>
<p>举例抖音的signature，我还没找到是如何生成的（知道的小伙伴可以下方留言告诉我）</p>
<p>token作为key，关联信息作为value，缓存到redis中，当请求处理时检查token存在及过期时间，否则返回异常</p>
<h3 id="API-token-接口令牌"><a href="#API-token-接口令牌" class="headerlink" title="API token 接口令牌"></a>API token 接口令牌</h3><p>访问不需要登录的数据，比如登录注册，基本数据获取</p>
<p>通过appid、timestamp、sign来换token</p>
<h3 id="USER-toekn-用户令牌"><a href="#USER-toekn-用户令牌" class="headerlink" title="USER toekn 用户令牌"></a>USER toekn 用户令牌</h3><p>访问登录后的数据，用户信息，增删改</p>
<p>通过用户名、密码来换token</p>
<h3 id="时效性"><a href="#时效性" class="headerlink" title="时效性"></a>时效性</h3><ul>
<li>一次性<ul>
<li>调用后销毁</li>
</ul>
</li>
<li>过期时间<ul>
<li>20分钟~2小时</li>
</ul>
</li>
<li>过期后激活并续期<ul>
<li>用旧token请求，返回新token，延长过期时间，下次用新token</li>
</ul>
</li>
</ul>
<h2 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp"></a>timestamp</h2><p>接口调用时的客户端时间戳，缩短Dos攻击时间</p>
<p>服务端判断时间差或者解析sign在几分钟内通过，以外的拦截过滤掉</p>
<p>Dos是指利用网络协议层的缺陷，大量请求服务器资源、占用带宽、填充硬盘空间，导致服务器无法正常工作，直至停止响应崩溃</p>
<ul>
<li>简述Dos方式<ul>
<li>Pingflood Ping包，堵塞网络&amp;主机资源</li>
<li>Synflood SYN包，收到主机ACK不回应，建立维护大量连接队列，消耗主机资源</li>
<li>Smurf ICMP包，伪装客户端为目标主机地址，向子网广播地址发包，使子网主机回应目标主机，形成攻击</li>
<li>Land-based 设置包的源地址和目标地址为主机地址，通过ip欺骗方式发给目标主机，造成与自身建立连接的死循环</li>
<li>Ping of Death 包长度分割片段，总和大于65536字节上限，造成宕机</li>
<li>Teardrop 包分割小片段，使合并前分配大量资源堆栈</li>
</ul>
</li>
</ul>
<h2 id="sign"><a href="#sign" class="headerlink" title="sign"></a>sign</h2><p>参数签名，防止篡改</p>
<p>ascii码升序+token+key+timestamp+随机数，加密</p>
<p>可以放在请求体中，也可以放在header中，即使参数被修改，通过sign解析在接收时验证</p>
<p>（有人说sign是骗自己，没有增加防护效果，这里再提一次，抖音的signature是怎么加密的呢）</p>
<h2 id="重复提交"><a href="#重复提交" class="headerlink" title="重复提交"></a>重复提交</h2><p>前端做请求触发的拦截<br>后端设置超时时间<br>    - 第一次提交时sign保存、超时时间<br>    - 第二次请求时检测是否存在sign<br>      - 存在为重复提交，因为如果sign过期token也会过期</p>
<p>增加装饰器自定义接口防重功能</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul>
<li>客户端申请appid和key</li>
<li>客户端携带appid、timestamp、sign获取服务端api token<ul>
<li>客户端请求普通接口</li>
</ul>
</li>
<li>客户端登录，用户名密码换取user token<ul>
<li>客户端请求权限接口</li>
</ul>
</li>
</ul>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>Thread多线程，单个线程中，方法共享内存，能从上下文取值</p>
<ul>
<li>api接收参数时，拦截器校验token合法</li>
<li>找到token对应的用户信息，存储到Thread中，这样在生命周期中都能获取到</li>
</ul>
<h2 id="文档工具"><a href="#文档工具" class="headerlink" title="文档工具"></a>文档工具</h2><p>Swagger / Yapi / Postman / Online&amp;Offline Website / Excel / PPT / Word</p>
]]></content>
      <categories>
        <category>API</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>网站前端登录原理</title>
    <url>/2020/07/13/%E7%BD%91%E7%AB%99%E5%89%8D%E7%AB%AF%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>登录/扫码，背后用到了什么功能</p>
</blockquote>
<a id="more"></a>

<p>最近也是看到一个需求，网站接入微信扫码登录，并且扫码同时还需要关注公众号，那么就乘此时机回顾下各类登录方式</p>
<hr>
<h2 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie+Session"></a>Cookie+Session</h2><p>经典的登录模式</p>
<p>由于http的无状态特性，服务端是不知道客户端是谁的，也就无法判断每次请求的用户是否相关联，所以不知道用户是否已经是登录态</p>
<p>cookie作用是服务端发送给客户端的字符串，以文本方式保存，再下次请求时携带</p>
<p>session是服务端对接收的信息进行验证，服务端会分配一个内存区域/文件/数据库，用于缓存session对象</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li>首次登录<ul>
<li>用户访问页面，输入密码</li>
<li>验证成功，分配sessionId</li>
<li>响应头写入cookie，告知客户端登录成功</li>
</ul>
</li>
<li>二次登录<ul>
<li>用户发送请求携带cookie给服务端</li>
<li>验证有效，允许访问，表示cookie中解析出来的sessionId一致</li>
<li>验证失效，重新登录</li>
</ul>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>客户端数量上升，服务端需分配更大量的空间存放sessionId，增大服务端压力</li>
<li>分布式/集群，同步登录态需要每一台机器</li>
<li>sessionId存放在cookie中，有CSRF攻击风险<ul>
<li>这里简述跨站脚本攻击，中间人无法拿到/解析cookie，但是能通过真实cookie向服务端发送请求，改变发送的数据，所以攻击的是改POST，而非读GET</li>
<li>如果业务走安全审计流程么，一般会给出具体的解决方案（专业审计，价格老贵了，四大审计真的业务方向啥都审）<ul>
<li>验证 HTTP Referer 字段</li>
<li>在请求地址中添加 token 并验证</li>
<li>在 HTTP 头中自定义属性并验证</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>token优化了传统cookie+session的服务端压力问题，之前我最常用的则是JWT</p>
<h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ul>
<li>首次登录<ul>
<li>用户访问页面，输入密码</li>
<li>验证成功，生成token</li>
<li>返回token，告知客户端登录成功</li>
</ul>
</li>
<li>二次登录<ul>
<li>用户发送请求携带token给服务端</li>
<li>验证有效，允许访问</li>
<li>验证失效，重新登录</li>
</ul>
</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>服务端无需保存，利用客户端天然的分布式优势缓存token，每次请求时校验</li>
<li>不存在cookie中</li>
<li>登录态有效期由服务端决定</li>
</ul>
<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>格式为header.playload.signature字符串</p>
<p>头部指定签名算法，消息体包含数据，签名对前两部base64url+对称加密</p>
<p>当然不一定要强制按格式，能够产生类似功能的字符串与服务端匹配就可以称为JWT</p>
<p>服务端拿到字符串后执行相同对称加密动作，判断签名一致</p>
<ul>
<li>问题点在于对称加密，密钥是暴露的  </li>
<li>但是前端安全的本质是防止中间人通过各种方式篡改/攻击数据库，执行改权限之前是经过其他权限验证的真实用户，不能防止黑客作为真实用户去进行请求  </li>
<li>所以JWT也是有价值的，当然更大的价值在于减轻服务端压力</li>
</ul>
<h2 id="SSO单点登录"><a href="#SSO单点登录" class="headerlink" title="SSO单点登录"></a>SSO单点登录</h2><p>品牌内部的公共认证中心，所有产品一次登录，其他产品无需登录，常见比如腾讯的子域名游戏、综艺等</p>
<h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><ul>
<li>首次登录<ul>
<li>用户访问页面A，跳转到renz认证中心统一登录页B，并url带上redirect地址，发送请求并验证</li>
<li>输入密码，认证中心验证成功，创建全局会话&amp;ticket</li>
<li>带上统一登录的登录态cookie，重定向跳转回页面A，此时url上含有ticket</li>
<li>页面A请求，认证中心验证ticket有效，带上页面A的登录态cookie</li>
<li>登录成功，客户端有2个cookie</li>
</ul>
</li>
<li>二次登录页面A<ul>
<li>验证ticket，cookie已存在，令牌有效，登录成功</li>
</ul>
</li>
<li>二次登录页面B<ul>
<li>通过认证中心统一登录页B，验证认证中心登录态</li>
<li>验证通过，带上ticket重定向回B</li>
</ul>
</li>
<li>退出<ul>
<li>在验证ticket时，请求为退出的api接口即可</li>
<li>清除c的登录态cookie</li>
<li>清除认证中心的cookie，执行退出方法</li>
<li>遍历下发过ticket的产品，执行的退出方法</li>
</ul>
</li>
</ul>
<h2 id="Oauth"><a href="#Oauth" class="headerlink" title="Oauth"></a>Oauth</h2><p>比如微信、qq、微博,授权机制，客户端携带令牌可以访问所有者的资源</p>
<ul>
<li>接入的第三方应用获取appid,appsecret</li>
<li>用户进入时，跳转平台Oauth授权，平台发送请求用户确认</li>
<li>确认后重新进入第三方站点，并带上临时code</li>
<li>第三方应用根据code、id、secret向平台申请token</li>
<li>第三方应用拿到用户信息，保存登录态</li>
</ul>
<h3 id="Oauth2-0"><a href="#Oauth2-0" class="headerlink" title="Oauth2.0"></a>Oauth2.0</h3><p>获取token的过程，4种授权方式，都需要第三方有appid和appsecret，需要分发token和refresh</p>
<ul>
<li>授权码，最复杂，安全高，如微信</li>
<li>隐藏式，客户端直接获取token</li>
<li>密码式，第三方拿用户账密登录平台，危险风险大</li>
<li>凭证式，客户端分配了id,secret标识身份 </li>
</ul>
<p>token放header中</p>
<h3 id="令牌过期处理"><a href="#令牌过期处理" class="headerlink" title="令牌过期处理"></a>令牌过期处理</h3><p>token是有时效的，重新授权的流程体验不好，更优雅得处理过期问题</p>
<p>一个令牌请求API，一个令牌请求refresh_token，当一个失效时，下一次请求更新token，即可优化前端流程</p>
<h2 id="扫码登录及关注"><a href="#扫码登录及关注" class="headerlink" title="扫码登录及关注"></a>扫码登录及关注</h2><p>简述一下思路，扫码后&amp;关注默认为已授权</p>
<ul>
<li>嵌入网页的平台二维码展示，客户端存jwt用于验证</li>
<li>服务端生成微信临时带参二维码，每三分钟更新</li>
<li>客户端每隔3秒请求一次API获取最新状态，5次后每隔5秒，再往后时间间隔变长，优化请求，这里也可以用socket更简洁(简述三点接口性能，有空写一篇关于socket的)<ul>
<li>大量链接的创建和关闭</li>
<li>长时间保持大量连接</li>
<li>大量推送消息</li>
</ul>
</li>
<li>用户扫码后关注/直接进入公众号，服务端根据临时二维码区分渠道，得到授权状态，更新API、token、数据库</li>
<li>客户端切换页面内容A，刷新页面从缓存中取token值，验证成功后直接进入页面A，不再重新扫码</li>
<li>授权/关注流程结束，需求实现</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>轻松处理10种跨域请求</title>
    <url>/2020/07/10/%E8%BD%BB%E6%9D%BE%E5%A4%84%E7%90%8610%E7%A7%8D%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<blockquote>
<p>Leo：跨域啦，跨域啦，求后端小哥开放白名单吧<br>大佬：自己解决<br>Leo：/(ㄒoㄒ)/~~</p>
</blockquote>
<a id="more"></a>

<p>记得以前最频繁的处理跨域需求就是本地调不通测试站点的接口，只好找后端重新部署一次，开放CORS限制</p>
<p>后来有了nginx和cli-proxy就方便多了</p>
<hr>
<h2 id="什么是跨域啦"><a href="#什么是跨域啦" class="headerlink" title="什么是跨域啦"></a>什么是跨域啦</h2><ul>
<li>浏览器侧的同源策略，用来限制请求资源交互，减少服务器被攻击的渠道之一</li>
<li>服务端侧是没有的，所以有些新入门/不了解的服务端同学会疑惑postman上可以正常请求</li>
</ul>
<h2 id="什么是同源啦"><a href="#什么是同源啦" class="headerlink" title="什么是同源啦"></a>什么是同源啦</h2><p>protocol（协议）、domain（域名）、port（端口）三者一致</p>
<p>http即默认80<br>https即默认443</p>
<p>说到domain域名，示例<code>map.baidu.com</code>中  </p>
<ul>
<li><p><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D" target="_blank" rel="noopener">维基百科</a></p>
<ul>
<li>baidu.com叫做二级域名</li>
<li>map.baidu.com叫做三级域名</li>
</ul>
</li>
<li><p>而我更倾向于称呼</p>
<ul>
<li>baidu.com叫做一级域名，【主域名】<ul>
<li>.com是顶级域，baidu是一级名</li>
</ul>
</li>
<li>map.baidu.com叫做二级域名，【子域名】<ul>
<li>map是二级名</li>
</ul>
</li>
<li><strong><em>不接受反驳</em></strong>，你上阿里云/腾讯云买的是后缀域和名，可以自行配置多个子域名</li>
</ul>
</li>
</ul>
<hr>
<h2 id="解决它"><a href="#解决它" class="headerlink" title="解决它"></a>解决它</h2><h2 id="1、CORS控制响应头"><a href="#1、CORS控制响应头" class="headerlink" title="1、CORS控制响应头"></a>1、CORS控制响应头</h2><p><code>Access-Control-Allow-Origin</code>控制哪些域名可以获取资源</p>
<p>通常解决是设置响应头<code>Access-Control-Allow-Origin: *</code></p>
<h3 id="简单-复杂请求"><a href="#简单-复杂请求" class="headerlink" title="简单/复杂请求"></a>简单/复杂请求</h3><p>触发简单：</p>
<ul>
<li>Method<ul>
<li>GET、HEAD、POST</li>
</ul>
</li>
<li>Content-Type<ul>
<li>text/plain、multipart/form-data、application/x-www-form-urlencoded</li>
</ul>
</li>
<li>header<ul>
<li>Accept、Accept-Language、Content-Language、Content-Type、DPR、Downlink、Save-Data、Viewport-Width、Width</li>
</ul>
</li>
<li>XMLHttpRequestUpload没有事件监听</li>
<li>ReadableStream不存在</li>
</ul>
<p>触发预检：Options</p>
<p>就是除了简单条件以外的，比如put和application/json</p>
<p><strong><em>ie9请使用jsonp</em></strong></p>
<h3 id="Origin请求头"><a href="#Origin请求头" class="headerlink" title="Origin请求头"></a>Origin请求头</h3><ul>
<li>存在跨域，浏览器带上Origin</li>
<li>不存在跨域，请求不带Origin</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> xxx(ctx,next)&#123;</span><br><span class="line">  <span class="keyword">const</span> getOrigin = ctx.get(<span class="string">'Origin'</span>);</span><br><span class="line">  <span class="keyword">if</span>(!getOrigin) <span class="keyword">return</span> <span class="keyword">await</span> next();</span><br><span class="line">  <span class="comment">// 解决跨域请求</span></span><br><span class="line">  ctx.set(<span class="string">'Access-Control-Allow-Origin'</span>,getOrigin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Vary缓存处理"><a href="#Vary缓存处理" class="headerlink" title="Vary缓存处理"></a>Vary缓存处理</h3><p>当存在多个域名需要通过CORS时，会存在响应缓存，需要【避免CDN缓存】，可以配置<code>Vary:Origin</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getOrigin = ctx.get(<span class="string">'Origin'</span>);</span><br><span class="line">ctx.set(<span class="string">'Vary'</span>, <span class="string">'Origin'</span>)</span><br><span class="line"><span class="comment">// xxx</span></span><br></pre></td></tr></table></figure>

<h3 id="cookie处理"><a href="#cookie处理" class="headerlink" title="cookie处理"></a>cookie处理</h3><ul>
<li>withCredentials为true</li>
<li>Access-Control-Allow-Origin为非 *</li>
<li>Access-Control-Allow-Credentials 为 true</li>
</ul>
<h2 id="2、正向代理Node-proxy"><a href="#2、正向代理Node-proxy" class="headerlink" title="2、正向代理Node proxy"></a>2、正向代理Node proxy</h2><p>代理的是客户端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地开发时的接口请求域名设为空</span></span><br><span class="line">proxy: &#123;</span><br><span class="line">    <span class="string">"/api"</span>: &#123;</span><br><span class="line">        target: <span class="string">"http://10.130.10.10:1234"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>charles抓包工具拦截处理代理</p>
<p>在 tools/map remote 中设置Map from和Map to</p>
<h2 id="3、反向代理Nginx"><a href="#3、反向代理Nginx" class="headerlink" title="3、反向代理Nginx"></a>3、反向代理Nginx</h2><p>代理的是服务端</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /api &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、JSONP"><a href="#4、JSONP" class="headerlink" title="4、JSONP"></a>4、JSONP</h2><p>script标签，GET方法</p>
<ul>
<li>定义函数jsonpCallback=function(){}</li>
<li>定义请求参数cb=jsonpCallback</li>
<li>动态接口返回结果运行jsonpCallback({xxx:xxx})</li>
</ul>
<h2 id="5、Websocket"><a href="#5、Websocket" class="headerlink" title="5、Websocket"></a>5、Websocket</h2><p>客户端和服务器之间存在非HTTP，持久，全双工连接</p>
<p>因为不用HTTP，所以就没限制了</p>
<h2 id="6、window-postMessage"><a href="#6、window-postMessage" class="headerlink" title="6、window.postMessage"></a>6、window.postMessage</h2><p><strong><em>可以在 http 返回头 添加X-Frame-Options: SAMEORIGIN 防止被别人添加至 iframe</em></strong></p>
<p><code>&lt;iframe id=&quot;frame&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; src=&quot;http://b.test.com/b.html&quot;&gt;&lt;/iframe&gt;</code></p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的 iframe 消息传递</li>
</ul>
<h2 id="7、document-domain-iframe"><a href="#7、document-domain-iframe" class="headerlink" title="7、document.domain + iframe"></a>7、document.domain + iframe</h2><p>相同主域名，页面A可以拿到iframe页面B的内容</p>
<h2 id="8、window-location-hash-iframe"><a href="#8、window-location-hash-iframe" class="headerlink" title="8、window.location.hash + iframe"></a>8、window.location.hash + iframe</h2><p>A：<code>&lt;iframe src=&quot;http://localhost:8080/hash/c.html#name1&quot;&gt;&lt;/iframe&gt;</code></p>
<p>C：<code>const iframe = document.createElement(&quot;iframe&quot;); iframe.src = &quot;http://localhost:8000/hash/b.html#name2&quot;;
document.body.appendChild(iframe);</code></p>
<p>B：<code>window.parent.parent.location.hash = location.hash;</code></p>
<p>页面A的url的hash值 -&gt; C     AC跨域<br>页面C的url接收hash值 -&gt; B   BC跨域<br>页面B结果给页面A的hash值 -&gt; A   AB跨域</p>
<h2 id="9、window-name-iframe"><a href="#9、window-name-iframe" class="headerlink" title="9、window.name + iframe"></a>9、window.name + iframe</h2><p>location 变化，重新加载，name 可以不变</p>
<p>就是先读取一次后换个iframe的src路径重新加载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A：</span></span><br><span class="line"><span class="keyword">let</span> first = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">        iframe.src = <span class="string">"http://localhost:8000/name/b.html"</span>;</span><br><span class="line">        first = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span><br><span class="line">        <span class="built_in">console</span>.log(iframe.contentWindow.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.html</span></span><br><span class="line">&lt;div&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ c.html</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  window.name = "秋风的笔记";</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="10、浏览器配置"><a href="#10、浏览器配置" class="headerlink" title="10、浏览器配置"></a>10、浏览器配置</h2><p>【慎用】</p>
<p>Windows<br>找到你安装的目录<br>.\Google\Chrome\Application\chrome.exe –disable-web-security –user-data-dir=xxxx</p>
<p>Mac<br><del>/Downloads/chrome-data<br>/Applications/Google\ Chrome\ Canary.app/Contents/MacOS/Google\ Chrome\ Canary  –disable-web-security –user-data-dir=</del>/Downloads/chrome-data</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>和我一起搭建Jenkins</title>
    <url>/2020/07/08/%E5%92%8C%E6%88%91%E4%B8%80%E8%B5%B7%E6%90%AD%E5%BB%BAJenkins/</url>
    <content><![CDATA[<blockquote>
<p>自动化部署工具,释放部署流程</p>
</blockquote>
<a id="more"></a>

<p>运维工具？不存在的，作为开发什么都得了解，之前公司手动部署流程可太麻烦了，不同项目不同流程手动处理，小本本都记不下了</p>
<p>本篇是centos搭建Jenkins持续集成环境的教程</p>
<p><a href="https://mp.weixin.qq.com/s/oiznlZ_4L_0Am2SNOonLDw" target="_blank" rel="noopener">图文版参考链接</a></p>
<hr>
<blockquote>
<p>Jenkins能做什么</p>
</blockquote>
<p>当然是部署自动化啦,java底层的持续集成的工具平台，插件包管理</p>
<ul>
<li>本地代码push到GitHub</li>
<li>Webhook自动触发jenkins上的构建动作</li>
<li>完成安装node插件并且打包</li>
<li>通过Publish Over SSH插件，将打包出来的文件，部署到目标服务器上</li>
</ul>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>github、centos、java sdk、nginx、jenkins</p>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$yum install java</span><br><span class="line"></span><br><span class="line">$ wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo</span><br><span class="line"></span><br><span class="line">$ rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key</span><br><span class="line"></span><br><span class="line">$ yum install jenkins //这一步会比较慢</span><br><span class="line"></span><br><span class="line">// 下载成功，但收到警告xxx.rpm公钥未安装，<span class="built_in">cd</span>到包的目录，执行</span><br><span class="line">rpm -ivh xxx.rpm手动安装</span><br><span class="line"></span><br><span class="line">$ service jenkins restart  //启动 jenkins</span><br><span class="line"></span><br><span class="line">$ cat /var/lib/jenkins/secrets/initialAdminPassword 查看初始密码</span><br></pre></td></tr></table></figure>

<h2 id="配置jenkis的端口"><a href="#配置jenkis的端口" class="headerlink" title="配置jenkis的端口"></a>配置jenkis的端口</h2><p>vi /etc/sysconfig/jenkins<br>修改<br>JENKINS_PORT=”8080”</p>
<p>service jenkins start    // 默认8080，记得服务器开端口<br>service jenkins stop<br>service jenkins restart</p>
<p>systemctl daemon-reload  // 重启</p>
<p>// 选择安装推荐的插件<br>// 等待大约20个包安装<br>// 创建管理员账户<br>// 然后再安装推荐的插件 Rebuilder， SafeRestart，Publish over SSH插件</p>
<p>Publish Over SSH插件安装后进入Configure System，最底下有Publish Over SSH配置</p>
<p>需要配置jenkins服务器和centos服务器的密钥认证</p>
<h2 id="构建第一个任务"><a href="#构建第一个任务" class="headerlink" title="构建第一个任务"></a>构建第一个任务</h2><ul>
<li>选择自由风格</li>
<li>源码管理<code>https://github.com/Gitby-Leo/xxx.git</code><ul>
<li>Credentials绑定仓库账号</li>
</ul>
</li>
<li>构建环境 Provide Node &amp; npm bin/ folder to PATH<ul>
<li>选择开发时的Node版本</li>
</ul>
</li>
<li>构建<ul>
<li>执行shell</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">node -v &amp;&amp;</span><br><span class="line">npm i yarn -g &amp;&amp;</span><br><span class="line">yarn config set registry https://registry.npm.taobao.org &amp;&amp;</span><br><span class="line">yarn install &amp;&amp;</span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure>

<h2 id="配置服务器部署"><a href="#配置服务器部署" class="headerlink" title="配置服务器部署"></a>配置服务器部署</h2><ul>
<li>构建后操作  SSH Server</li>
</ul>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">Name     leo_aly</span><br><span class="line">Source files     build/<span class="emphasis">**/*</span>         编译打包后的目标文件/文件夹</span><br><span class="line">Remove prefix     build            删除目录</span><br><span class="line">Remote directory test1_yarn     创建目录</span><br><span class="line">Exec command</span><br></pre></td></tr></table></figure>

<ul>
<li>应用、保存</li>
</ul>
<p>当仓库有内容时，执行构建可以看到构建进度</p>
<blockquote>
<p>注意Nginx非proxy_pass模式的路径配置</p>
</blockquote>
<h2 id="配置自动构建"><a href="#配置自动构建" class="headerlink" title="配置自动构建"></a>配置自动构建</h2><h3 id="jenkins配置"><a href="#jenkins配置" class="headerlink" title="jenkins配置"></a>jenkins配置</h3><ul>
<li>安装Generic Webhook Trigger插件，用来push代码后自动构建jenkins</li>
<li>配置工程中的构建触发器，选择Generic Webhook Trigger，填写token，才能和github仓库关联<ul>
<li>比如设置简单的16位md5加密123456，token=49ba59abbe56e057</li>
</ul>
</li>
</ul>
<h3 id="github配置"><a href="#github配置" class="headerlink" title="github配置"></a>github配置</h3><ul>
<li>进入仓库settings,左侧webhooks，add webhooks</li>
<li>url配置为xxx:8080/generic-webhook-trigger/invoke?token=49ba59abbe56e057</li>
<li>Just the push event在push代码时触发webhook<br>提交</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>修改一个字符，提交到github，可以看到jenkins面版里自动开始构建，并成功更新</p>
<blockquote>
<p>很久不用docker了</p>
</blockquote>
<p>下一篇用docker打包镜像，自动化容器构建</p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>一条SQL查询语句是如何执行的</title>
    <url>/2020/07/07/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<blockquote>
<p>执行sql语句时都进行了哪些操作</p>
</blockquote>
<a id="more"></a>

<p>这个标题就和点击一个url时都做了什么一样，找寻<a href="https://time.geekbang.org/column/intro/139" target="_blank" rel="noopener">背后的原理</a></p>
<hr>
<p><code>mysql&gt; select * from T where Id=10</code></p>
<p>Server层和存储引擎层</p>
<ul>
<li><ol>
<li>客户端操作</li>
</ol>
</li>
<li><ol start="2">
<li>连接器</li>
</ol>
<ul>
<li>管理连接，权限验证</li>
</ul>
</li>
<li><ol start="3">
<li>查询缓存</li>
</ol>
<ul>
<li>命中返回结果</li>
</ul>
</li>
<li><ol start="3">
<li>分析器</li>
</ol>
<ul>
<li>词法分析，语法分析</li>
<li>查询缓存</li>
</ul>
</li>
<li><ol start="4">
<li>优化器</li>
</ol>
<ul>
<li>索引选择</li>
</ul>
</li>
<li><ol start="5">
<li>执行器</li>
</ol>
<ul>
<li>返回结果</li>
</ul>
</li>
<li><ol start="6">
<li>存储引擎</li>
</ol>
<ul>
<li>读写接口，存储</li>
</ul>
</li>
</ul>
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器，内置函数，存储过程、触发器、视图</p>
<p>存储引擎层负责数据的存储和提取，支持InnoDB、MyISAM、Memory等多个存储引擎，MySQL 5.5.5默认InnoDB</p>
<p>在create table语句中使用engine=memory, 来指定使用内存引擎创建表<br>不同的存储引擎共用一个Server层</p>
<h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>mysql -h$ip -P$port -u$user -p</p>
<p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码</p>
<ul>
<li>用户名或密码不对<ul>
<li>报错，客户端程序结束</li>
</ul>
</li>
<li>用户名密码认证通过<ul>
<li>到权限表里面查出你拥有的权限</li>
<li>权限修改后要重新连接才会刷新</li>
</ul>
</li>
</ul>
<p>show processlist查看状态，空闲状态默认值是8小时</p>
<p>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接<br>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</p>
<p>MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放，<br>长连接占用内存涨得快，内存占用太大会导致MySQL异常重启</p>
<p>定期断开长连接，程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连<br>5.7+用mysql_reset_connection重新初始化，跳过重连和权限验证</p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>MySQL 8.0删除了这个功能</p>
<p>到查询缓存看看，之前是不是执行过这条语句，结果可能会以key-value对的形式，被直接缓存在内存中</p>
<p>不要使用查询缓存，查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空<br>一张静态表，很长时间才会更新一次才适合使用查询缓存</p>
<p>按需使用<br>query_cache_type设置成DEMAND，不使用查询缓存<br>select SQL_CACHE * from T where ID=10使用查询缓存的语句</p>
<h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>执行语句，对SQL语句做解析</p>
<p>词法分析，识别关键字如select查询,T是表名，id是列名</p>
<p>语法分析，根据语法规则判断语句合法</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>在开始执行之前，还要先经过优化器的处理</p>
<p>有多个索引的时候，决定使用哪个索引</p>
<p>有多表关联（join）的时候，决定各个表的连接顺序</p>
<p>mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;</p>
<ul>
<li>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li>
<li>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li>
</ul>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>执行语句</p>
<p>有没有执行查询的权限</p>
<p>根据表的引擎定义，使用这个引擎提供的接口</p>
<ul>
<li>没有索引<ul>
<li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ul>
</li>
<li>有索引<ul>
<li>第一次调用的是“取满足条件的第一行”这个接口</li>
<li>之后循环取“满足条件的下一行”这个接口</li>
</ul>
</li>
</ul>
<p>在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的</p>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>git版本管理工具命令概述</title>
    <url>/2020/07/06/git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>git的命令行语法噢</p>
</blockquote>
<a id="more"></a>

<p>接触git进行版本管理源代码，常用一些基础的推拉命令/sourceTree<br>今天看着旁边大佬一顿操作命令行，执行速度杠杠的，sourceTree在这方面完全不能比</p>
<hr>
<!-- https://copyfuture.com/blogs-details/20200601122538850lylhabd6xw46urm -->
<h2 id="三大区域"><a href="#三大区域" class="headerlink" title="三大区域"></a>三大区域</h2><p>工作区、暂存区和Git仓库(本地/远端)</p>
<p><code>git add, git commit, git push, git merge, git pull, git log</code></p>
<p><code>git add</code><br>会将工作区的文件标记为已暂存，保存在暂存区</p>
<p><code>git commit</code><br>会将标记为已暂存的文件保存都本地Git仓库，并生成一个快照</p>
<p><code>git diff</code><br>查看修改，谢谢您了这个请用可视化吧</p>
<h2 id="未暂存前，撤销修改"><a href="#未暂存前，撤销修改" class="headerlink" title="未暂存前，撤销修改"></a>未暂存前，撤销修改</h2><p><code>git checkout -- .</code><br>撤销所有本地修改</p>
<p><code>git checkout -- [filename]</code><br>撤销指定文件修改</p>
<h2 id="暂存后-撤销修改"><a href="#暂存后-撤销修改" class="headerlink" title="暂存后,撤销修改"></a>暂存后,撤销修改</h2><p><code>git reset .</code><br>撤销暂存区的全部修改</p>
<h2 id="提交到本地仓库后-撤销提交"><a href="#提交到本地仓库后-撤销提交" class="headerlink" title="提交到本地仓库后,撤销提交"></a>提交到本地仓库后,撤销提交</h2><p><code>git commit -m &quot;modify some files&quot;</code><br>提交历史里面会有一条记录</p>
<p><code>git checkout a18c6fa</code><br><code>git log</code><br>回到上一次提交记录，执行log</p>
<p><code>git reset --hard HEAD~1</code><br>或者重置</p>
<p><code>git reflog</code><br><code>git reset --hard f8651ff</code><br>又反悔了，那就再找到f8651ff</p>
<h2 id="修改提交"><a href="#修改提交" class="headerlink" title="修改提交"></a>修改提交</h2><p>提交了一个文件,又想提交一个，但不想2条记录<br><code>git add xx</code><br><code>git commit -m &quot;add test block&quot;</code><br><code>git log</code><br><code>git add src/app/app.component.css</code><br><code>git commit --amend</code>  </p>
<p>修改一个词，会改变之前的id<br><code>git commit --amend -m &quot;add test container&quot;</code></p>
<h2 id="撤销提交历史中的某一次提交"><a href="#撤销提交历史中的某一次提交" class="headerlink" title="撤销提交历史中的某一次提交"></a>撤销提交历史中的某一次提交</h2><p><code>git revert 711bb0b</code></p>
<h2 id="合并出现冲突时撤销合并"><a href="#合并出现冲突时撤销合并" class="headerlink" title="合并出现冲突时撤销合并"></a>合并出现冲突时撤销合并</h2><p><code>git merge --abort</code><br>撤销这个合并,恢复合并之前的状态</p>
<h2 id="移除暂存区的文件"><a href="#移除暂存区的文件" class="headerlink" title="移除暂存区的文件"></a>移除暂存区的文件</h2><p><code>git rm --cached src/test.pptx</code></p>
<h2 id="分支重命名"><a href="#分支重命名" class="headerlink" title="分支重命名"></a>分支重命名</h2><p><code>git br -m [old_br] [new_br]</code></p>
<h2 id="撤销变基操作"><a href="#撤销变基操作" class="headerlink" title="撤销变基操作"></a>撤销变基操作</h2><p><code>git co rebase_test</code><br><code>git rebase master</code></p>
<p>1.使用 git reflog 命令找到变基前的提交 09b0adc<br>2.使用 git reset –hard 09b0adc 重置到该提交</p>
<h2 id="删除远端仓库记录"><a href="#删除远端仓库记录" class="headerlink" title="删除远端仓库记录"></a>删除远端仓库记录</h2><p>密码文件可以通过git快照恢复</p>
<p>git filter-branch –tree-filter ‘rm -f passwords.txt’ HEAD</p>
<h2 id="交互式变基"><a href="#交互式变基" class="headerlink" title="交互式变基"></a>交互式变基</h2><p><code>git rebase -i</code><br>对本地分支进行合并操作，让提交变成一条直线，不适合远程分支操作</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>v-if之用key管理可复用元素</title>
    <url>/2020/07/03/v-if%E4%B9%8B%E7%94%A8key%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<blockquote>
<p>vue key解决了引入相同组件切换时数据互不影响</p>
</blockquote>
<a id="more"></a>

<p>文档细节遗忘导致的问题（面试官：这是基础）</p>
<hr>
<p>日常开发中，遇到一个问题，相同组件引入后，切换发现组件内的数据没有更新/重置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父</span></span><br><span class="line">&lt;code-same v-<span class="keyword">if</span>=<span class="string">"code==1"</span>/&gt;</span><br><span class="line">&lt;code-same v-<span class="keyword">if</span>=<span class="string">"code==2"</span>/&gt;</span><br><span class="line"><span class="keyword">import</span> codeSame <span class="keyword">from</span> <span class="string">"./components/code.vue"</span>;</span><br><span class="line"><span class="comment">// 子</span></span><br><span class="line">&lt;input type=<span class="string">"text"</span> /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="思考1"><a href="#思考1" class="headerlink" title="思考1"></a>思考1</h2><p>是不是受到了keep-alive影响缓存，然而场景下并没有用动态组件，而是v-if</p>
<h2 id="尝试了4种情况"><a href="#尝试了4种情况" class="headerlink" title="尝试了4种情况"></a>尝试了4种情况</h2><p>components引入不同实例组件时正常，而只实例化一次的组件就会缓存</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;!-- 正常 --&gt;</span><br><span class="line">    &lt;code1 v-<span class="keyword">if</span>=<span class="string">"code==1"</span>/&gt;</span><br><span class="line">    &lt;code2 v-<span class="keyword">if</span>=<span class="string">"code==2"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 缓存 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;code-same v-if="code==1" :key="c1"/</span>&gt;</span><br><span class="line">    &lt;code-same v-<span class="keyword">if</span>=<span class="string">"code==2"</span> :key=<span class="string">"c2"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 缓存 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;code-same  v-if="code==`$&#123;code&#125;`" :key="xxx"/</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 正常 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;code-same v-if="code==1" ref="c1" /</span>&gt;</span><br><span class="line">    &lt;code-same2 v-<span class="keyword">if</span>=<span class="string">"code==2"</span> ref=<span class="string">"c2"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">import code1 from "./</span>components/code1.vue<span class="string">";</span></span><br><span class="line"><span class="string">import code2 from "</span>./components/code2.vue<span class="string">";</span></span><br><span class="line"><span class="string">import codeSame from "</span>./components/code.vue<span class="string">";</span></span><br><span class="line"><span class="string">import codeSame2 from "</span>./components/code.vue<span class="string">";</span></span><br></pre></td></tr></table></figure>

<h2 id="思考2"><a href="#思考2" class="headerlink" title="思考2"></a>思考2</h2><p>即时父组件上用了key也不生效<br>等等<br>既然试了父组件的key，也试试子组件的key呗</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input :key=<span class="string">"`c$&#123;dnumber&#125;`"</span> type=<span class="string">"text"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>这次成功了，上面2种缓存的情况回复了正常，切换时输入框不再有值</p>
<p><code>v-if + components</code>时为什么需要加key呢，那就前往官方文档看看~<br><a href="https://cn.vuejs.org/v2/guide/conditional.html" target="_blank" rel="noopener">用key管理可复用的元素</a></p>
<p><code>(Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key attribute 即可)</code></p>
<p>（震惊了，我感觉我没看过文档，尤小右牛皮!）</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>是时候掌握Proxy了</title>
    <url>/2020/07/02/%E6%98%AF%E6%97%B6%E5%80%99%E6%8E%8C%E6%8F%A1Proxy%E4%BA%86/</url>
    <content><![CDATA[<blockquote>
<p>为其他对象提供一种代理以控制对这个对象的访问</p>
</blockquote>
<a id="more"></a>

<h2 id="回顾Object-defineProperty"><a href="#回顾Object-defineProperty" class="headerlink" title="回顾Object.defineProperty"></a>回顾Object.defineProperty</h2><p>只要准备过面试，相信你一定熟知ES5的Object.defineProperty，遍历属性、get/set劫持监听、双向绑定、重写数组原型支持响应式、balabala<br>当然Object.defineProperty还有4大属性，configurable、enumerable、writable、value<br>良好的兼容性</p>
<h3 id="不能一次监听所有属性"><a href="#不能一次监听所有属性" class="headerlink" title="不能一次监听所有属性"></a>不能一次监听所有属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">       <span class="keyword">set</span>() &#123;&#125;,</span><br><span class="line">       <span class="keyword">get</span>() &#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 什么叫简洁啊（战术后仰</span></span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">set</span>() &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="无法监听新增加的属性"><a href="#无法监听新增加的属性" class="headerlink" title="无法监听新增加的属性"></a>无法监听新增加的属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用框架语法</span></span><br><span class="line">Vue.set(obj, <span class="string">"a"</span>, <span class="string">"1"</span>);</span><br><span class="line"><span class="comment">// Proxy直接监听</span></span><br><span class="line">obj.a = <span class="string">"1"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="无法响应数组操作"><a href="#无法响应数组操作" class="headerlink" title="无法响应数组操作"></a>无法响应数组操作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这也是诟病最多的问题了</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">// 改变已存在的项，都生效</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">10</span>; <span class="comment">// 改变长度，添加新的项，只有 Proxy 生效</span></span><br><span class="line">arr.push(<span class="number">10</span>); <span class="comment">// push方法，只有 Proxy 生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 据说Mobx的默认数组长度是1000，比如下面这样写，离谱的hock，但还是比redux香</span></span><br><span class="line">[...Array(<span class="number">1000</span>)].forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">Object</span>.defineProperty(arr, <span class="string">`<span class="subst">$&#123;index&#125;</span>`</span>, &#123;</span><br><span class="line">     <span class="keyword">set</span>() &#123;&#125;,</span><br><span class="line">     <span class="keyword">get</span>() &#123;&#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">arr[<span class="number">30</span>] = <span class="number">10</span>; <span class="comment">// 生效</span></span><br><span class="line">arr[<span class="number">40</span>] = <span class="number">10</span>; <span class="comment">// 生效</span></span><br></pre></td></tr></table></figure>

<h3 id="必考题如何重写数组原型用以支持监听"><a href="#必考题如何重写数组原型用以支持监听" class="headerlink" title="必考题如何重写数组原型用以支持监听"></a>必考题如何重写数组原型用以支持监听</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在定义变量的时候，判断其是否为数组，如果是数组，那么就修改它的 __proto__，将其指向 subArrProto，从而实现重写原型链</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"> <span class="keyword">const</span> subArrProto = <span class="built_in">Object</span>.create(arrayProto);</span><br><span class="line"> <span class="keyword">const</span> methods = [<span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'sort'</span>, <span class="string">'reverse'</span>, <span class="string">'splice'</span>, <span class="string">'push'</span>];</span><br><span class="line"> methods.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 重写原型方法</span></span><br><span class="line">   subArrProto[method] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     arrayProto[method].call(<span class="keyword">this</span>, ...arguments);</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">// 监听新方法</span></span><br><span class="line">   <span class="built_in">Object</span>.defineProperty(subArrProto, method, &#123;</span><br><span class="line">     <span class="keyword">set</span>() &#123;&#125;,</span><br><span class="line">     <span class="keyword">get</span>() &#123;&#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="看看Proxy"><a href="#看看Proxy" class="headerlink" title="看看Proxy"></a>看看Proxy</h2><p>Proxy 构造函数接收两个参数，第一个参数是需要拦截的目标对象，这个对象只可以是对象、数组或者函数<br>第二个参数则是一个配置对象，提供了拦截方法，即使这个配置对象为空对象，返回的 Proxy 新实例也不是原来的目标对象（用Reflect获取原目标对象哦）</p>
<h3 id="令人惊叹的13种拦截操作"><a href="#令人惊叹的13种拦截操作" class="headerlink" title="令人惊叹的13种拦截操作"></a>令人惊叹的13种拦截操作</h3><p>当然有很多和ts的新语法糖一样令人摸不着头脑能用在何处</p>
<!-- https://mp.weixin.qq.com/s/wmMAeZwGV_MK8k7HlkB_7g -->
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>拦截对目标对象属性的读取 get(目标对象,属性名,Proxy 实例)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置私有属性,实现禁止访问</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prop[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;prop&#125;</span> is private attribute`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target[prop]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy._aaa;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给对象中未定义的属性设置默认值</span></span><br><span class="line"><span class="keyword">const</span> defaults = <span class="function">(<span class="params">obj, initial</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">                <span class="keyword">return</span> target[prop]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> initial</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">person = defaults(person, <span class="number">0</span>);</span><br><span class="line">persion.aaa;<span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>拦截对属性的赋值操作 set(目标对象,属性名,属性值,Proxy 实例)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值时打印当前状态</span></span><br><span class="line"><span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> has been set to <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">Reflect</span>.set(target, key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// self属性指向本身</span></span><br><span class="line"><span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'self'</span>) &#123;</span><br><span class="line">        <span class="built_in">Reflect</span>.set(target, key, receiver);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Reflect</span>.set(target, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置不可写时依旧执行set函数，但不会生效</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校验规则扩展</span></span><br><span class="line"><span class="keyword">const</span> validators = &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        validate(value) &#123; <span class="keyword">return</span> value.length &gt; <span class="number">6</span>; &#125;,</span><br><span class="line">        message: <span class="string">'用户名长度不能小于6'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    password: &#123;</span><br><span class="line">        validate(value) &#123; <span class="keyword">return</span> value.length &gt; <span class="number">10</span>; &#125;,</span><br><span class="line">        message: <span class="string">'密码长度不能小于10'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    moblie: &#123;</span><br><span class="line">        validate(value) &#123; <span class="keyword">return</span> <span class="regexp">/^1(3|5|7|8|9)[0-9]&#123;9&#125;$/</span>.test(value); &#125;,</span><br><span class="line">        message: <span class="string">'手机号格式错误'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validator</span>(<span class="params">obj, validators</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="comment">// 属性拦截</span></span><br><span class="line">        <span class="comment">// target =&gt; obj</span></span><br><span class="line">        <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">            <span class="keyword">const</span> validator = validators[key]</span><br><span class="line">            <span class="keyword">if</span> (!validator) &#123;</span><br><span class="line">                target[key] = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (validator.validate(value)) &#123;</span><br><span class="line">                target[key] = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(validator.message || <span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> form = &#123;&#125;;</span><br><span class="line">form = validator(form, validators);</span><br><span class="line">form.name = <span class="string">'666'</span>; <span class="comment">// 提示</span></span><br></pre></td></tr></table></figure>

<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>拦截函数的调用 apply(目标对象,this,参数数组)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取函数调用次数，执行耗时</span></span><br><span class="line"><span class="keyword">const</span> func = <span class="keyword">new</span> <span class="built_in">Proxy</span>(test, &#123;</span><br><span class="line">    _count: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// target =&gt; test</span></span><br><span class="line">    apply(target, context, args) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello, world'</span>);</span><br><span class="line">        target.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">func(); <span class="comment">//执行函数也会执行test()</span></span><br></pre></td></tr></table></figure>

<h3 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h3><p>拦截 new 操作符 construct(目标对象,构造函数的参数列表,Proxy 对象)<br>返回一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> P = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Person, &#123;</span><br><span class="line">    <span class="comment">// target =&gt; Person</span></span><br><span class="line">    construct(target, args, newTarget) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'construct'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> target(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者返回一个新对象</span></span><br><span class="line">    construct(target, args, newTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: args[<span class="number">0</span>],</span><br><span class="line">            age: args[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> P(<span class="string">'tom'</span>, <span class="number">21</span>); <span class="comment">// 'construct'</span></span><br></pre></td></tr></table></figure>

<p><code>构造函数没有返回值或者返回原始类型的值，那么默认返回this，
如果返回引用类型的值，那么最终 new 出来的就是这个值</code></p>
<h2 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h2><h3 id="用于代理类"><a href="#用于代理类" class="headerlink" title="用于代理类"></a>用于代理类</h3><p>对属性设置 get 拦截，对原型函数设置 apply 拦截</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, and my age is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxyTrack = <span class="function">(<span class="params">targetClass</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> prototype = targetClass.prototype;</span><br><span class="line">  <span class="comment">// 获取原型 prototype 上所有的属性名,forEach 遍历并使用 apply 拦截</span></span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyNames(prototype).forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      targetClass.prototype[name] = <span class="keyword">new</span> <span class="built_in">Proxy</span>(prototype[name], &#123;</span><br><span class="line">          apply(target, context, args) &#123;</span><br><span class="line">              <span class="built_in">console</span>.time();</span><br><span class="line">              target.apply(context, args);</span><br><span class="line">              <span class="built_in">console</span>.timeEnd();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetClass, &#123;</span><br><span class="line">    <span class="comment">// 拦截 construct 方法</span></span><br><span class="line">    construct(target, args) &#123;</span><br><span class="line">        <span class="keyword">const</span> obj = <span class="keyword">new</span> target(...args);</span><br><span class="line">        <span class="comment">// 返回一个代理过的对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">            <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;target.name&#125;</span>.<span class="subst">$&#123;prop&#125;</span> is being getting`</span>);</span><br><span class="line">                <span class="keyword">return</span> target[prop]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> MyClass = proxyTrack(Person); <span class="comment">// 先代理</span></span><br><span class="line"><span class="keyword">const</span> myClass = <span class="keyword">new</span> MyClass(<span class="string">'tom'</span>, <span class="number">21</span>);<span class="comment">// 实例化代理类</span></span><br><span class="line">myClass.say(); <span class="comment">// 查看计算时间</span></span><br><span class="line">myClass.name;</span><br></pre></td></tr></table></figure>

<h3 id="对象链取值"><a href="#对象链取值" class="headerlink" title="对象链取值"></a>对象链取值</h3><p>多层属性可选链 a?.b</p>
<p>普通方式:<br>`country.province &amp;&amp; country.province.city &amp;&amp; country.province.city.name;</p>
<p>lodash方式:<br><code>_.get(country, &#39;province.city.name&#39;)</code>;</p>
<p>可选链:<br><code>country?.province?.city?.name</code></p>
<p>Proxy:<br><code>get(country).province.city.name()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">  person:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> isFirst = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyVoid = <span class="keyword">get</span>(undefined);</span><br><span class="line">function <span class="keyword">get</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isFirst) &#123;</span><br><span class="line">            <span class="keyword">return</span> proxyVoid;</span><br><span class="line">        &#125;</span><br><span class="line">        isFirst = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(noop, &#123;</span><br><span class="line">        <span class="comment">// 拦截传入的对象</span></span><br><span class="line">        <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">            <span class="comment">// return target[prop];</span></span><br><span class="line">            <span class="comment">// 不直接返回对象，而是返回代理对象</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                obj !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">                obj !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                obj.hasOwnProperty(prop)</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">get</span>(obj[prop]);</span><br><span class="line">            &#125;</span><br><span class="line">            return proxyVoid;</span><br><span class="line">        &#125;</span><br><span class="line">        // 代理noop，支持返回执行的时候传入的参数</span><br><span class="line">        apply(target, context, [arg]) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj === <span class="literal">undefined</span> ? arg : obj;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">get</span>(obj)() === obj;</span><br><span class="line"><span class="keyword">get</span>(obj).person(); // &#123;&#125;</span><br><span class="line"><span class="keyword">get</span>(obj).person.name(); // undefined</span><br><span class="line"><span class="keyword">get</span>(obj).person.name.xxx.yyy.zzz(); // undefined</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ngrok内网穿透工具</title>
    <url>/2020/07/01/ngrok%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<blockquote>
<p>没有云服务器不要紧，分分钟让局域网资源公网可访问</p>
</blockquote>
<a id="more"></a>

<p>太多教程标题党1分钟、10分钟完成一个ngrok的搭建，这里我只想说，funny mud pee，经过一堆配置报错异常处理后，本篇才是真正的10分钟</p>
<hr>
<p>内网穿透 即 NAT穿透</p>
<p><a href="http://ngrok.cn/docs.html#expose" target="_blank" rel="noopener">详细的中文文档说明</a></p>
<ul>
<li>通过ngrok反向代理服务实现本机在无公网ip时被外部访问</li>
<li>ngrok建立一个安全隧道,主机A的http请求传递给主机B</li>
<li>本地端口所监听的进程转发到远端服务器上，实现穿透</li>
</ul>
<blockquote>
<p>简单的国外官方服务器版 -v2.x - free版不支持自定义域名</p>
</blockquote>
<p>注册并获取授权码<br>如通过github绑定注册的</p>
<ol>
<li>下载<a href="https://ngrok.com/download" target="_blank" rel="noopener">客户端</a><ul>
<li>window版是.exe文件</li>
</ul>
</li>
<li>配置授权码<ul>
<li>Authentication里获取</li>
<li>执行.exe,输入<code>ngrok authtoken xxxxx</code></li>
<li>保存在<code>C:\Users\xxx\.ngrok2\</code>中</li>
</ul>
</li>
<li>本地启动服务器，端口8080<ul>
<li>推荐node下的anywhere，so easy</li>
</ul>
</li>
<li>启动ngrok<ul>
<li>在ngrok.exe进程的shell里</li>
<li>执行ngrok http 8080,</li>
</ul>
</li>
<li>访问<code>http://xxx.ngrok.io</code>等于本地<code>localhost:8080</code><ul>
<li>需等待官方同步</li>
</ul>
</li>
</ol>
<blockquote>
<p>自建服务centos    -v1.7    -自己的域名 （云服务器还是香）</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/53c72ae1446c" target="_blank" rel="noopener">采用了文中的go+docker方案</a></p>
<ul>
<li>公网ip服务器</li>
<li>域名及备案</li>
<li>配置两条二级域名*.ngrok和ngrok</li>
<li>安全组端口开通80、4443是服务通信、4444是tcp端口转发、8000是http请求转发</li>
<li>安全组添加端口白名单和域名</li>
<li>ngrok.sh传到服务器上,执行</li>
</ul>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h3><p><code>docker build -t ngrok .</code></p>
<p>一共10个Step<br>go install -tags ‘release’ ngrok/main/ngrokd会比较慢，等待install8次才成功</p>
<h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><p><code>docker run -it -p 8081:8081 -p 4443:4443 -p 4444:4444 -p 4445:4445 -d ngrok /ngrok/bin/ngrokd -domain=&quot;ngrok.xxx.com&quot; -httpAddr=&quot;:8081&quot;</code></p>
<h3 id="查看镜像列表"><a href="#查看镜像列表" class="headerlink" title="查看镜像列表"></a>查看镜像列表</h3><p><code>docker images</code>，拿到镜像ID，image id</p>
<h3 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h3><p><code>docker ps</code>，拿到容器ID，container id</p>
<h3 id="查看镜像-容器信息"><a href="#查看镜像-容器信息" class="headerlink" title="查看镜像/容器信息"></a>查看镜像/容器信息</h3><p><code>docker inspect id</code></p>
<p>找到挂载目录Mounts.Source</p>
<p>进入这个目录，找到bin/里面选择客户端版本ngrok.exe，下载</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>新建配置文件config.yml，放在刚刚下载的同一层</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server_addr:</span> <span class="string">"ngrok.xxx.com:4443"</span></span><br><span class="line"><span class="attr">trust_host_root_certs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">tunnels:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">proto:</span> <span class="comment"># 本地端口</span></span><br><span class="line">      <span class="attr">http:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">subdomain:</span> <span class="string">test</span> <span class="comment"># 二级域名，没有则自动生成</span></span><br><span class="line">  <span class="attr">tcp12345:</span></span><br><span class="line">    <span class="attr">remote_port:</span> <span class="number">4444</span>  <span class="comment"># tcp隧道中远程服务器端口</span></span><br><span class="line">    <span class="attr">proto:</span></span><br><span class="line">      <span class="attr">tcp:</span> <span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>如果是window客户端，用cmd进入目录后执行<br><code>ngrok -config=config.yml start-all</code></p>
<p>棒不棒！(๑•̀ㅂ•́)و✧，可以通过域名访问本地内容了</p>
<p>如果切换盘符失败可以用<code>cd /d xxx</code></p>
<p>8080是本地启动服务的端口<br>访问时加载速度取决于服务端的带宽</p>
<p><code>http://localhost:4040</code>可以查看本地请求的资源信息</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Quasar基于vue的前端框架-组件</title>
    <url>/2020/06/29/Quasar%E5%9F%BA%E4%BA%8Evue%E7%9A%84%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>上一篇介绍了基于quasar的配置能做些什么<br>本篇了解一下quasar的基于vue的组件</p>
</blockquote>
<a id="more"></a>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>通过v-xxx使用，并且在quasar.config配置文件中提前声明用到的指令<br>framework: {<br>    directives: [‘Ripple’]<br>}<br><code>&lt;div v-touch-pan=&quot;handler&quot;&gt;...&lt;/div&gt;</code></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件名用Q开头QBtn和QElementResizeObservable，同样需要在配置文件中提前声明<br>framework: {<br>  components: [‘QBtn’, ‘QIcon’]<br>}<br><code>&lt;q-icon name=&quot;alarm&quot; /&gt;</code></p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>使用Notify，ActionSheet时，需要在配置文件中提前声明<br>framework: {<br>  plugins: [‘Notify’, ‘ActionSheet’]<br>}</p>
<p>this.$q.notify(‘Some other message’)<br>和<br>import { Notify } from ‘quasar’<br>Notify.create(‘My message’)</p>
<p>framework:’all’导入所有组件用于测试</p>
<h2 id="平台判断"><a href="#平台判断" class="headerlink" title="平台判断"></a>平台判断</h2><p>this.$q.platform.is<br>this.$q.platform.has<br>this.$q.platform.within.iframe</p>
<h2 id="注入原型"><a href="#注入原型" class="headerlink" title="注入原型"></a>注入原型</h2><p>$q.version<br>$q.themem<br>$q.platform<br>$q.i18n<br>$q.cordova<br>$q.electron</p>
<h1 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h1><p>css 类似于bootstrap,通过配置约定的class名称，只需写少量class</p>
<!-- 产品的配置化风格 -->

<h2 id="颜色列表"><a href="#颜色列表" class="headerlink" title="颜色列表"></a>颜色列表</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">// class类</span><br><span class="line">class="text-primary"</span><br><span class="line">class="bg-positive"</span><br><span class="line"></span><br><span class="line">// Stylus变量</span><br><span class="line">color $red-1</span><br><span class="line">backgroung-color grey-5</span><br><span class="line"></span><br><span class="line">// 自定义颜色</span><br><span class="line">.text-brand&#123;</span><br><span class="line"><span class="code">    color:#afsfd</span></span><br><span class="line">&#125;</span><br><span class="line">// 使用自定义颜色</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">q-input</span> <span class="attr">color</span>=<span class="string">"brand"</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>import {colors} from ‘quasar’</p>
<p>设置自定义颜色，相当于setProperty()<br>colors.setBrand(‘light’,’#ddd’,’element’)<br>获取自定义颜色，相当于getPropertyValue()<br>colors.getBrand(‘primary’)<br>getComputedStyle(document.documentElement).getPropertyValue(‘–q-color-primary’)</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>h1</td>
<td>q-display-4</td>
</tr>
<tr>
<td>h2</td>
<td>q-display-3</td>
</tr>
<tr>
<td>h3</td>
<td>q-display-2</td>
</tr>
<tr>
<td>h4</td>
<td>q-display-1</td>
</tr>
<tr>
<td>h5</td>
<td>q-headline</td>
</tr>
<tr>
<td>h6</td>
<td>q-title</td>
</tr>
<tr>
<td>div</td>
<td>q-display-4subheading</td>
</tr>
<tr>
<td>div</td>
<td>q-body2</td>
</tr>
<tr>
<td>div</td>
<td>q-body1</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="粗细"><a href="#粗细" class="headerlink" title="粗细"></a>粗细</h2><p>text-weight-thin<br>text-weight-light<br>text-weight-regular<br>text-weight-medium<br>text-weight-bold<br>text-weight-bolder</p>
<h2 id="文本类型"><a href="#文本类型" class="headerlink" title="文本类型"></a>文本类型</h2><table>
<thead>
<tr>
<th><code>&lt;xxx /&gt;</code></th>
<th>标签</th>
</tr>
</thead>
<tbody><tr>
<td>samll</td>
<td>小文字</td>
</tr>
<tr>
<td>big</td>
<td>大文字</td>
</tr>
<tr>
<td>text-bold</td>
<td>strong粗体</td>
</tr>
<tr>
<td>text-italic</td>
<td>em斜体</td>
</tr>
<tr>
<td>text-right</td>
<td>右侧对齐</td>
</tr>
<tr>
<td>no-margin</td>
<td>设置0</td>
</tr>
<tr>
<td>no-outline</td>
<td>设置0</td>
</tr>
<tr>
<td>block</td>
<td>display设置0</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="间距"><a href="#间距" class="headerlink" title="间距"></a>间距</h2><p>格式：q-[p|m][t|r|b|l|a|x|y]-[none|xs|sm|md|lg|xl]</p>
<p>p-padding<br>m-margin</p>
<p>top、right、bootom、left、all、both left &amp; rigt、both top &amp; bottom</p>
<p>比如：<br>class=”q-pa-sm” // 方向小padding<br>class=”q-mt-md q-mr-sm” // 顶部中margin右边小margin</p>
<h2 id="flex系统"><a href="#flex系统" class="headerlink" title="flex系统"></a>flex系统</h2>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Quasar基于vue的前端框架</title>
    <url>/2020/06/28/Quasar%E5%9F%BA%E4%BA%8Evue%E7%9A%84%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<blockquote>
<p>一次编写，多端应用（非小程序）<br>开箱即用，基于webpack &amp; Vue</p>
</blockquote>
<a id="more"></a>

<h2 id="指南"><a href="#指南" class="headerlink" title="指南"></a>指南</h2><h3 id="官方文档-v1-12-8-版本，国内文档久未更新，本文参考国内站点"><a href="#官方文档-v1-12-8-版本，国内文档久未更新，本文参考国内站点" class="headerlink" title="官方文档 v1.12.8 版本，国内文档久未更新，本文参考国内站点"></a>官方文档 v1.12.8 版本，国内文档久未更新，本文参考国内站点</h3><p>蛮多人推荐 Quasar 的，github 星标也蛮多</p>
<p>而且目前的二级域名也很有意思<a href="http://v0-16.quasarchs.com/guide/quasar-roadmap.html" target="_blank" rel="noopener">v0-16</a></p>
<hr>
<h3 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h3><ul>
<li>响应式 Web</li>
<li>PWA/移动 app</li>
<li>桌面应用</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>开箱即用，默认配置集成（代码压缩、缓存清除、tree shaking、sourcemapping、热重载、代码分割和延迟加载、ES6 转译、i18n、代码检查、可访问性功能 and so on）</li>
<li>一次编写，多端部署</li>
<li>体积小</li>
<li>底层为 webpack</li>
<li>原生 ui 外观</li>
<li>文档简洁(真的吗，我不信。。。果然很全面，内置大量组件及布局，文档很长)</li>
<li>ie11+</li>
<li>组件丰富</li>
</ul>
<p>[Stylus 语法]</p>
<h3 id="简单的官网示例"><a href="#简单的官网示例" class="headerlink" title="简单的官网示例"></a>简单的官网示例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"q-app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"q-ma-md"</span>&gt;</span></span><br><span class="line">    abcdefg</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">q-btn</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"q-ma-md"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">color</span>=<span class="string">"primary"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">icon</span>=<span class="string">"warning"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">label</span>=<span class="string">"notify"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">click</span>=<span class="string">"notify"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"q-ma-md"</span>&gt;</span></span><br><span class="line">      show version is &#123;&#123;version&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">q-btn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#q-app'</span>,</span><br><span class="line">    data:()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            version:Quasar.version</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        notify:()&#123;</span><br><span class="line">            <span class="keyword">this</span>.$q.notify(<span class="string">'[show] version is'</span>+<span class="keyword">this</span>.$q.version);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>虽然你现在还没有了解过 Quasar 语法，但是可以猜测到<br>Quasar 可以结合 Vue 一起使用，Vue 中默认挂载了$q 代表 Quasar</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>三种方式，功能覆盖均不一致</p>
<ul>
<li>UMD(CDN)</li>
<li>Quasar Cli</li>
<li>Vue cli</li>
</ul>
<p>官方推荐用自带的 Cli</p>
<h3 id="入门套件安装"><a href="#入门套件安装" class="headerlink" title="入门套件安装"></a>入门套件安装</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node &gt; <span class="number">8</span></span><br><span class="line">npm install -g vue-cli</span><br><span class="line">npm install -g quasar-cli</span><br><span class="line">quasar init &lt;project&gt;</span><br><span class="line">quasar dev</span><br><span class="line">quasar build</span><br></pre></td></tr></table></figure>

<h3 id="quasar-conf-js-配置文件"><a href="#quasar-conf-js-配置文件" class="headerlink" title="quasar.conf.js 配置文件"></a>quasar.conf.js 配置文件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是对象，dev/build时创建，动态更改配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        <span class="comment">// 开发服务器8000,pwa9000,其他9090</span></span><br><span class="line">        prot:ctx.mode.spa ? <span class="number">8000</span></span><br><span class="line">            :(ctx.mode.pwa?<span class="number">9000</span>:<span class="number">9090</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    extras:[</span><br><span class="line">        <span class="comment">// ctx.theme.mat // 主题选择</span></span><br><span class="line">    ]</span><br><span class="line">    css:[</span><br><span class="line">        ctx.mode.spa?<span class="string">'app-spa.styl'</span>:<span class="literal">null</span>, <span class="comment">// 指向css/app-spa.sty</span></span><br><span class="line">        ctx.mode.cordova?<span class="string">'app-cordova.styl'</span>:<span class="literal">null</span> <span class="comment">// 指向css/app-cordova.styl</span></span><br><span class="line">    ]</span><br><span class="line">    build:&#123;</span><br><span class="line">        extendWebpack(cfg)&#123;</span><br><span class="line">            <span class="comment">// 扩展webpack功能加载器</span></span><br><span class="line">            cfg.module.rules.push(&#123;</span><br><span class="line">              test: <span class="regexp">/\.json$/</span>,</span><br><span class="line">              loader: <span class="string">'json-loader'</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 别名</span></span><br><span class="line">            cfg.resolve.alias = &#123;</span><br><span class="line">                 ...cfg.resolve.alias, <span class="comment">// 添加现有的别名，</span></span><br><span class="line">                <span class="comment">// 添加你自己的别名</span></span><br><span class="line">                myalias: path.resolve(__dirname, <span class="string">'./src/somefolder'</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方法二实现extendWebpack功能</span></span><br><span class="line">        chainWebpack (chain) &#123;</span><br><span class="line">            chain.module.rule(<span class="string">'json'</span>)</span><br><span class="line">              .test(<span class="regexp">/\.json$/</span>)</span><br><span class="line">              .use(<span class="string">'json-loader'</span>)</span><br><span class="line">                .loader(<span class="string">'json-loader'</span>)</span><br><span class="line">            chain.resolve.alias</span><br><span class="line">                .set(<span class="string">'myalias'</span>, path.resolve(__dirname, <span class="string">'./src/somefolder'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// supportIE,framework,animatins,sourceFiles等等配置类似webpack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由-按需路由-资源处理-接口代理和-vue-一致"><a href="#路由-按需路由-资源处理-接口代理和-vue-一致" class="headerlink" title="路由/按需路由/资源处理/接口代理和 vue 一致"></a>路由/按需路由/资源处理/接口代理和 vue 一致</h3><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>根据 quasar 规则解剖插件，以配合 quasar 运行</p>
<p>vue 根组件被实例化之前运行，当启动应用程序时，Quasar 将调用导出的函数，并将具有以下属性的一个对象传递给该函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; app, router, store, Vue &#125;) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 根实例，路由，状态库，vue</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>插件用途比如：<br>挂载实例 this.$xx、安装插件 Vue.use()、路由 router.beforeEach、状态存储库 vuex-router-sync、请求库 vuex-router-sync</p>
<p>插件使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用Quasar CLI在/plugins/下生成一个新的插件</span></span><br><span class="line">quasar <span class="keyword">new</span> plugin &lt;name&gt;</span><br><span class="line"><span class="comment">// 配置文件写用到的插件</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="string">'&lt;name&gt;'</span> <span class="comment">// 指向/src/plugins/&lt;name&gt;.js</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Quasar-生命周期"><a href="#Quasar-生命周期" class="headerlink" title="Quasar 生命周期"></a>Quasar 生命周期</h3><p>1、Quasar 初始化（组件、插件、指令、图标等）<br>2、Quasar Extras 导入（字体、动画、图标等）<br>3、Quasar css 和 css 导入<br>4、App.vue 加载<br>5、Store 导入（如果使用了 Store）<br>6、Quasar 插件导入完成</p>
<ul>
<li>7、在 Electron 模式下）Electron 被导入并注入 Vue 原型<ul>
<li>在 Cordova 模式下）收听“deviceready”事件</li>
<li>存在 Boot 插件，执行应用程序 Boot 插件</li>
<li>不存在 Boot 插件，使用根组件实例化 Vue 并附加到 DOM</li>
</ul>
</li>
</ul>
<p>所以 boot 插件最终是用来 new Vue(app)的</p>
<h3 id="vuex-模块"><a href="#vuex-模块" class="headerlink" title="vuex 模块"></a>vuex 模块</h3><p>和 vue 一致，quasar 提供了命令行模板简化初始化操作<br><code>quasar new store &lt;name&gt;</code>创建 module 模板，然后可以在主 store 里引用这个 modules</p>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>要不怎么说是 UI 框架呢，最大的特点还是它的主题风格<br>/css/themes<br>基于 Stylus 的 Material 和 iOS</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;style lang=<span class="string">"stylus"</span>&gt;</span><br><span class="line">  <span class="comment">// Quasar CLI提供提供的Webpack别名，解析Stylus的变量 @import '~variables'</span></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>9 个平台</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>mat</td>
<td>默认样式 Material 设计主题;Android 平台</td>
</tr>
<tr>
<td>ios</td>
<td>Apple 平台; iOS 主题</td>
</tr>
<tr>
<td>desktop</td>
<td>应用运行在一个桌面浏览器上</td>
</tr>
<tr>
<td>mobile</td>
<td>应用运行在一个手机浏览器上</td>
</tr>
<tr>
<td>cordova</td>
<td>Apache Cordova 包装的独立手机 App</td>
</tr>
<tr>
<td>electron</td>
<td>应用运行在 Electron 下</td>
</tr>
<tr>
<td>touch</td>
<td>触摸感知能力的平台</td>
</tr>
<tr>
<td>no-touch</td>
<td>没有触摸感知能力的平台</td>
</tr>
<tr>
<td>within-iframe</td>
<td>当整个网站都是在一个 IFRAME 标签下的时候</td>
</tr>
</tbody></table>
<h2 id="多端"><a href="#多端" class="headerlink" title="多端"></a>多端</h2><p>文档中有多端打包的配置描述，这里也简述下</p>
<h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><p>需要以下包含以下几点</p>
<p>渐进式-不强制用框架标准开发，生态按需使用<br>响应式-布局适配各端<br>离线访问-service workers 离线并更新保持新状态<br>app 风格-app 式的导航与交互<br>https 安全<br>可发现，mainifests 和 service worker 注册允许被搜索为应用程序<br>推送通知<br>桌面安装-桌面图标<br>可链接</p>
<p>Manifest 文件包含名称，图标和启动页<br>Service Worker 文件用来缓存资源，js 文件、请求数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加pwa模式</span></span><br><span class="line">quasar mode -a pwa</span><br><span class="line"><span class="comment">// 开发模式</span></span><br><span class="line">quasar dev -m pwa</span><br></pre></td></tr></table></figure>

<h3 id="mobile-APP"><a href="#mobile-APP" class="headerlink" title="mobile APP"></a>mobile APP</h3><p>Cordova 移动开发框架<br>既不是真正的原生移动 APP（因为所有的布局渲染都是通过 Web 视图而不是平台的本地 UI 框架完成的），<br>也不是纯粹的基于 Web 的 APP（它们不仅仅是 Web APP，因为可以包装成可分发的 APP, 并可访问本机设备 API）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装cli</span></span><br><span class="line">npm install -g cordova</span><br><span class="line"><span class="comment">// pc安装Android sdk 略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加Cordova模式，生成一个文件夹</span></span><br><span class="line">quasar mode -a cordova</span><br><span class="line"><span class="comment">// 开发模式</span></span><br><span class="line">quasar dev -m cordova -T [android|ios]</span><br></pre></td></tr></table></figure>

<p>Cordova 支持插件，配置获取原生设备信息<br>电池状态、相机、联系人、设备、设备运动、地理位置、媒体、媒体捕捉、网络信息、飞溅屏幕、振动、状态栏</p>
<p>插件执行依赖 Quasar 监听事件 deviceready 完成，然后挂载根 Vue 组件</p>
<h3 id="pc-Electron"><a href="#pc-Electron" class="headerlink" title="pc Electron"></a>pc Electron</h3><p>桌面 GUI 应用程序，后端 NodeJs，前端 Chromium<br>每个 Electron 应用有 2 个线程，主线程处理窗口和启动初始化，渲染线程处理 UI</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加模式</span></span><br><span class="line">quasar mode -a electron</span><br><span class="line"><span class="comment">// 开发模式</span></span><br><span class="line">quasar dev -m electron -t [mat|ios]</span><br></pre></td></tr></table></figure>

<!-- - vue cli
  - vue --version 3.x
  - vue add quasar
  - 配置vue.config.js -->]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解js的面向对象</title>
    <url>/2020/06/26/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3js%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<blockquote>
<p>关键字：封装、继承、多态</p>
</blockquote>
<a id="more"></a>

<p>对象 &gt;&gt;&gt; object</p>
<blockquote>
<p>面向对象三大特性可以</p>
</blockquote>
<p>更轻松的编写代码，用更轻松的方式将代码组织起来<br>在不了解他人代码的情况下配合开发<br>不需要知道程序的每一步细节</p>
<p>对于框架来说，组件背后封装了大量逻辑，比如如何渲染，检测props变化后组件渲染，由于框架已经实现，我们只要去继承使用</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>不用知道内部工作原理，拿来即用</p>
<ul>
<li>汽车，手机</li>
<li>jq 库和 npm 包</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>重用已有的类，不用从零开始，提高维护性</p>
<ul>
<li>基类是车，不同的内饰，外观，功能衍生出各种型号的车</li>
<li>基类是角色，玩家和敌人都有生命值，控制行走，技能</li>
<li>基类是武器，攻击值，攻击距离和攻击效果</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>建立在继承上，才有多态</p>
<ul>
<li>通过调用 type，程序自动选择合适的操作</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>块级作用域和变量提升</title>
    <url>/2020/06/25/%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<a id="more"></a>

<p>上一篇(js 中 var-let-const 的区别)通过变量声明的不同方式简单描述了区别<br>这一篇继续看看变量提升和函数提升</p>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">在群里看到一道题: <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    a = <span class="number">21</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a1"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a2"</span>, a);</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>var 声明的变量会提升至最顶层</p>
<p>let,const 的特殊声明也会提前，并标记为不可再声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 正常打印</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 已声明未初始化</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是【 定义函数名变量, 指针指向 函数内存块】</p>
<p>函数存在块级作用域</p>
<p>将函数声明提到函数级作用域最前面，然后将函数定义提升到块级作用域最前面</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="comment">// 函数 a 的声明提前</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>; <span class="comment">// 赋值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 函数定义 a 声明提升到块级最前面</span></span><br><span class="line">    a = <span class="number">1</span>; <span class="comment">// 块级作用域最前面的函数 a 重置为 1</span></span><br><span class="line">    a = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<br>a1 = ‘21’<br>a2 = ‘1’</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js异常捕获</title>
    <url>/2020/06/23/js%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</url>
    <content><![CDATA[<blockquote>
<p>try catch/Promise 如何捕获运行时异常</p>
</blockquote>
<a id="more"></a>

<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h2><p>能捕捉到的异常必须是线程执行已经进入 try catch, 但 try catch 未执行完时抛出的异常</p>
<h3 id="try-catch的执行周期"><a href="#try-catch的执行周期" class="headerlink" title="try catch的执行周期"></a>try catch的执行周期</h3><blockquote>
<p>执行前 不能捕捉异常</p>
</blockquote>
<p>语法异常（syntaxError）在语法检查阶段报错，未进入 try catch </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    a.</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error"</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行中 能捕捉到异常</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    a.b</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error"</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行后 不能捕捉异常</p>
</blockquote>
<p>线程已经执行完</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;a.b&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error"</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote>
<p>catch</p>
</blockquote>
<p>try catch 无法捕捉 Promise  的异常，用Promise.prototype.catch<br>同步和异步的 Promise 异常都是由 reject 和 Promise.prototype.catch 来捕获</p>
<p>因为 Promise 在执行回调中都用 try catch 包裹起来了，所有的异常都被内部捕获到了，并未往上抛异常，因此在外层的 try catch 看来没有异常</p>
<blockquote>
<p>unhandledrejection</p>
</blockquote>
<p>通过监听unhandledrejection事件，可以捕获未处理的Promise错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unhandledrejection'</span>, event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.reason);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'gg'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>rejectionhandled</p>
</blockquote>
<p>当一个Promise错误最初未被处理，但是稍后又得到了处理，则会触发rejectionhandled事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'rejectionhandled'</span>, event =&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejection handled'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'gg'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = foo();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    f.catch(<span class="function"><span class="params">e</span> =&gt;</span>&#123;&#125;);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode插件夸夸神器Rainbow-Fart</title>
    <url>/2020/06/19/vscode%E6%8F%92%E4%BB%B6%E5%A4%B8%E5%A4%B8%E7%A5%9E%E5%99%A8Rainbow-Fart/</url>
    <content><![CDATA[<blockquote>
<p>Rainbow Fart语音包<br>vscode/git版本升级</p>
</blockquote>
<a id="more"></a>

<h2 id="这是什么"><a href="#这是什么" class="headerlink" title="这是什么"></a>这是什么</h2><p><a href="https://github.com/SaekiRaku/vscode-rainbow-fart/blob/master/README.zh.md" target="_blank" rel="noopener">VSCode Rainbow Fart</a> 是一个在你编程时持续夸你写的牛逼的扩展，可以根据代码关键字播放贴近代码意义的真人语音</p>
<p>扩展仓库搜索<code>Rainbow Fart</code>（五星那个就是了</p>
<p>通过打开命令面板，执行Rainbow Fart，点击open按钮，会启动一个7777端口的server需要授权即可<br><a href="http://127.0.0.1:7777/" target="_blank" rel="noopener">http://127.0.0.1:7777/</a></p>
<p>当你敲代码时候就会出提示音啦（建议带上耳机</p>
<h2 id="vscode升级版本"><a href="#vscode升级版本" class="headerlink" title="vscode升级版本"></a>vscode升级版本</h2><p>有vscode版本限制，我把v1.24升级到了v1.46即可正常从商店安装</p>
<p>升级版本后不用每次提交到仓库都敲一遍账号密码了，vscode简化了这步操作，赞</p>
<h2 id="git升级版本"><a href="#git升级版本" class="headerlink" title="git升级版本"></a>git升级版本</h2><p>升级vscode v1.46之后遇到了暂存文件时git <code>&lt;file&gt; is outside directory</code>的问题，通过github上的<a href="https://github.com/microsoft/vscode/issues/99881#issuecomment-643056608" target="_blank" rel="noopener">issue</a>可以升级git版本解决</p>
<p>git –version<br>当前版本是2.7.2，不支持git update,只有<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">手动安装</a>到原目录</p>
<p>2.14+版本可以使用<code>git update</code><br>2.17.1+版本可以使用<code>git update-git-for-windows</code></p>
]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>必知必会的bind-call-apply</title>
    <url>/2020/06/18/%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84bind-call-apply/</url>
    <content><![CDATA[<blockquote>
<p>this是运行时才确定，用来改变this的指向<br>执行函数并绑定参数 </p>
</blockquote>
<a id="more"></a>

<p>之前一篇文章<a href="../../../../2020/06/14/通过数组边遍历边删除来回顾迭代器/">通过数组边遍历边删除来回顾迭代器</a>附录中描述了一遍this与箭头函数的几种情况</p>
<p><code>当this是null、undefined时，默认指向window</code><br><code>箭头函数无arguments 对象，用 Rest 参数代替</code></p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>call(‘绑定this’,’参数’,’列表’)      立即调用<br>apply(‘绑定this’,[‘参数’,’数组’])   立即调用<br>bind(‘绑定this’,’参数’,’列表’)      返回函数需要再次调用</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用其他函数并传入参数</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    message: <span class="string">'hello: '</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.message + str1 + <span class="string">' '</span> + str2)</span><br><span class="line">&#125;</span><br><span class="line">getName.call(obj, <span class="string">'a'</span>, <span class="string">'b'</span>) <span class="comment">// this指向了obj</span></span><br><span class="line">getName.apply(obj, [<span class="string">'a'</span>, <span class="string">'b'</span>]) <span class="comment">// hello : a b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">89</span>, <span class="number">46</span>]</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.call(<span class="literal">null</span>,arr[<span class="number">0</span>],arr[<span class="number">1</span>],arr[<span class="number">2</span>])<span class="comment">// 89</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr)<span class="comment">//89 合理使用apply处理</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将类数组转化为数组</span></span><br><span class="line"><span class="keyword">var</span> trueArr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br><span class="line"><span class="comment">// 数组arr1更新合并</span></span><br><span class="line"><span class="keyword">var</span> total = [].push.apply(arr1, arr2);</span><br><span class="line"><span class="comment">// 类型判断</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj)</span><br><span class="line"><span class="comment">// 代理 console.log</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> log = <span class="built_in">console</span>.log()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">var</span> Person1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Dot'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Person2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.getname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用Person1对象代替this，使Person2中继承Person1的属性和方法</span></span><br><span class="line">    Person1.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Person3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Person1.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)<span class="comment">//将父元素所有方法在这里执行一遍就继承了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person2();</span><br><span class="line">person.getname();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数珂里化</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>); <span class="comment">// 保存x=1</span></span><br><span class="line"><span class="keyword">var</span> addTen = add(<span class="number">10</span>); <span class="comment">// 保存x=10</span></span><br><span class="line">increment(<span class="number">2</span>);<span class="comment">// 3   1+2</span></span><br><span class="line">addTen(<span class="number">2</span>);<span class="comment">// 12     10+2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现bind</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>,                        <span class="comment">// 保存原函数</span></span><br><span class="line">            context = [].shift.call(<span class="built_in">arguments</span>), <span class="comment">// 保存需要绑定的this上下文</span></span><br><span class="line">            args = [].slice.call(<span class="built_in">arguments</span>);    <span class="comment">// 剩余的参数转为数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                    <span class="comment">// 返回一个新函数</span></span><br><span class="line">            self.apply(context, [].concat.call(args, [].slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>文章题目也不好取啊- -想起之前有本工具手册《MySQL必知必会》，那就用你好了</p>
<hr>
<h1 id="附录1-this"><a href="#附录1-this" class="headerlink" title="附录1 this"></a>附录1 this</h1><p>我们再来看看this的更多例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a1:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// obj</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a3:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a1() <span class="comment">// =&gt; obj.a1.call(undefined) 默认绑定window</span></span><br><span class="line">obj.a2() <span class="comment">// =&gt; obj.a2.call(obj)</span></span><br><span class="line"><span class="keyword">var</span> obja3 = obj.a3;</span><br><span class="line">obja3()  <span class="comment">// =&gt; obj 绑定为window了</span></span><br><span class="line"></span><br><span class="line">id.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// 指向绑定的id元素</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里说一下setTimeout异步函数</span></span><br><span class="line"><span class="comment">// 当callback是普通函数时this是window，丢失this</span></span><br><span class="line"><span class="comment">// 当callback是箭头函数时this是绑定了当前所在作用域的this</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 这里的this都指向实例</span></span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="comment">// 箭头函数也一样</span></span><br><span class="line">    <span class="keyword">this</span>.getAge = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'P'</span>,<span class="number">2</span>)</span><br><span class="line">p.getAge()<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="附录2-函数执行时说明"><a href="#附录2-函数执行时说明" class="headerlink" title="附录2 函数执行时说明"></a>附录2 函数执行时说明</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj1.fn() </span><br><span class="line">obj1.fn.call(obj1);</span><br><span class="line"></span><br><span class="line">fn1()</span><br><span class="line">fn1.call(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">f1(f2)</span><br><span class="line">f1.call(<span class="literal">null</span>,f2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj1.fn() </span><br><span class="line">obj1.fn.apply(obj1);</span><br><span class="line"></span><br><span class="line">fn1()</span><br><span class="line">fn1.apply(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">f1(f2)</span><br><span class="line">f1.apply(<span class="literal">null</span>,f2)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>四类浏览器资源缓存</title>
    <url>/2020/06/17/%E5%9B%9B%E7%B1%BB%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<blockquote>
<p>优先级顺序依次为<code>Memory Cache</code>、<code>Service Worker Cache</code>、<code>HTTP Cache</code>、<code>Push Cache</code></p>
</blockquote>
<a id="more"></a>

<p>面试时经常被问到对缓存有什么理解</p>
<p>好吧每次都是回答的cookie/localstorage/sessionstorage三个本地存储的区别,而忽略了前端最常见的cache，有时候资源更新了页面资源没引用新的文件，就是cache在搞事情</p>
<p>一般资源会经过<code>浏览器发起请求</code>，<code>服务端处理请求</code>，<code>浏览器响应加载</code>三个阶段<br>缓存的作用是性能优化，减少网络请求，减少延迟，重复利用</p>
<hr>
<h2 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h2><p>资源(js,font,img)从内存缓存中获取<br>不会向服务器请求<br>关闭页面会释放内存<br>这个词常在network面板的资源状态中看到from memory cache  </p>
<p>还会看见from disk cache<br>这个是指资源(css)存在硬盘上，关闭页面不会删除资源</p>
<p><code>&lt;link rel=&quot;prefetch&quot;&gt;</code>异步加载优化</p>
<h2 id="Service-Worker-Cache"><a href="#Service-Worker-Cache" class="headerlink" title="Service Worker Cache"></a>Service Worker Cache</h2><p>浏览器离线缓存<br>Service Worker可以拦截修改访问的资源请求，不能访问dom，异步执行，必须https</p>
<p>cache.addAll()缓存文件<br>caches.match(event.request)缓存请求内容</p>
<h2 id="HTTP-Cache"><a href="#HTTP-Cache" class="headerlink" title="HTTP Cache"></a>HTTP Cache</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>200 不请求服务器，使用缓存</p>
<ul>
<li>expires过期时间内不请求  </li>
<li>cache-control控制资源有效时间<ul>
<li>max-age设置有效时间</li>
<li>s-maxage更高优先级，代理服务器中只认这个字段作为有效时间</li>
<li></li>
<li>public客户端和代理服务器可缓存</li>
<li>private只有客户端可缓存</li>
<li></li>
<li>no-cache进行协商缓存方案</li>
<li>no-store直接请求新资源</li>
</ul>
</li>
</ul>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>304 服务器告知资源未更新，使用缓存</p>
<ul>
<li>last-modified资源最后修改时间 &gt; If-modified-since</li>
<li>etag唯一编码 &gt; If-None-Match</li>
</ul>
<h3 id="访问-刷新缓存"><a href="#访问-刷新缓存" class="headerlink" title="访问/刷新缓存"></a>访问/刷新缓存</h3><ul>
<li>标签进入、输入url回车进入<ul>
<li>step1 判断no-cache/no-store<ul>
<li>强缓存    判断expires是否过期</li>
</ul>
</li>
<li>step2 协商缓存</li>
<li>step3 返回新资源200</li>
</ul>
</li>
<li>按刷新按钮、F5 刷新、网页右键“重新加载”<ul>
<li>step1 相当于cache-control 的 max-age = 0</li>
<li>step2 协商缓存</li>
</ul>
</li>
<li>ctrl + F5 强制刷新<ul>
<li>step1 强制设置cache-control: no-cache</li>
</ul>
</li>
</ul>
<h2 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h2><p>推送缓存<br>属于http/2，当以上缓存都未命中时触发<br>会话结束释放缓存</p>
<h2 id="合理使用缓存"><a href="#合理使用缓存" class="headerlink" title="合理使用缓存"></a>合理使用缓存</h2><ul>
<li><p>频繁变动的资源</p>
<ul>
<li>Cache-Control: no-cache，减少响应数据大小</li>
</ul>
</li>
<li><p>不变化的资源</p>
<ul>
<li>Cache-Control: max-age=31536000强制缓存</li>
<li>加版本号更新</li>
</ul>
</li>
</ul>
<hr>
<p>推荐浪里行舟的这篇文章<a href="https://www.jianshu.com/p/54cc04190252" target="_blank" rel="noopener">深入理解浏览器的缓存机制</a>，有使用缓存的流程图</p>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器Iterator与生成器Generator</title>
    <url>/2020/06/16/%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8Generator/</url>
    <content><![CDATA[<blockquote>
<p>迭代器是对象<br>生成器是返回迭代器的函数<br>够直接吧</p>
</blockquote>
<a id="more"></a>

<h1 id="迭代器是什么"><a href="#迭代器是什么" class="headerlink" title="迭代器是什么"></a>迭代器是什么</h1><p>迭代器是包含next方法的<code>对象</code></p>
<p>iterable（可迭代对象）:被外界访问的内部元素的数据结构,实现了 Symbol.iterator 方法<br>iterator（迭代器）:遍历数据结构元素的指针</p>
<h2 id="实现一个迭代器"><a href="#实现一个迭代器" class="headerlink" title="实现一个迭代器"></a>实现一个迭代器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义迭代,数组倒序</span></span><br><span class="line"><span class="keyword">const</span> myArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">myArr[<span class="built_in">Symbol</span>.iterator]= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="keyword">this</span>.length;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="keyword">this</span>[index],<span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">true</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [...myArr]; // [3, 2, 1]</span></span><br><span class="line"><span class="comment">// Array.from(myArr); // [3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<p>myArr有符合标准的 <code>Symbol.iterator 接口</code>，那就是 可迭代的(Iterator) ，调用这个<code>接口</code>返回的对象就是一个 迭代器</p>
<h2 id="关闭迭代器"><a href="#关闭迭代器" class="headerlink" title="关闭迭代器"></a>关闭迭代器</h2><p>1、当next()方法返回done:true时，正常执行结束关闭<br>2、调用符合规范的return()方法关闭</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIterable</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> iterable =&#123;</span><br><span class="line">        [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        next()&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">false</span>,<span class="attr">value</span>:<span class="string">'- -'</span>&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">return</span>()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'~~'</span>);</span><br><span class="line">            <span class="keyword">return</span>&#123;<span class="attr">done</span>:<span class="literal">false</span>,<span class="attr">value</span>:<span class="literal">undefined</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iterable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> myIterable()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生成器Generator"><a href="#生成器Generator" class="headerlink" title="生成器Generator"></a>生成器Generator</h1><p>生成器是返回迭代器的函数<br>Generator既是迭代器也是可迭代对象， 有next()和<a href="">Symbol.iterator</a></p>
<h2 id="使用生成器"><a href="#使用生成器" class="headerlink" title="使用生成器"></a>使用生成器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getIterator = <span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第1次"</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"A"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第2次"</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"B"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第3次"</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"C"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = getIterator();</span><br><span class="line"><span class="comment">// 每次调用next会在yield处返回结果并暂停</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); </span><br><span class="line"><span class="comment">// 传参会替换上一次yield的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">1</span>)); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getIterator2 = <span class="function"><span class="keyword">function</span> *(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ；i &lt; array.length; i++)&#123;</span><br><span class="line">       <span class="keyword">yield</span> array[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目 - 3个苹果，2个香蕉，发完了苹果才能发香蕉</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成器委托</span><br><span class="line">getAppleIterator &#x3D;  function*() &#123;</span><br><span class="line">    yield &quot;a1&quot;</span><br><span class="line">    yield &quot;a2&quot;</span><br><span class="line">    yield &quot;a3&quot;</span><br><span class="line">&#125;</span><br><span class="line">getBananaIterator &#x3D; function*()&#123;</span><br><span class="line">    yield &quot;b1&quot;</span><br><span class="line">    yield &quot;b2&quot;</span><br><span class="line">&#125;</span><br><span class="line">getFruitIterator &#x3D;  function*()&#123;</span><br><span class="line">    yield *getAppleIterator();</span><br><span class="line">    yield *getBananaIterator();</span><br><span class="line">&#125;</span><br><span class="line">fruit &#x3D; getFruitIterator();</span><br><span class="line">console.log(fruit.next());</span><br></pre></td></tr></table></figure>

<p>写到这里，想起以前看《你不知道的js》中有generator的概念，遂又去翻了翻</p>
<p>生成器里写业务，任务工具执行，不关心next()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行callback的里所有内容直到done:true</span></span><br><span class="line"><span class="keyword">let</span> run = <span class="function"><span class="keyword">function</span>(<span class="params">requestIteratorCreator</span>)</span>&#123;</span><br><span class="line">    task = requestIteratorCreator();</span><br><span class="line">	<span class="keyword">let</span> result = task.next(); <span class="comment">// 先执行</span></span><br><span class="line">	doTask = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!result.done)&#123;</span><br><span class="line">            result = task.next(result.value);</span><br><span class="line">            doTask()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	doTask() <span class="comment">// 看看是否继续执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> requestIteratorCreator = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">const</span> result = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">yield</span> result</span><br><span class="line">&#125;</span><br><span class="line">run(requestIteratorCreator)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>一些示例</title>
    <url>/2020/06/15/%E4%B8%80%E4%BA%9B%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<a id="more"></a>
<p>面试时遇到了那些你处理哪些业务场景使用xxx就一脸懵，想不起来啊<br>不知道大家有没有这种感觉，背古诗上半句能接下半句，但是下半句去接上半句就有点难了<br>更何况有些是特性，而非业务<br>anyway,开个目录记录下来，之后一点点在这里补充吧</p>
<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将变量保存进函数，待执行</span><br><span class="line">function makeSizer(size) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    console.log(size)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var size1 &#x3D; makeSizer(10);</span><br><span class="line">size1();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 私有化变量</span><br><span class="line">var Counter &#x3D; function() &#123;</span><br><span class="line">    var privateCounter &#x3D; 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        value: function() &#123;</span><br><span class="line">            return privateCounter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var counter1 &#x3D; Counter();</span><br><span class="line">counter1.value()</span><br></pre></td></tr></table></figure>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工具函数,工具类</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">checkList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">    checkCodeNum(codeNum, maxLen = <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (codeNum == <span class="string">''</span> || codeNum.length != maxLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取字符串并替换节点内容</span></span><br><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"workType"</span> v-getBaTitle=<span class="string">"item.position"</span>&gt;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">directives: &#123;</span></span><br><span class="line"><span class="regexp">    getBaTitle: &#123;</span></span><br><span class="line"><span class="regexp">        bind: function(el, binding) &#123;</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 通过binding.value获取绑定的值，并写入节点内</span></span><br><span class="line"><span class="regexp">            el.innerHTML = binding.value.split("-")[1] || "xxx";</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="遍历时删除，置顶合并数组"><a href="#遍历时删除，置顶合并数组" class="headerlink" title="遍历时删除，置顶合并数组"></a>遍历时删除，置顶合并数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 置顶数组中的指定对象</span></span><br><span class="line">baList(state) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state.list.length == <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> needTopItemArr = [];<span class="comment">// 保存取出来的对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; state.list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state.list[i].serviceStar) &#123;</span><br><span class="line">            needTopItemArr.push(state.list[i]);</span><br><span class="line">            state.list.splice(i, <span class="number">1</span>);</span><br><span class="line">            i--;<span class="comment">// for边循环边删除需要修改i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> needTopItemArr.concat(state.list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p>当有需求改动ui框架样式是，scoped 中的样式不生效，用 /deep/ 解决<br>但是 ios 移动端还不支持，只能这部分重写的内容不要放在 scoped 中</p>
]]></content>
  </entry>
  <entry>
    <title>通过数组边遍历边删除来回顾迭代器</title>
    <url>/2020/06/14/%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E8%BE%B9%E9%81%8D%E5%8E%86%E8%BE%B9%E5%88%A0%E9%99%A4%E6%9D%A5%E5%9B%9E%E9%A1%BE%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>遍历时删除会出现什么问题<br>迭代器是什么,for,forEach,for in,for of都是什么</p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="遍历时删除会出现什么问题"><a href="#遍历时删除会出现什么问题" class="headerlink" title="遍历时删除会出现什么问题"></a>遍历时删除会出现什么问题</h1><p>先看这个例子，遍历数组时删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    arr.splice(i,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(i,arr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">arr.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    arr.splice(index,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 0,[2,3]</span></span><br><span class="line"><span class="comment">// 1,[2]</span></span><br></pre></td></tr></table></figure>
<p>发现结果和期望不一样，应该是个空数组<br>因为当修改原数组时，下一轮用的是这个新的数组，所以第二轮实际上是[2,3]的arr[1]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正序删除，需要更新下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    arr.splice(i,<span class="number">1</span>);</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反序删除</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = arr.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    arr.splice(i,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，java中有iterator.remove()方法进行删除</p>
<hr>
<h1 id="for-forEach-for-in-for-of差异"><a href="#for-forEach-for-in-for-of差异" class="headerlink" title="for,forEach,for in,for of差异"></a><code>for</code>,<code>forEach</code>,<code>for in</code>,<code>for of</code>差异</h1><p>通过MDN来<code>简单</code>回顾一下它们</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a><code>for</code></h2><p>常见的处理<code>数组</code>的循环嘛<br>for (let i = 0; i &lt; 9; i++) {}</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>提前结束<ul>
<li>break退出循环</li>
<li>continue提前结束本次循环，开始下一轮</li>
</ul>
</li>
<li>是所有循环语法糖的基础 </li>
<li>作用域<ul>
<li>使用 var 声明的变量与 for 循环处在同样的作用域中。用 let 声明的变量是语句的局部变量。</li>
</ul>
</li>
</ul>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><code>forEach</code></h2><p>依旧是处理<code>数组</code>的循环，对每个元素依次执行一次指定函数  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.forEach(<span class="function">(<span class="params">item,index,_arr</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// _arr是数组对象本身，不会改变原数组</span></span><br><span class="line">    <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>)</span><br><span class="line">&#125;,<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
<p>那些已删除或者未初始化的项将被跳过（例如稀疏数组[1,,3,,5]）<br>(callback,thisArg) 还接收第二参数this，用法参照函数的this规则，默认指向window，见文末1</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>提前结束<ul>
<li>throw抛出异常</li>
</ul>
</li>
<li>实现浅拷贝，和循环类似<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> copy = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj)) <span class="comment">// 返回指定对象的原型</span></span><br><span class="line">    <span class="keyword">const</span> propNames = <span class="built_in">Object</span>.getOwnPropertyNames(obj); <span class="comment">// 返回属性的属性名</span></span><br><span class="line">    propNames.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, name); <span class="comment">// 返回属性名对应的四大属性描述符configurable,enumerable,value,writable</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(copy, name, desc); <span class="comment">// 更新对象的现有属性</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在遍历时删除会遇到同样的问题，因为每次都是以当前arr执行</li>
<li>扁平化数组,建议使用flat()<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(i))</span><br><span class="line">            result.push(...flatten(i));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result.push(i);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> problem = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>], <span class="number">8</span>, <span class="number">9</span>]];</span><br><span class="line">flatten(problem); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h2><p>和forEach一样都是遍历数组的每一项<br>map()返回新数组，forEach()返回undefined<br>map不会改变原数组，forEach会改变原数组</p>
<h2 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a><code>for in</code></h2><p>以<code>任意顺序</code>遍历一个<code>对象</code>的除Symbol以外的<code>可枚举属性enumerable</code>（包括它的原型链上的可枚举属性）</p>
<p>用于调试，可以更方便的去检查对象属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(prop))&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>迭代过程中不要进行该<code>对象</code>的增删改<ul>
<li>不保证新属性会被访问到</li>
</ul>
</li>
<li>不建议用于<code>数组</code><ul>
<li>因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素</li>
</ul>
</li>
<li>只迭代对象自身的属性<ul>
<li>getOwnPropertyNames() 或 hasOwnProperty() 或 propertyIsEnumerable 确定某属性是否是对象本身的属性</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个例子可以看到由于存在原型链继承规则</span></span><br><span class="line"><span class="comment">// 所以iterable要过滤，否则需要遍历很多不相关元素</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">iterable.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// logs 0, 1, 2, "foo", "arrCustom", "objCustom"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iterable.hasOwnProperty(i)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// logs 0, 1, 2, "foo"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a><code>for of</code></h2><p>在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul>
<li>弥补 forEach 和 for…in 的缺点</li>
<li>提前结束<ul>
<li>break, continue, throw</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String </span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="string">"boo"</span>;</span><br><span class="line"><span class="comment">// 'a' 'b' 'c'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypedArray </span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0x00</span>, <span class="number">0xff</span>]);</span><br><span class="line"><span class="comment">// 0 255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"a"</span>, <span class="number">1</span>], [<span class="string">"b"</span>, <span class="number">2</span>], [<span class="string">"c"</span>, <span class="number">3</span>]]);</span><br><span class="line"><span class="comment">// ["a", 1] ["b", 2] ["c", 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments 对象</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> argument <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(argument);<span class="comment">// 1 2 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> articleParagraphs = <span class="built_in">document</span>.querySelectorAll(<span class="string">"article &gt; p"</span>);</span><br><span class="line"><span class="comment">// item.classList.add("read");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>) </span>&#123;<span class="keyword">yield</span> curr;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> fibonacci()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for-in-of区别"><a href="#for-in-of区别" class="headerlink" title="for in/of区别"></a>for in/of区别</h2><p>迭代方式</p>
<p>for…in 语句以任意顺序迭代对象的<code>可枚举属性</code>。<br>for…of 语句遍历<code>可迭代对象</code>定义要迭代的数据。</p>
<h1 id="迭代器是什么"><a href="#迭代器是什么" class="headerlink" title="迭代器是什么"></a>迭代器是什么</h1><h2 id="迭代器是包含next方法的对象"><a href="#迭代器是包含next方法的对象" class="headerlink" title="迭代器是包含next方法的对象"></a>迭代器是包含next方法的<code>对象</code></h2><p>{done:是否结束，产生下一个值,value:返回值}<br>本质上，迭代器会不断调用其 next() 方法直到返回 done: true  </p>
<p>Array 或 Map 等内置<code>可迭代对象</code>有默认的迭代行为<br>Object 则<code>没有</code>所以不能直接用for…of ，可以用Object.keys(obj)，Object.entries(obj)</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">for..of</span><br><span class="line">扩展运算符</span><br><span class="line">yield*</span><br><span class="line">解构赋值</span><br><span class="line">内置API在接收数组参数时会调用数组的迭代行为</span><br><span class="line"><span class="code">    Array.from()</span></span><br><span class="line"><span class="code">    Map(),Set(),WeakMap(),WeakSet()</span></span><br><span class="line"><span class="code">    Promise.all()/Promise.race()</span></span><br></pre></td></tr></table></figure>
<hr>
<hr>
<hr>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>这里来枚举一下forEach中的this情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    arrFunc1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,_arr</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 普通函数，普通回调，【检查】thisArg，this-&gt;arr</span></span><br><span class="line">            <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>) </span><br><span class="line">        &#125;,arr)</span><br><span class="line">    &#125;,</span><br><span class="line">    arrFunc2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function">(<span class="params">item,index,_arr</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 普通函数，箭头回调，【忽视】thisArg，this-&gt;obj</span></span><br><span class="line">            <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>) </span><br><span class="line">        &#125;,arr)</span><br><span class="line">    &#125;,</span><br><span class="line">    arrFunc3:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,_arr</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 箭头函数，普通回调，【检查】thisArg，this-&gt;arr</span></span><br><span class="line">            <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>) </span><br><span class="line">        &#125;,arr)</span><br><span class="line">    &#125;,</span><br><span class="line">    arrFunc4:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function">(<span class="params">item,index,_arr</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 箭头函数，箭头回调，【忽视】thisArg，this-&gt;window</span></span><br><span class="line">            <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>) </span><br><span class="line">        &#125;,arr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.arrFunc1()</span><br></pre></td></tr></table></figure>

<pre><code class="js"></code></pre>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>最近在看</title>
    <url>/2020/06/12/%E6%9C%80%E8%BF%91%E5%9C%A8%E7%9C%8B/</url>
    <content><![CDATA[<blockquote>
<p>想知道我最近关注什么 点进来看看</p>
</blockquote>
<!-- > 找工作中 T-T....base上海，[查看cv](http://www.leow.net.cn/resume/) -->
<a id="more"></a>
<!-- 正在做 - 2020/6 -->
<p><code>uniapp v2.7</code><br><code>ECharts v4.8</code><br><code>vue-element-admin v4</code><br><code>Element ui</code> (维护频率变低，要流失到ant了- -)</p>
<p>小目标 - 2020<br>更新博客-&gt;github标绿/天</p>
<!-- 计划项 - 2020 -->
<p><code>docker+jenkins</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">周边同事都在用的自动部署方案</span><br></pre></td></tr></table></figure>
<p><code>quasar</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">ui库吧</span><br></pre></td></tr></table></figure>
<p><code>vue stable v3</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">API解构，更hooks了</span><br></pre></td></tr></table></figure>
<p><code>webpack stable v5</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">微前端的模块化</span><br><span class="line">服务暴露独立编译的模块，宿主远程引用</span><br><span class="line">避免重复加载</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>如果你有更有意思的推荐，可以在下方留言给我~</p>
</blockquote>
<hr>
]]></content>
  </entry>
  <entry>
    <title>通过await在definePorperty中的表现重新认识async</title>
    <url>/2020/06/12/%E9%80%9A%E8%BF%87await%E5%9C%A8definePorperty%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86async/</url>
    <content><![CDATA[<blockquote>
<p>defineProperty中无法获取await get()的值<br>再来看看async/await</p>
</blockquote>
<a id="more"></a>
<p>群里聊天时看到抛出的一个问题和相关代码，<code>Object.defineProperty</code>中的get使用await为啥不能同步获取到值<br>用这俩语法糖执行同步任务也有一段时间了，看到这个问题还是有点懵，经过实践解决了这个问题<br>那通过<code>MDN</code>重新再了解一下async/await  </p>
<hr>
<h2 id="异步转同步的发展过程"><a href="#异步转同步的发展过程" class="headerlink" title="异步转同步的发展过程"></a>异步转同步的发展过程</h2><ul>
<li>ajax需要在callback中获取结果，当有请求结果和请求参数有相互依赖时需要多层嵌套，出现回调地狱的代码问题  </li>
<li>而Promise可以在then()中拿到结果，让每步调用写法更清晰，解决回调地狱  </li>
<li>async更简洁，更优雅的错误处理，易于调试  </li>
</ul>
<p><code>async</code>定义一个返回Promise对象的异步函数<br><code>await</code>会暂停异步函数的执行,并等待Promise执行，然后继续执行异步函数，并返回结果<br>是generator生成器的语法糖  </p>
<h2 id="通过俩例子了解一下async-await"><a href="#通过俩例子了解一下async-await" class="headerlink" title="通过俩例子了解一下async/await"></a>通过俩例子了解一下async/await</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'异步结果'</span>, val)</span><br><span class="line">            res(val)</span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'异步getData'</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getVal</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> getData(val)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'正常的异步转同步'</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'getVal'</span>, getVal(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>会发现打印的是一个Promise对象 pending状态，这也符合async的返回，而内部的函数是正常同步执行的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData2</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'异步2结果'</span>, val)</span><br><span class="line">            res(val)</span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'异步2getData2'</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getVal2</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> getData2(val)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'依旧正常的异步转同步'</span>, result)</span><br><span class="line">&#125;</span><br><span class="line">getVal2(<span class="number">33</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'这行还是会先于getVal2执行的哦'</span>)</span><br></pre></td></tr></table></figure>
<p>原来，async/await 保证的是，同一个作用域中存在同步代码和异步代码时，等待获取到promise结果后再执行后续代码</p>
<h2 id="如何解决get中的await取值"><a href="#如何解决get中的await取值" class="headerlink" title="如何解决get中的await取值"></a>如何解决get中的await取值</h2><p>定义一个函数，改变对象的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">target, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="comment">// console.log('执行get', val)</span></span><br><span class="line">            <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    res(<span class="string">'success'</span>)</span><br><span class="line">                &#125;, <span class="number">2000</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// console.log('结束执行Promise', res, val)</span></span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'设置新的值'</span>, newVal)</span><br><span class="line">            val = newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为什么get()中使用async不会生效呢</span></span><br><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</span><br><span class="line">def(a, <span class="string">'id'</span>, <span class="number">1</span>);</span><br><span class="line">a.id = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.id---'</span>, a.id) <span class="comment">// 可以看到返回的是 Promise &#123; &lt;pending&gt; &#125;</span></span><br></pre></td></tr></table></figure>
<p>通过上文关于async/await的语法含义，解决这个问题就很简单了<br>目的是获取get中的await返回val而不是promise<br>通过代理包装一层async/await，就能正常获取get()的值  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取指定对象的当前值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myProxy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对指定对象执行加法运算</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myProxyAddition</span>(<span class="params">obj, key, num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> myProxy(obj[key])</span><br><span class="line">    <span class="keyword">let</span> new_result = result + num;</span><br><span class="line">    obj[key] = new_result;</span><br><span class="line">    <span class="keyword">return</span> new_result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对指定对象执行加法运算</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myProxySubtraction</span>(<span class="params">obj, key, num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> myProxy(obj[key])</span><br><span class="line">    <span class="keyword">let</span> new_result = result - num;</span><br><span class="line">    obj[key] = new_result;</span><br><span class="line">    <span class="keyword">return</span> new_result;</span><br><span class="line">&#125;</span><br><span class="line">myProxyAddition(a, <span class="string">'id'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// myProxySubtraction(a, 'id', 3);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计时器的结果,每隔1秒返回</span></span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> myProxy(a.id)</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        clearInterval(timer)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    myProxyAddition(a, <span class="string">'id'</span>, <span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环的结果,2秒后一起返回</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>].map(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    myProxyAddition(a, <span class="string">'id'</span>, <span class="number">1</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>虽然实际开发中不会遇到defineProperty中await get()的情况，但是通过这次的例子可以加深对语法糖的理解~</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>接口返回10万条数据前端如何加载</title>
    <url>/2020/06/11/%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E10%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<blockquote>
<p>震惊！后端大哥偷懒不分页，前端如何在不影响性能时加载大量数据</p>
</blockquote>
<a id="more"></a>

<p>原文:<a href="https://zhuanlan.zhihu.com/p/147178478" target="_blank" rel="noopener">刘小夕</a></p>
<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"appScrollData"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"poll"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="初级方案，直接渲染"><a href="#初级方案，直接渲染" class="headerlink" title="初级方案，直接渲染"></a>初级方案，直接渲染</h2><p>数据量庞大将导致页面性能极具降低, 造成页面卡顿</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处直接使用了原文中的获取数据方式，只做了同步转换</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">way1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'开始创建'</span>)</span><br><span class="line">        <span class="built_in">console</span>.time(<span class="string">'普通创建对象'</span>)</span><br><span class="line">        <span class="keyword">let</span> box = <span class="built_in">document</span>.createElement(<span class="string">"ul"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">            div1.innerHTML = <span class="string">`<span class="subst">$&#123;res.data[i].title&#125;</span> <span class="subst">$&#123;res.data[i].name&#125;</span> <span class="subst">$&#123;res.data[i].text&#125;</span>`</span></span><br><span class="line">            box.appendChild(div1)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(box, res.data)</span><br><span class="line">        app.appendChild(box)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">'普通创建对象'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 文档碎片创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">way2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'开始创建'</span>)</span><br><span class="line">        <span class="built_in">console</span>.time(<span class="string">'文档碎片创建对象'</span>)</span><br><span class="line">        <span class="keyword">var</span> box = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">            div1.innerHTML = <span class="string">`<span class="subst">$&#123;res.data[i].title&#125;</span> <span class="subst">$&#123;res.data[i].name&#125;</span> <span class="subst">$&#123;res.data[i].text&#125;</span>`</span></span><br><span class="line">            box.appendChild(div1)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(box, res.data)</span><br><span class="line">        app.appendChild(box)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">'文档碎片创建对象'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// way1();</span></span><br><span class="line"><span class="comment">// way2();</span></span><br></pre></td></tr></table></figure>

<p>这里用到了 console.time/console.timeEnd 计算函数运行时长<br>注意为什么<code>console.timeEnd</code>放在了<code>setTimeout</code>中？<br>事件循环先宏任务，再微任务，最后更新ui<br>setTimeout属于宏任务<br>这里需要得到能够渲染数据后的运行时长，所以放在了下一轮宏任务中，能够准确获取总</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 10w数据  普通                    文档碎片</span><br><span class="line">&#x2F;&#x2F; chrome   10521.47412109375ms     12217.3671875ms</span><br><span class="line">&#x2F;&#x2F; edge     8409.425048828125ms     8900.69287109375ms</span><br><span class="line">&#x2F;&#x2F; firefox  828ms                   卡崩溃了</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(createDocumentFragment真的更快吗？大家可以测试告诉我)</p>
</blockquote>
<h2 id="中级方案，懒加载-分页"><a href="#中级方案，懒加载-分页" class="headerlink" title="中级方案，懒加载+分页"></a>中级方案，懒加载+分页</h2><p>渲染首屏，后续窗口滚动时防抖优化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getApiData = [];</span><br><span class="line"><span class="keyword">let</span> way3Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分页</span></span><br><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line"><span class="keyword">let</span> curPage = <span class="number">1</span>; <span class="comment">// 当前的页数</span></span><br><span class="line"><span class="keyword">let</span> pageSize = <span class="number">30</span>; <span class="comment">// 每一页展示的数量 * data 传入的数据量</span></span><br><span class="line"><span class="keyword">let</span> prevY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">way3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        getApiData = res.data;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> time = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        clearTimeout(time);</span><br><span class="line">        time = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听scroll事件，使用getBoundingClientRect获取底部空占位元素相对于可视窗口的距离进行懒加载</span></span><br><span class="line"><span class="comment">// 回滚时需要单向锁</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollAndLoading</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.scrollY &gt; prevY) &#123; <span class="comment">// 判断用户是否向下滚动</span></span><br><span class="line">        prevY = <span class="built_in">window</span>.scrollY; <span class="comment">// 在向下滚动并且滚动高度大于上一次时更新</span></span><br><span class="line">        <span class="keyword">if</span> (poll.getBoundingClientRect().top &lt;= <span class="built_in">window</span>.innerHeight) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getApiData.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'getApiData数据还未请求返回'</span>);</span><br><span class="line">            <span class="comment">// 请求下一页数据,每次渲染量为pageSize</span></span><br><span class="line">            curPage++;</span><br><span class="line">            way3Data = getApiData.slice(pageSize * (curPage - <span class="number">1</span>), pageSize * curPage)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'开始创建'</span>, way3Data.length / getApiData.length)</span><br><span class="line">            <span class="built_in">console</span>.time(<span class="string">'文档碎片创建对象'</span>)</span><br><span class="line">            <span class="keyword">var</span> box = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; way3Data.length; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">                div1.innerHTML = <span class="string">`<span class="subst">$&#123;way3Data[i].title&#125;</span> <span class="subst">$&#123;way3Data[i].name&#125;</span> <span class="subst">$&#123;way3Data[i].text&#125;</span>`</span></span><br><span class="line">                box.appendChild(div1)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(box, way3Data)</span><br><span class="line">            app.appendChild(box)</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.timeEnd(<span class="string">'文档碎片创建对象'</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// way3();</span></span><br><span class="line"><span class="comment">// const getWay3Data = debounce(scrollAndLoading, 300)</span></span><br><span class="line"><span class="comment">// window.addEventListener('scroll', getWay3Data, false)</span></span><br></pre></td></tr></table></figure>

<h2 id="高级方案，更优雅的实现方式"><a href="#高级方案，更优雅的实现方式" class="headerlink" title="高级方案，更优雅的实现方式"></a>高级方案，更优雅的实现方式</h2><ul>
<li>js缓冲器来分片处理</li>
<li>虚拟长列表 核心思路就是每次只渲染可视区域的列表数,当滚动后动态的追加元素并通过顶部padding来撑起整个滚动内容</li>
<li>web worker来将需要在前端进行大量计算的逻辑移入进去, 保证js主进程的快速响应, 让web worker线程在后台计算</li>
<li>模糊搜索，二分法优化</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的写法每轮是取数组第一项，并执行添加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multistep</span>(<span class="params">steps, taskHandle, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// var tasks = steps.concat();</span></span><br><span class="line">    <span class="keyword">var</span> tasks = steps;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> task = tasks.shift(); <span class="comment">// 每次执行一步</span></span><br><span class="line">        <span class="comment">// task.apply(null, args || []); //调用Apply参数必须是数组</span></span><br><span class="line">        taskHandle(task);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// arguments.callee代表multistep函数</span></span><br><span class="line">            setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">25</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">25</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">way4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        getApiData = res.data;</span><br><span class="line">        multistep(getApiData, <span class="function"><span class="keyword">function</span>(<span class="params">_arr</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// console.time('文档碎片创建对象')</span></span><br><span class="line">            <span class="keyword">let</span> box = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">            <span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">            div1.innerHTML = <span class="string">`<span class="subst">$&#123;_arr.title&#125;</span> <span class="subst">$&#123;_arr.name&#125;</span> <span class="subst">$&#123;_arr.text&#125;</span>`</span>;</span><br><span class="line">            box.appendChild(div1);</span><br><span class="line">            app.appendChild(box);</span><br><span class="line">            <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">            <span class="comment">//     console.timeEnd('文档碎片创建对象')</span></span><br><span class="line">            <span class="comment">// &#125;)</span></span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'way4完成'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// way4()</span></span><br></pre></td></tr></table></figure>
<p>这里用分片处理，每个事件循环周期处理几十条数据,每轮5ms<br>步骤的集合，每次执行的依赖参数，完成结果回调</p>
<hr>
<p>无论采取什么方案，最终目的是释放主线程，让用户可进行交互操作时，无卡顿感知</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>创建新的window隔离沙箱</title>
    <url>/2020/06/11/%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84window%E9%9A%94%E7%A6%BB%E6%B2%99%E7%AE%B1/</url>
    <content><![CDATA[<blockquote>
<p>一起来了解下~<br><code>target=&quot;_blank</code>的安全隐患<br>当window下的全局方法被污染了，如何获取到原本的全局方法getComputedStyle</p>
</blockquote>
<a id="more"></a>

<p>前情提要<br>  1、 <code>target=&quot;_blank&quot;</code>的安全/性能隐患<br>  2、window被污染后当前网页找到一个新的window</p>
<hr>
<p>看到一篇文章，讲的是<code>&lt;a/&gt;</code>标签的<code>target=&quot;_blank&quot;</code>的安全/性能隐患<br>众所周知，这个操作会打开一个新窗口</p>
<ul>
<li>有数据表面国外站点倾向于当前页跳转，有连贯性，减少窗口数量</li>
<li>而国内站点倾向于打开新窗口，优化搜索结果及返回页</li>
</ul>
<h2 id="那会有什么安全-性能隐患呢？"><a href="#那会有什么安全-性能隐患呢？" class="headerlink" title="那会有什么安全/性能隐患呢？"></a>那会有什么安全/性能隐患呢？</h2><p>window.opener获取到来源页面的window对象，即时跨域也不受影响 <code>excuse me?</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父 http://xx.xx.xx.xx:8000/父.html</span></span><br><span class="line">&lt;a href=<span class="string">"http://localhost:8000/子.html"</span> target=<span class="string">"_blank"</span>&gt;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子 http:/</span><span class="regexp">/localhost:8000/</span>子.html</span><br><span class="line"><span class="built_in">window</span>.opener.location = <span class="string">'https://www.baidu.com'</span></span><br></pre></td></tr></table></figure>
<p>在ip跨域时，竟然真的触发了父跳转，这被钓鱼可咋办</p>
<p><code>target=&quot;_blank&quot;</code>的窗口和父窗口公用一个进程，so资源占用你懂的</p>
<blockquote>
<p>如何保障你的网站外链合规</p>
</blockquote>
<ul>
<li>为了防止CSRF攻击<ul>
<li>父页面跳转到钓鱼登录页</li>
<li>发送带参get请求</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父 在a标签上加属性</span></span><br><span class="line">&lt;a rel=<span class="string">"noopener"</span> /&gt;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">&lt;a rel=<span class="string">"noreferrer"</span>/&gt;</span><br><span class="line"><span class="comment">/////////////////////////////</span></span><br><span class="line"><span class="comment">// 或者重写open()</span></span><br><span class="line"><span class="keyword">var</span> window_open = <span class="built_in">window</span>.open();</span><br><span class="line">window_open.opener = <span class="literal">null</span>;</span><br><span class="line">window_open.location = <span class="string">'yourUrl'</span>;</span><br><span class="line">window_open.target = <span class="string">"_blank"</span>;</span><br></pre></td></tr></table></figure>
<p>这样子窗口就是独立的进程了</p>
<p>hexo的主题已经支持这个方案了，不过插件生态好像并没有，（比如文末的本文链接- -,可以提issue了）</p>
<h2 id="如何找到新的window"><a href="#如何找到新的window" class="headerlink" title="如何找到新的window"></a>如何找到新的window</h2><p>回忆起遇到了这么一题，getComputedStyle方法被重写了，要获取css伪元素的content中的文字，当前页面的window被污染了，从哪里得到新的window呢</p>
<blockquote>
<p>iframe和open</p>
</blockquote>
<p>以getComputedStyle举例，这里就放部分代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父</span></span><br><span class="line">#t1::before &#123;content: '我是父t1';&#125;</span><br><span class="line"><span class="built_in">window</span>.getComputedStyle = <span class="string">""</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'通过子获取父style'</span>, <span class="built_in">window</span>.frames[<span class="string">'iframe1'</span>].contentWindow.getComputedStyle(<span class="built_in">document</span>.getElementById(<span class="string">'t1'</span>), <span class="string">':before'</span>).content)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'调用子方法'</span>,<span class="built_in">window</span>.frames[<span class="string">'iframe1'</span>].contentWindow.funcLeo_c())</span><br><span class="line"><span class="comment">// 子</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'从子获取父style'</span>, <span class="built_in">window</span>.getComputedStyle(<span class="built_in">window</span>.parent.document.getElementById(<span class="string">'t1'</span>), <span class="string">':before'</span>).content)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'调用父方法'</span>,<span class="built_in">window</span>.parent.funcLeo_p())</span><br></pre></td></tr></table></figure>

<p>当然还有上文提到的open()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="built_in">window</span>.open(<span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.log(win.getComputedStyle(<span class="built_in">document</span>.getElementById(<span class="string">'t1'</span>), <span class="string">':before'</span>).content)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>不一样的console-log</title>
    <url>/2020/06/10/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84console-log/</url>
    <content><![CDATA[<blockquote>
<p>来看看 控制台中console的各种实现~</p>
</blockquote>
<a id="more"></a>

<ul>
<li>console.log 用于输出普通信息</li>
<li>console.info 用于输出提示性信息</li>
<li>console.error 用于输出错误信息</li>
<li>console.warn 用于输出警示信息</li>
<li>console.group&amp;console.groupEnd 输出一组信息</li>
<li>console.table 信息通过表格展示</li>
<li>console.count 函数执行次数</li>
<li>console.dir将Dom 树结构输出</li>
<li>console.time 计时开始</li>
<li>console.timeEnd 计时结束</li>
<li>console.profile&amp;console.profileEnd 查看CPU使用相关信息、</li>
<li>console.timeLine&amp;console.timeLineEnd 记录一段时间轴</li>
<li>console.trace 堆栈跟踪相关的调试</li>
</ul>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>复制代码贴入console中试试看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 换行</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第一行\n第二行'</span>);</span><br><span class="line"><span class="comment">// 样式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'%c换个颜色'</span>,<span class="string">'color:blue;'</span>);</span><br><span class="line"><span class="comment">// 图片</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"%c "</span>,<span class="string">"background: url(https://gitby-leo.github.io/images/avatar.jpg) no-repeat center;padding-left:80px;padding-bottom: 80px;"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="字符画"><a href="#字符画" class="headerlink" title="字符画"></a>字符画</h2><p>打开<a href="http://patorjk.com/" target="_blank" rel="noopener">http://patorjk.com/</a>找到<a href="http://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type%20Something%20" target="_blank" rel="noopener">Text to ASCII Art Generator</a></p>
<p>目前支持315种英文字符样式</p>
<p>字符生成复制后直接放console</p>
<p>npm包，如<a href="https://www.npmjs.com/package/figlet" target="_blank" rel="noopener">figlet</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开控制台可见</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`</span></span><br><span class="line"><span class="string"> __    ____  _____ </span></span><br><span class="line"><span class="string">(  )  ( ___)(  _  )</span></span><br><span class="line"><span class="string"> )(__  )__)  )(_)( </span></span><br><span class="line"><span class="string">(____)(____)(_____)</span></span><br><span class="line"><span class="string">`</span>)</span><br></pre></td></tr></table></figure>
<script>
console.log(`
 __    ____  _____ 
(  )  ( ___)(  _  )
 )(__  )__)  )(_)( 
(____)(____)(_____)
`) 
</script>

<pre><code class="js">&lt;script&gt;
<span class="built_in">console</span>.log(<span class="string">`</span>
<span class="string">          _____            _____                   _______         </span>
<span class="string">         /\    \          /\    \                 /::\    \        </span>
<span class="string">        /::\____\        /::\    \               /::::\    \       </span>
<span class="string">       /:::/    /       /::::\    \             /::::::\    \      </span>
<span class="string">      /:::/    /       /::::::\    \           /::::::::\    \     </span>
<span class="string">     /:::/    /       /:::/\:::\    \         /:::/~~\:::\    \    </span>
<span class="string">    /:::/    /       /:::/__\:::\    \       /:::/    \:::\    \   </span>
<span class="string">   /:::/    /       /::::\   \:::\    \     /:::/    / \:::\    \  </span>
<span class="string">  /:::/    /       /::::::\   \:::\    \   /:::/____/   \:::\____\ </span>
<span class="string"> /:::/    /       /:::/\:::\   \:::\    \ |:::|    |     |:::|    |</span>
<span class="string">/:::/____/       /:::/__\:::\   \:::\____\|:::|____|     |:::|    |</span>
<span class="string">\:::\    \       \:::\   \:::\   \::/    / \:::\    \   /:::/    / </span>
<span class="string"> \:::\    \       \:::\   \:::\   \/____/   \:::\    \ /:::/    /  </span>
<span class="string">  \:::\    \       \:::\   \:::\    \        \:::\    /:::/    /   </span>
<span class="string">   \:::\    \       \:::\   \:::\____\        \:::\__/:::/    /    </span>
<span class="string">    \:::\    \       \:::\   \::/    /         \::::::::/    /     </span>
<span class="string">     \:::\    \       \:::\   \/____/           \::::::/    /      </span>
<span class="string">      \:::\    \       \:::\    \                \::::/    /       </span>
<span class="string">       \:::\____\       \:::\____\                \::/____/        </span>
<span class="string">        \::/    /        \::/    /                 ~~              </span>
<span class="string">         \/____/          \/____/                                  </span>
<span class="string"></span>
<span class="string">`</span>) </code></pre>
<p></script></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>用Web Components写摄像头组件</title>
    <url>/2020/06/08/%E7%94%A8Web%20Components%E5%86%99%E6%91%84%E5%83%8F%E5%A4%B4%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>Web Components中最佳特性就是shadow DOM的防污染封装<br>来看看怎么实现一个摄像头组件吧~</p>
</blockquote>
<a id="more"></a>

<p>原文:<a href="https://www.w3cplus.com/javascript/how-to-build-the-simple-camera-component.html" target="_blank" rel="noopener">大漠w3c</a></p>
<hr>
<ul>
<li>使用MediaDevices API获取相机访问权限</li>
<li>使用video元素播放MediaStream</li>
<li>使用canvas元素以blob或base64形式拍照</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;simple-camera&gt;&lt;/simple-camera&gt;</span></span><br><span class="line"><span class="comment">// &lt;button id="btnPhoto"&gt;拍一张&lt;/button&gt;</span></span><br><span class="line"><span class="comment">// &lt;button id="btnBase64Photo"&gt;转为base64&lt;/button&gt;</span></span><br><span class="line"><span class="comment">// &lt;img id="base64Img" src="#" alt=""&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCamera</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125; <span class="comment">// 当元素连接到DOM时调用这个函数</span></span><br><span class="line">    connectedCallback() &#123; </span><br><span class="line">        <span class="comment">// shadow样式保持 </span></span><br><span class="line">        <span class="keyword">const</span> shadow = <span class="keyword">this</span>.attachShadow(&#123;</span><br><span class="line">            mode: <span class="string">'open'</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.videoElement = <span class="built_in">document</span>.createElement(<span class="string">'video'</span>);</span><br><span class="line">        <span class="keyword">this</span>.canvasElement = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">        <span class="keyword">this</span>.videoElement.setAttribute(<span class="string">'playsinline'</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.canvasElement.style.display = <span class="string">'none'</span>;</span><br><span class="line"></span><br><span class="line">        shadow.appendChild(<span class="keyword">this</span>.videoElement);</span><br><span class="line">        shadow.appendChild(<span class="keyword">this</span>.canvasElement)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配给目标元素执行</span></span><br><span class="line">    open(constraints) &#123;</span><br><span class="line">        <span class="comment">// 本地测试不要使用ip，要用localhost，否则没有navigator.mediaDevices</span></span><br><span class="line">        <span class="keyword">return</span> navigator.mediaDevices.getUserMedia(constraints)</span><br><span class="line">            .then(<span class="function">(<span class="params">mediaStream</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 分配MediaStream </span></span><br><span class="line">                <span class="keyword">this</span>.videoElement.srcObject = mediaStream;</span><br><span class="line">                <span class="comment">// 加载时播放流 </span></span><br><span class="line">                <span class="keyword">this</span>.videoElement.onloadedmetadata = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.videoElement.play()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从video元素中绘制帧</span></span><br><span class="line">    _drawImage() &#123;</span><br><span class="line">        <span class="keyword">const</span> imageWidth = <span class="keyword">this</span>.videoElement.videoWidth;</span><br><span class="line">        <span class="keyword">const</span> imageHeight = <span class="keyword">this</span>.videoElement.videoHeight;</span><br><span class="line">        <span class="keyword">this</span>.canvasElement.width = imageWidth;</span><br><span class="line">        <span class="keyword">this</span>.canvasElement.height = imageHeight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> context = <span class="keyword">this</span>.canvasElement.getContext(<span class="string">'2d'</span>);</span><br><span class="line">        context.drawImage(<span class="keyword">this</span>.videoElement, <span class="number">0</span>, <span class="number">0</span>, imageWidth, imageHeight);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            imageHeight,</span><br><span class="line">            imageWidth</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// canvas的toBlob()转为同步</span></span><br><span class="line">    takeBlobPhoto() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">            imageHeight,</span><br><span class="line">            imageWidth</span><br><span class="line">        &#125; = <span class="keyword">this</span>._drawImage();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.canvasElement.toBlob(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">                resolve(&#123;</span><br><span class="line">                    blob,</span><br><span class="line">                    imageHeight,</span><br><span class="line">                    imageWidth</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// canvase转base64</span></span><br><span class="line">    takeBase64Photo(&#123;</span><br><span class="line">        type,</span><br><span class="line">        quality</span><br><span class="line">    &#125; = &#123;</span><br><span class="line">        type: <span class="string">'png'</span>,</span><br><span class="line">        quality: <span class="number">1</span></span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">            imageHeight,</span><br><span class="line">            imageWidth</span><br><span class="line">        &#125; = <span class="keyword">this</span>._drawImage();</span><br><span class="line">        <span class="keyword">const</span> base64 = <span class="keyword">this</span>.canvasElement.toDataURL(<span class="string">'image/'</span> + type, quality);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            base64,</span><br><span class="line">            imageHeight,</span><br><span class="line">            imageWidth</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用自定义元素了</span></span><br><span class="line">customElements.define(<span class="string">'simple-camera'</span>, SimpleCamera)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> camera = <span class="built_in">document</span>.querySelector(<span class="string">'simple-camera'</span>)</span><br><span class="line">    <span class="keyword">const</span> btnBlobPhoto = <span class="built_in">document</span>.querySelector(<span class="string">'#btnBlobPhoto'</span>)</span><br><span class="line">    <span class="keyword">const</span> btnBase64Photo = <span class="built_in">document</span>.querySelector(<span class="string">'#btnBase64Photo'</span>)</span><br><span class="line">    <span class="keyword">const</span> base64Img = <span class="built_in">document</span>.getElementById(<span class="string">'base64Img'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> camera.open(&#123;</span><br><span class="line">        video: &#123;</span><br><span class="line">            facingMode: <span class="string">'user'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'摄像头开启失败'</span>, err)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    btnPhoto.addEventListener(<span class="string">'click'</span>, <span class="keyword">async</span> event =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> photo = <span class="keyword">await</span> camera.takeBlobPhoto()</span><br><span class="line">        <span class="built_in">console</span>.log(photo)</span><br><span class="line">        base64Img.src = URL.createObjectURL(photo.blob);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    btnBase64Photo.addEventListener(<span class="string">'click'</span>, <span class="keyword">async</span> event =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> photo = camera.takeBase64Photo(&#123;</span><br><span class="line">            type: <span class="string">'jpeg'</span>,</span><br><span class="line">            quality: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(photo)</span><br><span class="line">        base64Img.src = photo.base64;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>javascript</category>
        <category>Web Component</category>
      </categories>
      <tags>
        <tag>Web Component</tag>
      </tags>
  </entry>
  <entry>
    <title>js中var/let/const的区别</title>
    <url>/2020/05/31/js%E4%B8%ADvar/let/const%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>三种变量声明很常见，就来说点不一样的  </p>
<ul>
<li>原来还有全局对象和顶层对象  </li>
<li>为什么我定义的变量和函数无法delete</li>
</ul>
</blockquote>
<a id="more"></a>

<p>刚接触js时，声明一个变量会用var或者function，共2种</p>
<ul>
<li>var声明的全局变量</li>
<li>var在函数范围内声明的局部变量</li>
<li>eval中声明的全局变量。</li>
</ul>
<p>在es6中，新增了let/const/import/class，共6种</p>
<hr>
<h2 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h2><p>浏览器环境中顶层对象是window，Node中是global对象</p>
<ul>
<li>ES5中，顶层对象的属性等价于全局变量</li>
<li>ES6中，var、function声明的全局变量<strong>属于</strong>顶层对象，其他4个则<strong>不属于</strong>顶层对象<br>,所以es6中的全局变量和顶层对象的属性分离。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.info(<span class="built_in">window</span>.b);  <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.info(<span class="built_in">window</span>.c);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.info(<span class="keyword">this</span>.len)</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// undefined,此时this为window</span></span><br><span class="line"><span class="keyword">let</span> Person = &#123;</span><br><span class="line">	len: <span class="number">5</span>,</span><br><span class="line">	say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		fn(); <span class="comment">// undefined 此时this为window</span></span><br><span class="line">		<span class="built_in">arguments</span>[<span class="number">0</span>](); <span class="comment">// undefined 此时调用fn方法，arguments对象里没有len属性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.say(fn);<span class="comment">// this为Person</span></span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>arguments.length表示传入函数的实参数量</li>
<li>函数本身的length属性代表的是函数定义时给出的参数个数</li>
</ul>
<hr>
<h2 id="变量删除"><a href="#变量删除" class="headerlink" title="变量删除"></a>变量删除</h2><ul>
<li>var全局声明的变量是<strong>无法删除</strong>的，configurable=false</li>
<li>var函数作用域内声明的变量是<strong>无法删除</strong>的，没有依赖的父对象</li>
<li>eval()会创建属性，configurable=true,所以可以删除</li>
</ul>
<p>同理，函数也是对象，声明的函数也会遵循var的方式，判断是否可以删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">window</span>, <span class="string">'a'</span>));      <span class="comment">// delete b =&gt; false</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">2</span>; <span class="comment">// delete b =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// delete aa =&gt; false</span></span><br><span class="line">(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bb</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">delete</span> bb; <span class="comment">// false</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>所以如果要删除已定义的变量，可以赋值覆盖掉它，或者是在局部作用域中创建，等待内存回收</p>
<p>垃圾回收有2大条件</p>
<ul>
<li>未被引用的对象会被自动回收</li>
<li>不可访问的对象会被自动回收，比如虽然2对象互相引用，但是外部不可访问也会被回收</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>33行实现react</title>
    <url>/2020/05/30/33%E8%A1%8C%E5%AE%9E%E7%8E%B0react/</url>
    <content><![CDATA[<blockquote>
<p>一种简易的类react架构的实现，了解react，<br>全文添加中文注释，方便理解</p>
</blockquote>
<a id="more"></a>

<ul>
<li>取得状态并返回虚拟dom</li>
<li>状态改变，返回新的虚拟dom</li>
<li>将虚拟dom渲染为真实dom</li>
<li>更新真实dom</li>
</ul>
<p>前置知识点</p>
<ul>
<li><a href="http://www.mithriljs.net/" target="_blank" rel="noopener">Mithril</a> 现代化的 JS 轻量框架,内置了路由和 XHR 工具<ul>
<li>m() 函数可以描述任何 HTML 结构</li>
<li>m.render(root, ‘’) 挂载</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 结构args =&gt; tag, attrs, classes</span></span><br><span class="line">    <span class="keyword">let</span> [attrs, [head, ...tail]] = [&#123;&#125;, args]</span><br><span class="line">    <span class="keyword">let</span> [tag, ...classes] = head.split(<span class="string">'.'</span>)</span><br><span class="line">    <span class="keyword">if</span> (tail.length &amp;&amp; !m.isRenderable(tail[<span class="number">0</span>])) [attrs, ...tail] = tail</span><br><span class="line">    <span class="comment">// 合并class</span></span><br><span class="line">    <span class="keyword">if</span> (attrs.class) classes = [...classes, ...attrs.class]</span><br><span class="line">    <span class="comment">// 把已经使用的attrs做浅拷贝，删除class的值</span></span><br><span class="line">    attrs = &#123;...attrs&#125;; <span class="keyword">delete</span> attrs.class</span><br><span class="line">    <span class="comment">// 创建子数组，递归地将嵌套项拍平到该数组中，并忽略空值</span></span><br><span class="line">    <span class="keyword">const</span> children = []</span><br><span class="line">    <span class="keyword">const</span> addChildren = <span class="function"><span class="params">v</span>=&gt;</span>v === <span class="literal">null</span>? <span class="literal">null</span> : <span class="built_in">Array</span>.isArray(v)? v.map(addChildren) : children.push(v)</span><br><span class="line">    addChildren(tail)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">__m</span>: <span class="literal">true</span>, <span class="attr">tag</span>: tag || <span class="string">'div'</span>, attrs, classes, children&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否可以渲染null,字符串，数字，虚拟节点，数组</span></span><br><span class="line">m.isRenderable = <span class="function"><span class="params">v</span> =&gt;</span>v === <span class="literal">null</span> || [<span class="string">'string'</span>, <span class="string">'number'</span>].includes(<span class="keyword">typeof</span> v) || v.__m || <span class="built_in">Array</span>.isArray(v)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收真实dom和虚拟dom</span></span><br><span class="line"><span class="comment">// 把所需的虚拟dom的属性和类更新到真实dom</span></span><br><span class="line">m.update = <span class="function">(<span class="params">el, v</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 如果是文本元素，需要设置数据</span></span><br><span class="line">    <span class="keyword">if</span> (!v.__m) <span class="keyword">return</span> el.data === <span class="string">`<span class="subst">$&#123;v&#125;</span>`</span> || (el.data = v)</span><br><span class="line">    <span class="comment">// 设置添加class</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> v.classes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!el.classList.contains(name)) el.classList.add(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> el.classList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!v.classes.includes(name)) el.classList.remove(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置添加attributes</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> <span class="built_in">Object</span>.keys(v.attrs))&#123;</span><br><span class="line">        <span class="keyword">if</span> (el[name] !== v.attrs[name]) el[name] = v.attrs[name]</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> &#123;name&#125; <span class="keyword">of</span> el.attributes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(v.attrs).includes(name) &amp;&amp; name !== <span class="string">'class'</span>) el.removeAttribute(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定一个虚拟DOM节点，生成一个真实dom节点，否则生成一个真实textNode值。</span></span><br><span class="line">m.makeEl = <span class="function"><span class="params">v</span>=&gt;</span>v.__m? <span class="built_in">document</span>.createElement(v.tag) : <span class="built_in">document</span>.createTextNode(v)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染，真实Dom和虚拟Dom</span></span><br><span class="line"><span class="comment">// a) 获取新老节点的子项</span></span><br><span class="line"><span class="comment">// b) 清除多余的旧节点</span></span><br><span class="line"><span class="comment">// c) 遍历每个新虚拟节点</span></span><br><span class="line"><span class="comment">//  1、通过index获取匹配的旧节点，如果没有则新增节点</span></span><br><span class="line"><span class="comment">//  2、如果没有匹配的旧元素，创建一个新元素加入父级</span></span><br><span class="line"><span class="comment">//  3、如果不匹配(标签名/节点)，就替换父级上的匹配项为新元素</span></span><br><span class="line"><span class="comment">//  4、更新节点的属性/类</span></span><br><span class="line"><span class="comment">//  5、递归子节点</span></span><br><span class="line"><span class="comment">// 高效追加到元素列表,耗时O(n)</span></span><br><span class="line">m.render = <span class="function">(<span class="params">parent, v</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> olds = parent.childNodes || []</span><br><span class="line">    <span class="keyword">const</span> news = v.children || [] </span><br><span class="line">    <span class="comment">// 遍历次数是新旧节点的属性长度之差</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> _ <span class="keyword">of</span> <span class="built_in">Array</span>(<span class="built_in">Math</span>.max(<span class="number">0</span>, olds.length - news.length))) &#123;</span><br><span class="line">        parent.removeChild(parent.lastChild)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// entries返回可枚举属性的键值对数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [i, child] <span class="keyword">of</span> news.entries())&#123; </span><br><span class="line">        <span class="keyword">let</span> el = olds[i] || m.makeEl(child) </span><br><span class="line">        <span class="comment">// 旧的属性的值存在</span></span><br><span class="line">        <span class="keyword">if</span> (!olds[i])&#123;</span><br><span class="line">            parent.appendChild(el)  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">const</span> mismatch = (el.tagName || <span class="string">''</span>) !== (child.tag || <span class="string">''</span>).toUpperCase()</span><br><span class="line">        <span class="keyword">if</span> (mismatch) &#123;</span><br><span class="line">            (el = m.makeEl(child)) &amp;&amp; parent.replaceChild(el, olds[i])</span><br><span class="line">        &#125;</span><br><span class="line">        m.update(el, child) </span><br><span class="line">        m.render(el, child) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原文：<a href="https://leontrolski.github.io/33-line-react.html" target="_blank" rel="noopener">https://leontrolski.github.io/33-line-react.html</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex getter</title>
    <url>/2020/05/24/vuex%20getter/</url>
    <content><![CDATA[<blockquote>
<p>Vuex的5大属性，state，getters，mutations，actions和modules<br>getters到底能做什么</p>
</blockquote>
<a id="more"></a>

<hr>
<p>写业务时没有太在意state/getter读值的区别，直到面试时遇到了这样一个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue中computed和vuex中getters有什么相同点</span><br></pre></td></tr></table></figure>
<p>leo：纳尼，这两者还有关联？<br>面试官：你真的用过vuex?<br>leo：emmm</p>
<hr>
<p>vuex嘛，大家都知道是中心化的状态管理模式，单向数据流，如图  </p>
<div style="width: 50%; margin: auto">

<p><img src="state-view-actions.png" alt="单向数据流"></div></p>
<p>state保存状态，getters获取state，mutations同步执行改变state，actions异步执行</p>
<h2 id="如何获取state状态"><a href="#如何获取state状态" class="headerlink" title="如何获取state状态"></a>如何获取state状态</h2><p>方案一</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.state.aaa</span><br><span class="line"><span class="keyword">this</span>.$store.getter.bbb</span><br></pre></td></tr></table></figure>
<p>方案二</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">'aaa'</span>]),</span><br><span class="line">    ...mapGetters([<span class="string">'bbb'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么提供了2种方法获取state，他们有什么区别呢"><a href="#为什么提供了2种方法获取state，他们有什么区别呢" class="headerlink" title="为什么提供了2种方法获取state，他们有什么区别呢"></a>为什么提供了2种方法获取state，他们有什么区别呢</h2><ul>
<li>state获取时直接返回</li>
<li>getter可以在获取state时，对state进行操作后返回</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">    getMyListGreaterThanNum(state, getters) &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123; <span class="comment">// 把属性变成函数属性</span></span><br><span class="line">        <span class="keyword">return</span> state.myList.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; num) </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$store.getters[<span class="string">"getMyListGreaterThanNum"</span>](<span class="number">1</span>)</span><br><span class="line"><span class="keyword">this</span>.$store.getters.getMyListGreaterThanNum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="computed和getters相同点"><a href="#computed和getters相同点" class="headerlink" title="computed和getters相同点"></a>computed和getters相同点</h2><ul>
<li>缓存，和computed一样，当依赖的state改变才会重新计算</li>
</ul>
<p>在getters中是属性不是函数,不能直接传参</p>
<h2 id="mapGetters-是什么"><a href="#mapGetters-是什么" class="headerlink" title="mapGetters 是什么"></a>mapGetters 是什么</h2><ul>
<li>mapGetters辅助函数，直接返回一个对象，仅仅是将 store 中的 getter 映射到局部计算属性</li>
</ul>
<p>每次调用都需要this.$store.getters.xxx，非常麻烦，可以用mapGetters语法糖直接合并入computed</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">'getMyListGreaterThanNum'</span>]),</span><br><span class="line">    ...mapGetters(<span class="string">"myStore2"</span>, [<span class="string">"getMyListGreaterThanNum"</span>]);<span class="comment">// 分模块</span></span><br><span class="line">    ...mapGetters(<span class="string">"myStore2"</span>, &#123;<span class="attr">getMyList</span>: <span class="string">"getMyListGreaterThanNum"</span>&#125;);<span class="comment">// 重命名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$storestore.getters[<span class="string">"myStore2/getMyListGreaterThanNum"</span>]</span><br></pre></td></tr></table></figure>

<h2 id="mapGetters源码实现"><a href="#mapGetters源码实现" class="headerlink" title="mapGetters源码实现"></a>mapGetters源码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reduce the code which written in Vue.js for getting the getters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>[namespace] - Module's namespace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object|Array&#125;</span> <span class="variable">getters</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mapGetters = normalizeNamespace(<span class="function"><span class="keyword">function</span> (<span class="params">namespace, getters</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!isValidMap(getters)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'[vuex] mapGetters: mapper parameter must be either an Array or an Object'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    normalizeMap(getters).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ref</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> key = ref.key;</span><br><span class="line">      <span class="keyword">var</span> val = ref.val;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The namespace has been mutated by normalizeNamespace</span></span><br><span class="line">      val = namespace + val;</span><br><span class="line">      res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (namespace &amp;&amp; !getModuleByNamespace(<span class="keyword">this</span>.$store, <span class="string">'mapGetters'</span>, namespace)) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(val <span class="keyword">in</span> <span class="keyword">this</span>.$store.getters)) &#123;</span><br><span class="line">          <span class="built_in">console</span>.error((<span class="string">"[vuex] unknown getter: "</span> + val));</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters[val]</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// mark vuex getter for devtools</span></span><br><span class="line">      res[key].vuex = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeNamespace</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">namespace, map</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> namespace !== <span class="string">'string'</span>) &#123;</span><br><span class="line">        map = namespace;</span><br><span class="line">        namespace = <span class="string">''</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namespace.charAt(namespace.length - <span class="number">1</span>) !== <span class="string">'/'</span>) &#123;</span><br><span class="line">        namespace += <span class="string">'/'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fn(namespace, map)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeMap</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidMap(map)) &#123;</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(map)</span><br><span class="line">      ? map.map(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123; <span class="keyword">return</span> (&#123; <span class="attr">key</span>: key, <span class="attr">val</span>: key &#125;); &#125;)</span><br><span class="line">      : <span class="built_in">Object</span>.keys(map).map(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123; <span class="keyword">return</span> (&#123; <span class="attr">key</span>: key, <span class="attr">val</span>: map[key] &#125;); &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>normalizeNamespace函数将传入的改成namespace/getters的分割样式，如果没有namespace，那么直接返回getters</li>
<li>normalizeMap函数将输入的getters对应成store的内部属性，可以使用对象来更改函数的名称</li>
<li>查找属性，找到返回this.$store.getters[val]</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vuex</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3预览</title>
    <url>/2020/05/17/vue3%E9%A2%84%E8%A7%88/</url>
    <content><![CDATA[<p>vue3 的api及语法有哪些改变</p>
<a id="more"></a>

<img src="/images/vue3预览/1.jpg" />
<img src="/images/vue3预览/2.jpg" />
<img src="/images/vue3预览/3.jpg" />
<img src="/images/vue3预览/4.jpg" />
<img src="/images/vue3预览/all.png" />





]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>reduce用法详解</title>
    <url>/2020/04/14/reduce%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<p>reduce()累加器，数组中的每个元素依次执行回调函数callback（初始值(或者上次回调函数的返回值)，当前元素值，当前索引，调用reduce的数组）<br>arr.reduce(callback, [initialValue])</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pre, cur, index);</span><br><span class="line">    <span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, sum); <span class="comment">// [1, 2, 3, 4] 10   初始值为1,循环3次</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pre, cur, index);</span><br><span class="line">    <span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr, sum); <span class="comment">// [1, 2, 3, 4] 10   初始值为0,循环4次</span></span><br></pre></td></tr></table></figure>

<p>求和或求积</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;<span class="comment">// 10</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> mul = arr.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x * y;<span class="comment">// 24</span></span><br><span class="line">&#125;, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>计算数组中每个元素出现的次数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Tiff'</span>, <span class="string">'Alice'</span>];</span><br><span class="line"><span class="keyword">var</span> nameNum = names.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (cur <span class="keyword">in</span> pre) &#123;</span><br><span class="line">		pre[cur]++</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pre[cur] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre  </span><br><span class="line">&#125;, &#123;&#125;) <span class="comment">// &#123; Alice: 2, Bob: 1, Tiff: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>对象属性求和</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">	&#123;<span class="attr">subject</span>: <span class="string">'math'</span>, <span class="attr">score</span>: <span class="number">10</span>&#125;,</span><br><span class="line">	&#123;<span class="attr">subject</span>: <span class="string">'chinese'</span>, <span class="attr">score</span>: <span class="number">10</span>&#125;,</span><br><span class="line">	&#123;<span class="attr">subject</span>: <span class="string">'english'</span>, <span class="attr">score</span>: <span class="number">10</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cur.score + pre</span><br><span class="line">&#125;, <span class="number">0</span>) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>数组去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!pre.includes(cur)) &#123;</span><br><span class="line">		<span class="keyword">return</span> pre.concat(cur)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> pre</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, [])  <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>数组对象去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">	&#123;<span class="attr">id</span>: <span class="number">0</span>, <span class="attr">name</span>: <span class="string">"小明"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">"小张"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">"小李"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">"小孙"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">"小周"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">"小陈"</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	obj[cur.id] ? <span class="string">''</span> : obj[cur.id] = <span class="literal">true</span> &amp;&amp; pre.push(cur);</span><br><span class="line">	<span class="keyword">return</span> pre</span><br><span class="line">&#125;, []) <span class="comment">// [ &#123;id: 0, name: “小明”&#125;, &#123;id: 1, name: “小张”&#125;,&#123;id: 2, name: “小李”&#125;,&#123;id: 3, name: “小孙”&#125;]</span></span><br></pre></td></tr></table></figure>

<p>数组拍平</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pre.concat(cur)  <span class="comment">// [0,1,2,3,4,5]</span></span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<p>数组多维拍平</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]]]</span><br><span class="line"><span class="keyword">var</span> newArr = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">		pre.concat(<span class="built_in">Array</span>.isArray(cur) ? newArr(cur) : cur)</span><br><span class="line">	&#125;, [])</span><br><span class="line">&#125; <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>React</category>
        <category>Reduce</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react useMemo&amp;useCallback</title>
    <url>/2020/04/01/react%20useMemo&amp;useCallback/</url>
    <content><![CDATA[<blockquote>
<p>useMemo和useCallback都会在组件第一次渲染的时候执行</p>
</blockquote>
<blockquote>
<p>之后会在其依赖的变量发生改变时再次执行</p>
</blockquote>
<blockquote>
<p>useMemo返回缓存的变量，useCallback返回缓存的函数</p>
</blockquote>
<p>多个state改变会重渲染多此，借助useMemo可以在指定state改变时才执行对应的方法</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expensive</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">改为</span><br><span class="line"><span class="keyword">const</span> expensive = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,[count])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>useCallback返回的是缓存的函数</p>
</blockquote>
<ul>
<li>将我们传递给它的函数fnB返回，并且将这个结果缓存；当依赖a变更时，会返回新的函数。</li>
<li>既然返回的是函数，我们无法很好的判断返回的函数是否变更，</li>
<li>所以我们可以借助ES6新增的数据类型Set来判断<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fnA = useCallback(fnB, [a])</span><br></pre></td></tr></table></figure>
如果存在父子组件，如果父更新，子也会更新，可以把useCallback返回的函数传给子props,这样就缓存不更新<br>等返回的函数更新后字才会更新</li>
</ul>
<p>所有依赖本地状态或props来创建函数，需要使用到缓存函数的地方，都是useCallback的应用场景</p>
<p>useEffect、useMemo、useCallback都是自带闭包的。也就是说，每一次组件的渲染，其都会捕获当前组件函数上下文中的状态(state, props)，所以每一次这三种hooks的执行，反映的也都是当前的状态，你无法使用它们来捕获上一次的状态。对于这种情况，我们应该使用ref来访问</p>
<p>类组件的shouldComponentUpdate和 PureComponent,为了减少重新 render 的次数，主要是减少父组件更新而子组件也更新的情况</p>
<p>React.memo是对标类组件PureComponent<br>子组件如果在 props 没有变化的情况下，就算父组件重新渲染了，子组件也不应该渲染<br>React.memo其实是一个高阶函数，传递一个组件进去，返回一个可以记忆的组件</p>
<p>如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myComponent(props) &#123;</span><br><span class="line">   &#x2F;* 使用 props 渲染 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--  prevProps !&#x3D; nextProps时返回false会重渲 --&gt;</span><br><span class="line">funtion areEqual(prevProps,nextProps)&#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">const MyComponent &#x3D; React.memo(myComponent,areEqual);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个组件重新重新渲染，一般三种情况：</p>
</blockquote>
<ul>
<li>要么是组件自己的状态改变</li>
<li>要么是父组件重新渲染，导致子组件重新渲染，但是父组件的 props 没有改版</li>
<li>要么是父组件重新渲染，导致子组件重新渲染，但是父组件传递的 props 改变</li>
</ul>
<blockquote>
<p>React 的性能优化方向主要是两个：</p>
</blockquote>
<ul>
<li>一个是减少重新 render 的次数(或者说减少不必要的渲染)，</li>
<li>另一个是减少计算的量</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
        <category>Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react-useEffect&amp;useReducer</title>
    <url>/2020/03/30/react-useEffect&amp;useReducer/</url>
    <content><![CDATA[<blockquote>
<p>use*** 格式定义的函数是react hooks的规范</p>
</blockquote>
<p>useEffect用于处理组件中的effect，通常用于请求数据，事件处理，订阅等相关操作</p>
<blockquote>
<p>最后return的【返回函数】可以作为状态切换的默认执行函数，执行下一个effect之前执行上一个effect【返回的函数】</p>
</blockquote>
<a id="more"></a>
<hr>
<ul>
<li><p>状态和状态更新函数来自与useState这个hooks，通过调用useState，来创建App组件的内部状态。初始状态是一个object，其中的hits为一个空数组</p>
</li>
<li><p>axios发起请求,使用useEffect来隔离副作用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> fetchData = <span class="keyword">async</span>()&#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> axios(<span class="string">'xxx'</span>);</span><br><span class="line">            setData(result.data);</span><br><span class="line">        &#125;</span><br><span class="line">        fetchData()</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">        &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">                &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">         &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>useEffect在组件mount时执行，但也会在组件更新时执行</p>
</blockquote>
</li>
<li><p>如果在useEffect中请求数据并setData会触发渲染,导致死循环<br>所以需要传递一个空数组作为参数，避免在更新时触发useEffect,只会在mount挂载时执行一次</p>
</li>
<li><p>第二参数用于监听指定变量的更新<br>如果参数中定义的变量更新了，则useEffect会再次执行</p>
</li>
<li><p>async函数会隐式返回promise，但是useEffect不返回内容，所以需要用方法包装async</p>
</li>
</ul>
<hr>
<blockquote>
<p>响应更新的例子，用户输入</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">    <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'redux'</span>);</span><br><span class="line">    <span class="keyword">const</span> [search, setSearch] = useState(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">const</span> [url, setUrl] = useState(<span class="string">'http://localhost/api/v1/search?query=redux'</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> fetchData = <span class="keyword">async</span>()=&gt;&#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> axios(<span class="string">'xxx?query='</span> + query);</span><br><span class="line">            setData(result.data);</span><br><span class="line">        &#125;</span><br><span class="line">        fetchData()</span><br><span class="line">    &#125;,[search])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> value=&#123;query&#125;</span><br><span class="line">                onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">            &lt;button type=<span class="string">"button"</span> onClick=&#123;() =&gt; setSearch(query)&#125;&gt;</span><br><span class="line">                Search</span><br><span class="line">            &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">                &lt;li key=&#123;item.objectID&#125;&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/</span>a&gt;</span><br><span class="line">                &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            ))&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/u</span>l&gt;</span><br><span class="line">        &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>query的任何一次变动都会请求后端，这样会带来比较大的访问压力。这个时候我们需要引入一个按钮，点击这个按钮再发起请求(query改为search)</p>
</li>
<li><p>每次点击按钮时，会把search的值设置为query，这个时候我们需要修改useEffect中的依赖项为search，这样每次点击按钮，search值变更，useEffect就会重新执行，避免不必要的变更</p>
</li>
<li><p>因为组件首先会在mount时获取数据。所以简单点，直接将的要请求的后端URL设置为search state的初始值</p>
</li>
<li><p>如果useEffect中出现其他外部变量也需要放入依赖数组中，所以btn依赖的query也提取到btn中，不转入useEffect</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'redux'</span>);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(</span><br><span class="line">    <span class="string">'http://localhost/api/v1/search?query=redux'</span>,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        value=&#123;query&#125;</span><br><span class="line">        onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"button"</span> onClick=&#123;() =&gt; setUrl(<span class="string">`http://localhost/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>)&#125;&gt;</span><br><span class="line">            Search</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li key=&#123;item.objectID&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/</span>a&gt;</span><br><span class="line">          &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>处理Loading和error</p>
</blockquote>
</li>
<li><p>在请求后端数据,展现loading的状态</p>
</li>
<li><p>不需要再loading变更时重新调用useEffect</p>
</li>
<li><p>处理错误,使用useState来创建一个新的state，然后在useEffect中特定的位置来更新这个state</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">    const [isLoading, setIsLoading] &#x3D; useState(false);</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        const fetchData &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">            setIsLoading(true);</span><br><span class="line">        </span><br><span class="line">            const result &#x3D; await axios(url);</span><br><span class="line">        </span><br><span class="line">            setData(result.data);</span><br><span class="line">            setIsLoading(false);</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        fetchData();</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &#123;isLoading ? (</span><br><span class="line">                &lt;div&gt;Loading ...&lt;&#x2F;div&gt;</span><br><span class="line">            ) : (</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                &#123;data.hits.map(item &#x3D;&gt; (</span><br><span class="line">                    &lt;li key&#x3D;&#123;item.objectID&#125;&gt;</span><br><span class="line">                    &lt;a href&#x3D;&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;&#x2F;li&gt;</span><br><span class="line">                ))&#125;</span><br><span class="line">                &lt;&#x2F;ul&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">        &lt;&#x2F;Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同名目录内有抽离自定义hooks组件的例子<br>使用useReducer整合逻辑</p>
</blockquote>
</li>
<li><p>使用了各种通过分离的state hooks来管理分散的：数据、状态，为了有关联的状态整合到一起，我们需要用到useReducer</p>
</li>
<li><p>useReducer 是一个轻量的redux，返回一个状态对象和一个可以改变状态对象的dispatch函数,dispatch函数接受action作为参数，action包含type和payload属性</p>
</li>
<li><p>useReducer将reducer函数和初始状态对象作为参数,即同时定义多个hooks</p>
</li>
<li><p>type属性告诉reducer需要应用哪个状态转换，并且reducer可以使用payload来创建新的状态</p>
</li>
<li><p>例子中的state是对象，导出时可以解构分离原有状态</p>
</li>
<li><p>取消数据请求,在请求还没有返回的时候卸载了组件会报错</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dataFetchReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'FETCH_INIT'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                isLoading: <span class="literal">true</span>,</span><br><span class="line">                isError: <span class="literal">false</span></span><br><span class="line">            &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">    isError: <span class="literal">false</span>,</span><br><span class="line">    data: initialData,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch(&#123; <span class="attr">type</span>: <span class="string">'FETCH_INIT'</span> &#125;);</span><br><span class="line">dispatch(&#123; <span class="attr">type</span>: <span class="string">'FETCH_SUCCESS'</span>, <span class="attr">payload</span>: result.data &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在没有hooks时，创建class组件，性能的优化通过immutable比较，</span><br><span class="line">1、在不相等的时候调用setState,</span><br><span class="line">2、在shouldComponentUpdate中判断前后的props和state，如果没有变化，则返回false来阻止更新</span><br><span class="line"></span><br><span class="line">在hooks出来后，无法通过判断前后状态来决定是否更新，每一次调用都会执行其内部的所有逻辑，可以发现每次改变都会触发父子组件渲染</span><br><span class="line">性能损耗通过useMemo 和useCallback解决</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>React</category>
        <category>Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>追踪用户关闭网页</title>
    <url>/2020/03/30/%E8%BF%BD%E8%B8%AA%E7%94%A8%E6%88%B7%E5%85%B3%E9%97%AD%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<blockquote>
<p>异步ajax、img标签上传数据、beacon API比较</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>1、异步ajax</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">'post'</span>, <span class="string">'/log'</span>, <span class="literal">true</span>);</span><br><span class="line">    xhr.setRequestHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">    xhr.send(<span class="string">'foo=bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unload'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    log();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">1</span>; m &lt; <span class="number">10000</span>; m++) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2、img标签上传数据<br>后缀img.jpg?c=xxxx</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reportData = <span class="function">(<span class="params">url, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">    <span class="keyword">const</span> params = [];</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        params.push(key+<span class="string">'='</span>+<span class="built_in">encodeURIComponent</span>(data[key]));</span><br><span class="line">    &#125;);</span><br><span class="line">    img.onload = <span class="function"><span class="params">()</span> =&gt;</span> img = <span class="literal">null</span>;</span><br><span class="line">    img.src = url+<span class="string">'?'</span>+params.join(<span class="string">'&amp;'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3、beacon API<br>70%不到的成功率</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.sendBeacon(<span class="string">'/log'</span>, <span class="string">'foo=bar'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<hr>
<p>beforeunload不能准确的判断刷新和关闭<br>navigator.sendBeacon不能捕捉直接关闭浏览器或任务管理器结束任务<br>还是后端监听心跳做比较好</p>
<hr>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>koa2简易实现</title>
    <url>/2020/03/27/koa2%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>核心功能洋葱模型</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Application http server 基本服务器框架</span><br><span class="line">Context 上下文 服务器框架基本数据结构的封装，解析响应http请求</span><br><span class="line">Middleware 中间件，洋葱模型机制</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>启动一个简单的http服务</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.end(<span class="string">'- -'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p>app.listen处理请求和端口监听</p>
<p>app.use处理中间件和请求</p>
<blockquote>
<p>myKoa</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware=<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    listen(...args)&#123;</span><br><span class="line">        <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.middleware);</span><br><span class="line">        server.listen(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    use(middleware)&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware = middleware</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line"><span class="comment">// const app = new Application()</span></span><br><span class="line"><span class="comment">// app.use((req,res)=&gt;&#123;res.end('- -')&#125;)</span></span><br><span class="line"><span class="comment">// app.listen(3000)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>构建Context</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此时app.use的回调函数是原生的req,res，而koa中是一个Context对象</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware=<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    listen(...args)&#123;</span><br><span class="line">        <span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 创建Context对象</span></span><br><span class="line">            <span class="keyword">const</span> ctx = <span class="keyword">new</span> Context(req,res);</span><br><span class="line">            <span class="comment">// 处理 app.use</span></span><br><span class="line">            <span class="keyword">this</span>.middleware(ctx);</span><br><span class="line">            <span class="comment">// 响应内容</span></span><br><span class="line">            ctx.res.end(ctx.body);</span><br><span class="line">        &#125;);</span><br><span class="line">        server.listen(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    use(middleware)&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware = middleware</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(req,res)&#123;</span><br><span class="line">        <span class="keyword">this</span>.req=req;</span><br><span class="line">        <span class="keyword">this</span>.res=res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line"><span class="comment">// const app = new Application()</span></span><br><span class="line"><span class="comment">// app.use(ctx=&gt;&#123;ctx.body('- -')&#125;)</span></span><br><span class="line"><span class="comment">// app.listen(3000)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>中间件</p>
</blockquote>
<p>手机中间件回调函数数组，并使用compose串联起来<br>对所有中间件函数通过compose函数来达到抽象效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middlewares);</span><br><span class="line"><span class="keyword">await</span> fn(ctx);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">await</span> compose(<span class="keyword">this</span>.middlwares,ctx);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.middlewares=[]</span><br><span class="line">    &#125;</span><br><span class="line">    listen(...args)&#123;</span><br><span class="line">        <span class="keyword">const</span> server = http.createServer(<span class="keyword">async</span> (req,res)=&gt;&#123;</span><br><span class="line">            <span class="keyword">const</span> ctx = <span class="keyword">new</span> Context(req,res);</span><br><span class="line">            <span class="comment">// 对中间件回调函数串联，洋葱模型</span></span><br><span class="line">            <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middlewares);</span><br><span class="line">            <span class="keyword">await</span> fn(ctx);</span><br><span class="line"></span><br><span class="line">            ctx.res.end(ctx.body);</span><br><span class="line">        &#125;);</span><br><span class="line">        server.listen(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    use(middleware)&#123;</span><br><span class="line">        <span class="keyword">this</span>.middlewares.push(middleware)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">    constructo(req,res)&#123;</span><br><span class="line">        <span class="keyword">this</span>.req=req;</span><br><span class="line">        <span class="keyword">this</span>.res=res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个中间件将会执行。后续每个会通过next执行<br>使用递归完成中间件的改造,实现洋葱模型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch=<span class="function">(<span class="params">i</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> middlewares[i](ctx,()=&gt;&#123;</span><br><span class="line">        dispatch(i+<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">dispatch(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch=<span class="function">(<span class="params">i</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> middleware = middlewares[i];</span><br><span class="line">    <span class="keyword">if</span>(i === middlewares.length)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> middleware(ctx,()=&gt;&#123;</span><br><span class="line">        dispatch(i+<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">dispatch(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>最后的compose</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middlewares</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">ctx</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> dispatch=<span class="function">(<span class="params">i</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> middleware = middlewares[i];</span><br><span class="line">            <span class="keyword">if</span>(i === middlewares.length)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> middleware(ctx,()=&gt;&#123;</span><br><span class="line">                dispatch(i+<span class="number">1</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// const app = new Application()</span></span><br><span class="line"><span class="comment">// app.use(async(ctx)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//    ctx.body('- -')</span></span><br><span class="line"><span class="comment">//    await next()</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// app.use(async (ctxnext)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//    ctx.body('- -')</span></span><br><span class="line"><span class="comment">//    await next()</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// app.use(async (ctx,next)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//    ctx.body='富士山</span></span><br><span class="line"><span class="comment">//    await next()</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// app.listen(3000)</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>label语法</title>
    <url>/2020/03/10/label%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>使用label语法在多层循环中精确返回指定位置</p>
</blockquote>
<a id="more"></a>
<p>主要用于break和continue的跳出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span> )&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        num++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// 95 循环在 i 为5，j 为5的时候跳出 j循环，但会继续执行 i 循环</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outPoint:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span> )&#123;</span><br><span class="line">                <span class="keyword">break</span> outPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        num++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// 55 循环在 i 为5，j 为5的时候跳出双循环，返回到outPoint层继续执行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i === <span class="number">5</span> &amp;&amp; j === <span class="number">5</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span> outermost;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// 95 continue outermost;语句的作用是跳出当前循环，并跳转到outermost（标签）下的for循环继续执行</span></span><br></pre></td></tr></table></figure>
<p>实际场景下应该不会出现三层及以上循环</p>
]]></content>
      <categories>
        <category>label</category>
      </categories>
      <tags>
        <tag>label</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Component</title>
    <url>/2020/02/28/Web%20Component/</url>
    <content><![CDATA[<blockquote>
<p>Web Component</p>
</blockquote>
<a id="more"></a>

<p><a href="https://segmentfault.com/a/1190000012440318" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012440318</a></p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>Web Component</category>
      </categories>
      <tags>
        <tag>Web Component</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtual Dom</title>
    <url>/2020/02/28/Virtual%20Dom/</url>
    <content><![CDATA[<blockquote>
<p>什么是Virtual Dom</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.jianshu.com/p/a036eaa2263a" target="_blank" rel="noopener">https://www.jianshu.com/p/a036eaa2263a</a><br><a href="https://www.jianshu.com/p/b189b2949b33" target="_blank" rel="noopener">https://www.jianshu.com/p/b189b2949b33</a></p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>Virtual Dom</category>
      </categories>
      <tags>
        <tag>Virtual Dom</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组拍平 扁平化的方式</title>
    <url>/2020/02/28/js%E6%95%B0%E7%BB%84%E6%8B%8D%E5%B9%B3%20%E6%89%81%E5%B9%B3%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>六种方式 拍平数组 扁平化数组</p>
</blockquote>
<a id="more"></a>
<p><code>var arr = [1,2,[3,4,5,[6,7,8],9],10,[11,12]];</code></p>
<blockquote>
<p>递归实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">let</span> arr1 = [];</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">            arr1 = arr1.concat(fn(val))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr1.push(val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arr1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>reduce实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev,cur</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prev.concat(<span class="built_in">Array</span>.isArray(cur)?fn(cur):cur)</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>flat</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.flat(<span class="literal">Infinity</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>扩展运算符</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr1 = [];</span><br><span class="line">    <span class="keyword">let</span> bStop = <span class="literal">true</span>;</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(val))&#123;</span><br><span class="line">            arr1.push(...val);</span><br><span class="line">            bStop = <span class="literal">false</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr1.push(val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(bStop)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(arr1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>toString</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = arr.toString().split(<span class="string">','</span>).map(<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(val)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>apply</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item)))&#123;</span><br><span class="line">           arr =  [].concat.apply([],arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>curl</title>
    <url>/2020/02/28/curl/</url>
    <content><![CDATA[<blockquote>
<p>curl使用指南<br><a href="https://www.jianshu.com/p/fc0eb6c60816" target="_blank" rel="noopener">https://www.jianshu.com/p/fc0eb6c60816</a></p>
</blockquote>
<a id="more"></a>
<p>curl 的用法指南 阮一峰<br><a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a><br>学习笔记之 curl 命令用法详解<br><a href="https://www.cnblogs.com/doseoer/p/7044344.html" target="_blank" rel="noopener">https://www.cnblogs.com/doseoer/p/7044344.html</a></p>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2020/02/27/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>markdown语法</p>
</blockquote>
<a id="more"></a>

<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># h1 代表标题级数，最多6级标题</span><br></pre></td></tr></table></figure>
<h1 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h1><p>末尾加2个空格表示换行</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 无序列表</span><br><span class="line">    +次级</span><br><span class="line">    -次级</span><br><span class="line">    次级</span><br><span class="line">最后空行</span><br></pre></td></tr></table></figure>
<ul>
<li>列表<br>  +次级<br>  -次级<br>  次级</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.有序列表</span><br><span class="line">    1.次级</span><br><span class="line">    2.次级</span><br><span class="line">2.有序列表</span><br></pre></td></tr></table></figure>
<p>1.有序列表<br>    1.次级<br>    2.次级<br>2.有序列表</p>
<h1 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 一级引用</span><br><span class="line">&gt;&gt; 二级引用</span><br><span class="line">&gt;&gt;&gt; 三级引用</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一级引用</p>
<blockquote>
<p>二级引用</p>
<blockquote>
<p>三级引用</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<hr>
<h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[百度](https:&#x2F;&#x2F;www.baidu.com)</span><br></pre></td></tr></table></figure>
<p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![百度](https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;bd_logo1.png?where&#x3D;super)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.baidu.com/img/bd_logo1.png?where=super" alt="百度"></p>
<h1 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h1><p><code>代码框</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'123'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体*          _斜体_</span><br><span class="line">**加粗**        __加粗__</span><br><span class="line">***斜体加粗***  ___斜体加粗___</span><br></pre></td></tr></table></figure>
<p><em>斜体</em> <em>斜体</em><br><strong>加粗</strong> <strong>加粗</strong><br><strong><em>斜体加粗</em></strong> <strong><em>斜体加粗</em></strong></p>
<h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><p><code>~~待删除~~</code><br><del>待删除</del></p>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p><code>默认左对齐(:-)，右对齐(-:)，居中对齐(:-:)</code></p>
<table>
<thead>
<tr>
<th align="center">head</th>
<th align="left">head</th>
<th align="right">head</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">2</td>
<td align="right">3</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="right">head</th>
<th align="center">head</th>
<th>head</th>
</tr>
</thead>
<tbody><tr>
<td align="right">1</td>
<td align="center">2</td>
<td>3</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>head</th>
<th align="right">head</th>
<th align="center">head</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="right">2</td>
<td align="center">3</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>模板语法</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>hello hexo,你好 hexo</title>
    <url>/2020/02/22/hello-hexo/</url>
    <content><![CDATA[<blockquote>
<p>新建文章、创建标签和分类、阅读全文、搜索功能<br>next主题的使用方法</p>
</blockquote>
<a id="more"></a>
<h1 id="next主题的使用方法"><a href="#next主题的使用方法" class="headerlink" title="next主题的使用方法"></a>next主题的使用方法</h1><!-- 
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&auto=0&id=1386946644&height=66"></iframe> -->


<p>Hexo<br><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a><br>NexT<br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a><br>Hexo框架下用NexT(v7.0+)主题美化博客<br><a href="https://blog.csdn.net/weixin_39345384/article/details/80785373" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39345384/article/details/80785373</a><br>HEXO-NexT-V7-Gemini主题优化篇<br><a href="https://yangyang188.coding.me/archives/3575fa23/" target="_blank" rel="noopener">https://yangyang188.coding.me/archives/3575fa23/</a></p>
<!-- 复制粘贴工程师小程序
https://tj-xiajiahao.github.io/
git document
http://iissnan.com/progit/
主页
https://gitby-leo.github.io/ -->

<!-- ps导出精度会影响图片色彩，最好是导出最佳精度后压缩
NIM 调试扩展 nodejs
安装vscode .swig扩展支持
Parcel
MobX
https://cn.mobx.js.org/
web-cell
https://web-cell.dev/
😆 -->

<hr>
<h2 id="hexo的特点"><a href="#hexo的特点" class="headerlink" title="hexo的特点"></a>hexo的特点</h2><p>pjax：依赖jq的pushState+ajax库<br>无切换、高性能加载显示html，又能跟普通url兼容，而ajax引入hash会影响seo</p>
<hr>
<h3 id="启用数据目录"><a href="#启用数据目录" class="headerlink" title="启用数据目录"></a>启用数据目录</h3><p>在 hexo/source/_data 目录下新建 next.yml 文件，把 Next 的主题配置文件 next/_config.yml 内容全部复制到 next.yml，然后修改override为true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建额外目录文件：</span><br><span class="line">1、custom_file_path中增加一个路径，</span><br><span class="line">2、next&#x2F;scripts&#x2F;events&#x2F;lib&#x2F;injects-point.js中增加对应变量</span><br><span class="line">3、引用文件&#123;&#123;- next_inject(&#39;xxx&#39;) &#125;&#125;</span><br><span class="line">4、新建文件</span><br></pre></td></tr></table></figure>

<h2 id="定义-CSS-路径"><a href="#定义-CSS-路径" class="headerlink" title="定义 CSS 路径"></a>定义 CSS 路径</h2><p>Next 7.2 版本后取消了 \themes\next\source\css_custom\custom.styl，怪不得这个路径一直找不到，需要在配置文件里重新定义。此处的配置项基于数据目录功能，所以必须完成前面的「启用数据目录」才能生效。<br>next.yml中的custom_file_path，解注style并新建对应文件</p>
<h2 id="配置激活-失活时的网页标题"><a href="#配置激活-失活时的网页标题" class="headerlink" title="配置激活/失活时的网页标题"></a>配置激活/失活时的网页标题</h2><p>custom-script<br>yml配置文件里新建title_trick {enable,leave,enter}</p>
<h2 id="关联文章"><a href="#关联文章" class="headerlink" title="关联文章"></a>关联文章</h2><p>hexo-related-popular-posts 报错- -<br>lib/list-json.js中 要加try catch : ret.path  = pathFn.join(config.root , list.path)</p>
<h2 id="列表页添加可配置图片"><a href="#列表页添加可配置图片" class="headerlink" title="列表页添加可配置图片"></a>列表页添加可配置图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layout&#x2F;_macro&#x2F;post.swig中添加2处代码</span><br><span class="line">&lt;!--noindex--&gt;</span><br><span class="line">&#123;% if post.descriptionImage %&#125;</span><br><span class="line">  &lt;div class&#x3D;&quot;out-img-topic-descriptionImage&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&#123;&#123; post.descriptionImage &#125;&#125; class&#x3D;&quot;img-topic-descriptionImage&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">每个文章页头部添加需要显示的图片路径</span><br><span class="line">descriptionImage: &#39;&#39;</span><br><span class="line">&lt;!--&#x2F;noindex--&gt;</span><br></pre></td></tr></table></figure>
<h2 id="背景动态图片"><a href="#背景动态图片" class="headerlink" title="背景动态图片"></a>背景动态图片</h2><p>jquery-backstretch<br>可以放到bodyEnd中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;jquery-backstretch&#x2F;2.0.4&#x2F;jquery.backstretch.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  $(&quot;body&quot;).backstretch(&quot;https:&#x2F;&#x2F;背景图.jpg&quot;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="rating评分"><a href="#rating评分" class="headerlink" title="rating评分"></a>rating评分</h2><p>注册后填写网站的id</p>
<p>1) 可以配置评分方式，侧栏 &gt; Rating &gt; Setting，建议用 IP address 或 Device (cookie)，免登录，毕竟 Socials 里面的选项几乎都被墙，不适合国内网络环境。<br>2）建议在侧栏 &gt; Site &gt; Setting 中勾选 Private 选项，这样只能域名下使用</p>
<hr>
<h2 id="看板娘-桌宠"><a href="#看板娘-桌宠" class="headerlink" title="看板娘/桌宠"></a>看板娘/桌宠</h2><p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</a><br><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">https://github.com/xiazeyu/live2d-widget-models</a><br>npm install –save hexo-helper-live2d</p>
<p><del>/themes/next/layout/_layout.swig</del><br><del>body里添加{live2d()}</del><br>3.0不需要包含live2d(),只需安装依赖,models放入node_models内和站点文件配置live2d:</p>
<p>高定版本（高级定制<br><a href="https://github.com/stevenjoezhang/live2d-widget" target="_blank" rel="noopener">https://github.com/stevenjoezhang/live2d-widget</a><br>下载后放到目录/source/live2d-widget下，和_post同级<br>替换autoload.js中的live2d_path值和本地目录名称live2d-widget一致</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_layout.swig</span><br><span class="line">线上</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;stevenjoezhang&#x2F;live2d-widget@latest&#x2F;autoload.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">本地</span><br><span class="line">&lt;script src&#x3D;&quot;&#x2F;live2d-widget&#x2F;autoload.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p>首行缩进：空两格<br>&#160; &#160; &#160; &#160;开头<br><span style="background-color:#eee">字体高亮</span><br><code>字体高亮</code></p>

<table>
   <tr>
      <td colspan="6"><b>表格</b></td>
   </tr>
   <tr>
      <td>class</td><td>interface</td><td>byte</td><td>short</td><td>int</td><td>long</td>
   </tr>
   <tr>
      <td>class</td><td>interface</td><td>byte</td><td>short</td><td>int</td><td>long</td>
   </tr>
</table>



<hr>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图片根路径默认是source&#x2F;images</span><br><span class="line">![](&#x2F;images&#x2F;avatar.jpg)</span><br><span class="line">&#123;% img &#x2F;images&#x2F;avatar.jpg &quot;图片&quot; %&#125;</span><br><span class="line"></span><br><span class="line">fancybox放大预览，安装依赖后在配置页打开</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fancybox3 source&#x2F;lib&#x2F;fancybox</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;images&#x2F;avatar.jpg&quot; title&#x3D;&quot;放大预览&quot; alt&#x3D;&quot;放大预览&quot;&#x2F;&gt;</span><br><span class="line">&#123;% img &#x2F;images&#x2F;vi-vim-cheat-sheet.gif 600 600 &quot;点击查看大图:vi&#x2F;vim-cheat-sheet&quot; %&#125;</span><br><span class="line"></span><br><span class="line">themes&#x2F;next&#x2F;js&#x2F;utils内添加拦截，实现imageHref和imageTitle</span><br><span class="line">if ($image.hasClass(&#39;nofancybox&#39;)) &#123;</span><br><span class="line">  var imageHref &#x3D; $image.attr(&#39;href&#39;) </span><br><span class="line">  if(imageHref)&#123;</span><br><span class="line">    var imageWrapLink &#x3D; $image.wrap(&#96;&lt;a href&#x3D;$&#123;imageHref&#125; target&#x3D;&quot;_blank&quot;&gt;&lt;&#x2F;a&gt;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">  var imageTitle &#x3D; $image.attr(&#39;title&#39;) || $image.attr(&#39;alt&#39;);</span><br><span class="line">  if (imageTitle) &#123;</span><br><span class="line">    $image.after(&#96;&lt;p class&#x3D;&quot;image-caption&quot;&gt;$&#123;imageTitle&#125;&lt;&#x2F;p&gt;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;images&#x2F;avatar.jpg&quot; title&#x3D;&quot;不需要放大预览&quot; alt&#x3D;&quot;不需要放大预览&quot; class&#x3D;&quot;nofancybox&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<div style="display:flex;">
  <div style="flex:1">
    <img src="/images/avatar.jpg" title="放大预览" alt="放大预览"/>
  </div>
  <div style="flex:1">
    <img src="/images/avatar.jpg" title="不需要放大预览" alt="不需要放大预览" class="nofancybox"/>
  </div>
  <div style="flex:1">
    <img src="/images/avatar.jpg" title="跳转链接" alt="跳转链接" class="nofancybox" href="https://www.baidu.com" />
  </div>
</div>

<hr>
<h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br><span class="line"></span><br><span class="line">.md中top:true 或者true: 2控制多篇顺序</span><br><span class="line"></span><br><span class="line">添加样式themes&#x2F;hexo-theme-next&#x2F;layout&#x2F;_macr中&lt;div class&#x3D;&quot;post-meta&quot;&gt;里</span><br><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="随机副标题文案"><a href="#随机副标题文案" class="headerlink" title="随机副标题文案"></a>随机副标题文案</h2><p>站点_config.yml中：subtitle用-添加文案<br>/next/layout/_partials/header/brand.swig分割,数组随机显示</p>
<hr>
<h2 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h2><hr>
<h2 id="live2d"><a href="#live2d" class="headerlink" title="live2d"></a>live2d</h2><hr>
<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>如果没指定<code>[layout]</code>就使用<code>default_layout</code>中的默认模板</p>
<p>hexo new 文章名     // 简写新建<br>hexo new “文章名 1”  // 空格需要用引号<br>hexo new post 文章名 // 用post模板新建文章</p>
<p>npm install –save hexo-generator-index hexo-generator-archive hexo-generator-tag</p>
<hr>
<h2 id="个性化页面"><a href="#个性化页面" class="headerlink" title="个性化页面"></a>个性化页面</h2><p>站点_config.yml中skip_render配置过滤source下的指定目录或文件</p>
<hr>
<h2 id="创建标签和分类"><a href="#创建标签和分类" class="headerlink" title="创建标签和分类"></a>创建标签和分类</h2><p>hexo new page tags</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在tags&#x2F;index.md中加入</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<p>hexo new page categories</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories&#x2F;index.md中加入</span><br><span class="line">tags: &quot;categories&quot;</span><br></pre></td></tr></table></figure>

<p>文章页加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories: </span><br><span class="line">- Axx</span><br><span class="line">tags:</span><br><span class="line">- Bxx</span><br></pre></td></tr></table></figure>

<p>可以在scaffolds/post.md模板中加入categories:和tags:<br>每次hexo new 文章名时会自动包含分类和标签</p>
<hr>
<h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h2><p>npm install hexo-symbols-count-time –save</p>
<hr>
<h2 id="阅读全文"><a href="#阅读全文" class="headerlink" title="阅读全文"></a>阅读全文</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、md中手动&lt;!-- more --&gt;</span><br><span class="line">2、md中头部front-matter中使用description</span><br><span class="line">3、auto_excerpt功能在新版中弃用，换成npm包</span><br><span class="line">npm install hexo-excerpt --save</span><br><span class="line">主题_config.yml中&#96;添加&#96;:</span><br><span class="line">excerpt:</span><br><span class="line">  depth: 1</span><br><span class="line">  excerpt_excludes: []</span><br><span class="line">  more_excludes: []</span><br><span class="line">  hideWholePostExcerpts: false</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>引用algolia search:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、npm install --save hexo-algolia</span><br><span class="line">2、站点_config.yml中</span><br><span class="line">algolia:</span><br><span class="line">    applicationID: &#39;applicationID&#39;</span><br><span class="line">    indexName: &#39;indexName&#39;</span><br><span class="line">    chunkSize: 5000</span><br><span class="line"></span><br><span class="line">3、git bash中：</span><br><span class="line">$ export HEXO_ALGOLIA_INDEXING_KEY&#x3D;your Search key</span><br><span class="line">$ hexo algolia</span><br><span class="line">4、主题_config.yml中:</span><br><span class="line">algolia_search:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure>
<p>引用local search:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、npm install hexo-generator-searchdb --save</span><br><span class="line">2、站点_config.yml中</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line">4、主题_config.yml中:</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">5、hexo generate生成search.xml</span><br><span class="line">6、hexo server查看效果</span><br></pre></td></tr></table></figure>

<h2 id="hexo-admin后台管理"><a href="#hexo-admin后台管理" class="headerlink" title="hexo-admin后台管理"></a>hexo-admin后台管理</h2><p><code>DeprecationWarning: fs.SyncWriteStream is deprecated.</code>报错是因为node8.0+移除了方法，某插件依赖了这个方法<br>通过hexo –debug找到<br>在hexo-admin的依赖中找到hexo-fs/lib/fs.js并注释下面这行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.SyncWriteStream = fs.SyncWriteStream;</span><br></pre></td></tr></table></figure>

<!-- 发布配置局部信息
git config user.name xxx -->
]]></content>
      <categories>
        <category>hexo教程</category>
        <category>hexo入门</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World 欢迎来到hexo</title>
    <url>/2020/02/21/hello-world/</url>
    <content><![CDATA[<blockquote>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
</blockquote>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
