<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>迭代器Iterator与生成器Generator</title>
    <url>/2020/06/16/%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8Generator/</url>
    <content><![CDATA[<blockquote>
<p>迭代器是对象<br>生成器是返回迭代器的函数<br>够直接吧</p>
</blockquote>
<a id="more"></a>

<h1 id="迭代器是什么"><a href="#迭代器是什么" class="headerlink" title="迭代器是什么"></a>迭代器是什么</h1><p>迭代器是包含next方法的<code>对象</code></p>
<p>iterable（可迭代对象）:被外界访问的内部元素的数据结构,实现了 Symbol.iterator 方法<br>iterator（迭代器）:遍历数据结构元素的指针</p>
<h2 id="实现一个迭代器"><a href="#实现一个迭代器" class="headerlink" title="实现一个迭代器"></a>实现一个迭代器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义迭代,数组倒序</span></span><br><span class="line"><span class="keyword">const</span> myArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">myArr[<span class="built_in">Symbol</span>.iterator]= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="keyword">this</span>.length;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="keyword">this</span>[index],<span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">true</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [...myArr]; // [3, 2, 1]</span></span><br><span class="line"><span class="comment">// Array.from(myArr); // [3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<p>myArr有符合标准的 <code>Symbol.iterator 接口</code>，那就是 可迭代的(Iterator) ，调用这个<code>接口</code>返回的对象就是一个 迭代器</p>
<h2 id="关闭迭代器"><a href="#关闭迭代器" class="headerlink" title="关闭迭代器"></a>关闭迭代器</h2><p>1、当next()方法返回done:true时，正常执行结束关闭<br>2、调用符合规范的return()方法关闭</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIterable</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> iterable =&#123;</span><br><span class="line">        [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        next()&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">false</span>,<span class="attr">value</span>:<span class="string">'- -'</span>&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">return</span>()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'~~'</span>);</span><br><span class="line">            <span class="keyword">return</span>&#123;<span class="attr">done</span>:<span class="literal">false</span>,<span class="attr">value</span>:<span class="literal">undefined</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iterable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> myIterable()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生成器Generator"><a href="#生成器Generator" class="headerlink" title="生成器Generator"></a>生成器Generator</h1><p>生成器是返回迭代器的函数<br>Generator既是迭代器也是可迭代对象， 有next()和<a href="">Symbol.iterator</a></p>
<h2 id="使用生成器"><a href="#使用生成器" class="headerlink" title="使用生成器"></a>使用生成器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getIterator = <span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第1次"</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"A"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第2次"</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"B"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第3次"</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"C"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = getIterator();</span><br><span class="line"><span class="comment">// 每次调用next会在yield处返回结果并暂停</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); </span><br><span class="line"><span class="comment">// 传参会替换上一次yield的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">1</span>)); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getIterator2 = <span class="function"><span class="keyword">function</span> *(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ；i &lt; array.length; i++)&#123;</span><br><span class="line">       <span class="keyword">yield</span> array[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目 - 3个苹果，2个香蕉，发完了苹果才能发香蕉</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成器委托</span><br><span class="line">getAppleIterator &#x3D;  function*() &#123;</span><br><span class="line">    yield &quot;a1&quot;</span><br><span class="line">    yield &quot;a2&quot;</span><br><span class="line">    yield &quot;a3&quot;</span><br><span class="line">&#125;</span><br><span class="line">getBananaIterator &#x3D; function*()&#123;</span><br><span class="line">    yield &quot;b1&quot;</span><br><span class="line">    yield &quot;b2&quot;</span><br><span class="line">&#125;</span><br><span class="line">getFruitIterator &#x3D;  function*()&#123;</span><br><span class="line">    yield *getAppleIterator();</span><br><span class="line">    yield *getBananaIterator();</span><br><span class="line">&#125;</span><br><span class="line">fruit &#x3D; getFruitIterator();</span><br><span class="line">console.log(fruit.next());</span><br></pre></td></tr></table></figure>

<p>写到这里，想起以前看《你不知道的js》中有generator的概念，遂又去翻了翻</p>
<p>生成器里写业务，任务工具执行，不关心next()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行callback的里所有内容直到done:true</span></span><br><span class="line"><span class="keyword">let</span> run = <span class="function"><span class="keyword">function</span>(<span class="params">requestIteratorCreator</span>)</span>&#123;</span><br><span class="line">    task = requestIteratorCreator();</span><br><span class="line">	<span class="keyword">let</span> result = task.next(); <span class="comment">// 先执行</span></span><br><span class="line">	doTask = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!result.done)&#123;</span><br><span class="line">            result = task.next(result.value);</span><br><span class="line">            doTask()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	doTask() <span class="comment">// 看看是否继续执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> requestIteratorCreator = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">const</span> result = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">yield</span> result</span><br><span class="line">&#125;</span><br><span class="line">run(requestIteratorCreator)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>一些示例</title>
    <url>/2020/06/15/%E4%B8%80%E4%BA%9B%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<a id="more"></a>
<p>面试时遇到了那些你处理哪些业务场景使用xxx就一脸懵，想不起来啊<br>不知道大家有没有这种感觉，背古诗上半句能接下半句，但是下半句去接上半句就有点难了<br>更何况有些是特性，而非业务<br>anyway,开个目录记录下来，之后一点点在这里补充吧</p>
<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将变量保存进函数，待执行</span><br><span class="line">function makeSizer(size) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    console.log(size)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var size1 &#x3D; makeSizer(10);</span><br><span class="line">size1();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 私有化变量</span><br><span class="line">var Counter &#x3D; function() &#123;</span><br><span class="line">    var privateCounter &#x3D; 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        value: function() &#123;</span><br><span class="line">            return privateCounter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var counter1 &#x3D; Counter();</span><br><span class="line">counter1.value()</span><br></pre></td></tr></table></figure>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工具函数,工具类</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">checkList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">    checkCodeNum(codeNum, maxLen = <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (codeNum == <span class="string">''</span> || codeNum.length != maxLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取字符串并替换节点内容</span></span><br><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"workType"</span> v-getBaTitle=<span class="string">"item.position"</span>&gt;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">directives: &#123;</span></span><br><span class="line"><span class="regexp">    getBaTitle: &#123;</span></span><br><span class="line"><span class="regexp">        bind: function(el, binding) &#123;</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 通过binding.value获取绑定的值，并写入节点内</span></span><br><span class="line"><span class="regexp">            el.innerHTML = binding.value.split("-")[1] || "xxx";</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="遍历时删除，置顶合并数组"><a href="#遍历时删除，置顶合并数组" class="headerlink" title="遍历时删除，置顶合并数组"></a>遍历时删除，置顶合并数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 置顶数组中的指定对象</span></span><br><span class="line">baList(state) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state.list.length == <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> needTopItemArr = [];<span class="comment">// 保存取出来的对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; state.list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state.list[i].serviceStar) &#123;</span><br><span class="line">            needTopItemArr.push(state.list[i]);</span><br><span class="line">            state.list.splice(i, <span class="number">1</span>);</span><br><span class="line">            i--;<span class="comment">// for边循环边删除需要修改i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> needTopItemArr.concat(state.list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
  </entry>
  <entry>
    <title>通过数组边遍历边删除来回顾迭代器</title>
    <url>/2020/06/14/%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E8%BE%B9%E9%81%8D%E5%8E%86%E8%BE%B9%E5%88%A0%E9%99%A4%E6%9D%A5%E5%9B%9E%E9%A1%BE%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>遍历时删除会出现什么问题<br>迭代器是什么,for,forEach,for in,for of都是什么</p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="遍历时删除会出现什么问题"><a href="#遍历时删除会出现什么问题" class="headerlink" title="遍历时删除会出现什么问题"></a>遍历时删除会出现什么问题</h1><p>先看这个例子，遍历数组时删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    arr.splice(i,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(i,arr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">arr.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    arr.splice(index,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 0,[2,3]</span></span><br><span class="line"><span class="comment">// 1,[2]</span></span><br></pre></td></tr></table></figure>
<p>发现结果和期望不一样，应该是个空数组<br>因为当修改原数组时，下一轮用的是这个新的数组，所以第二轮实际上是[2,3]的arr[1]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正序删除，需要更新下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    arr.splice(i,<span class="number">1</span>);</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反序删除</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = arr.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    arr.splice(i,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，java中有iterator.remove()方法进行删除</p>
<hr>
<h1 id="for-forEach-for-in-for-of差异"><a href="#for-forEach-for-in-for-of差异" class="headerlink" title="for,forEach,for in,for of差异"></a><code>for</code>,<code>forEach</code>,<code>for in</code>,<code>for of</code>差异</h1><p>通过MDN来<code>简单</code>回顾一下它们</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a><code>for</code></h2><p>常见的处理<code>数组</code>的循环嘛<br>for (let i = 0; i &lt; 9; i++) {}</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>提前结束<ul>
<li>break退出循环</li>
<li>continue提前结束本次循环，开始下一轮</li>
</ul>
</li>
<li>是所有循环语法糖的基础 </li>
<li>作用域<ul>
<li>使用 var 声明的变量与 for 循环处在同样的作用域中。用 let 声明的变量是语句的局部变量。</li>
</ul>
</li>
</ul>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><code>forEach</code></h2><p>依旧是处理<code>数组</code>的循环，对每个元素依次执行一次指定函数  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.forEach(<span class="function">(<span class="params">item,index,_arr</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// _arr是数组对象本身，不会改变原数组</span></span><br><span class="line">    <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>)</span><br><span class="line">&#125;,<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
<p>那些已删除或者未初始化的项将被跳过（例如稀疏数组[1,,3,,5]）<br>(callback,thisArg) 还接收第二参数this，用法参照函数的this规则，默认指向window，见文末1</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>提前结束<ul>
<li>throw抛出异常</li>
</ul>
</li>
<li>实现浅拷贝，和循环类似<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> copy = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj)) <span class="comment">// 返回指定对象的原型</span></span><br><span class="line">    <span class="keyword">const</span> propNames = <span class="built_in">Object</span>.getOwnPropertyNames(obj); <span class="comment">// 返回属性的属性名</span></span><br><span class="line">    propNames.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, name); <span class="comment">// 返回属性名对应的四大属性描述符configurable,enumerable,value,writable</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(copy, name, desc); <span class="comment">// 更新对象的现有属性</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在遍历时删除会遇到同样的问题，因为每次都是以当前arr执行</li>
<li>扁平化数组,建议使用flat()<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(i))</span><br><span class="line">            result.push(...flatten(i));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result.push(i);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> problem = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>], <span class="number">8</span>, <span class="number">9</span>]];</span><br><span class="line">flatten(problem); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a><code>for in</code></h2><p>以<code>任意顺序</code>遍历一个<code>对象</code>的除Symbol以外的<code>可枚举属性enumerable</code>（包括它的原型链上的可枚举属性）</p>
<p>用于调试，可以更方便的去检查对象属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(prop))&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>迭代过程中不要进行该<code>对象</code>的增删改<ul>
<li>不保证新属性会被访问到</li>
</ul>
</li>
<li>不建议用于<code>数组</code><ul>
<li>因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素</li>
</ul>
</li>
<li>只迭代对象自身的属性<ul>
<li>getOwnPropertyNames() 或 hasOwnProperty() 或 propertyIsEnumerable 确定某属性是否是对象本身的属性</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个例子可以看到由于存在原型链继承规则</span></span><br><span class="line"><span class="comment">// 所以iterable要过滤，否则需要遍历很多不相关元素</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">iterable.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// logs 0, 1, 2, "foo", "arrCustom", "objCustom"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iterable.hasOwnProperty(i)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// logs 0, 1, 2, "foo"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a><code>for of</code></h2><p>在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul>
<li>弥补 forEach 和 for…in 的缺点</li>
<li>提前结束<ul>
<li>break, continue, throw</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String </span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="string">"boo"</span>;</span><br><span class="line"><span class="comment">// 'a' 'b' 'c'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypedArray </span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0x00</span>, <span class="number">0xff</span>]);</span><br><span class="line"><span class="comment">// 0 255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"a"</span>, <span class="number">1</span>], [<span class="string">"b"</span>, <span class="number">2</span>], [<span class="string">"c"</span>, <span class="number">3</span>]]);</span><br><span class="line"><span class="comment">// ["a", 1] ["b", 2] ["c", 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments 对象</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> argument <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(argument);<span class="comment">// 1 2 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> articleParagraphs = <span class="built_in">document</span>.querySelectorAll(<span class="string">"article &gt; p"</span>);</span><br><span class="line"><span class="comment">// item.classList.add("read");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>) </span>&#123;<span class="keyword">yield</span> curr;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> fibonacci()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for-in-of区别"><a href="#for-in-of区别" class="headerlink" title="for in/of区别"></a>for in/of区别</h2><p>迭代方式</p>
<p>for…in 语句以任意顺序迭代对象的<code>可枚举属性</code>。<br>for…of 语句遍历<code>可迭代对象</code>定义要迭代的数据。</p>
<h1 id="迭代器是什么"><a href="#迭代器是什么" class="headerlink" title="迭代器是什么"></a>迭代器是什么</h1><h2 id="迭代器是包含next方法的对象"><a href="#迭代器是包含next方法的对象" class="headerlink" title="迭代器是包含next方法的对象"></a>迭代器是包含next方法的<code>对象</code></h2><p>{done:是否结束，产生下一个值,value:返回值}<br>本质上，迭代器会不断调用其 next() 方法直到返回 done: true  </p>
<p>Array 或 Map 等内置<code>可迭代对象</code>有默认的迭代行为<br>Object 则<code>没有</code>所以不能直接用for…of ，可以用Object.keys(obj)，Object.entries(obj)</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">for..of</span><br><span class="line">扩展运算符</span><br><span class="line">yield*</span><br><span class="line">解构赋值</span><br><span class="line">内置API在接收数组参数时会调用数组的迭代行为</span><br><span class="line"><span class="code">    Array.from()</span></span><br><span class="line"><span class="code">    Map(),Set(),WeakMap(),WeakSet()</span></span><br><span class="line"><span class="code">    Promise.all()/Promise.race()</span></span><br></pre></td></tr></table></figure>
<hr>
<hr>
<hr>
<blockquote>
<p>附录</p>
</blockquote>
<p>这里来枚举一下forEach中的this情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    arrFunc1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,_arr</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 普通函数，普通回调，【检查】thisArg，this-&gt;arr</span></span><br><span class="line">            <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>) </span><br><span class="line">        &#125;,arr)</span><br><span class="line">    &#125;,</span><br><span class="line">    arrFunc2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function">(<span class="params">item,index,_arr</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 普通函数，箭头回调，【忽视】thisArg，this-&gt;obj</span></span><br><span class="line">            <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>) </span><br><span class="line">        &#125;,arr)</span><br><span class="line">    &#125;,</span><br><span class="line">    arrFunc3:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,_arr</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 箭头函数，普通回调，【检查】thisArg，this-&gt;arr</span></span><br><span class="line">            <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>) </span><br><span class="line">        &#125;,arr)</span><br><span class="line">    &#125;,</span><br><span class="line">    arrFunc4:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function">(<span class="params">item,index,_arr</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 箭头函数，箭头回调，【忽视】thisArg，this-&gt;window</span></span><br><span class="line">            <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>) </span><br><span class="line">        &#125;,arr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.arrFunc1()</span><br></pre></td></tr></table></figure>

<pre><code class="js"></code></pre>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>最近在看</title>
    <url>/2020/06/12/%E6%9C%80%E8%BF%91%E5%9C%A8%E7%9C%8B/</url>
    <content><![CDATA[<blockquote>
<p>想知道我最近关注什么 点进来看看<br>找工作中 T-T….base上海，<a href="http://www.leow.net.cn/resume/" target="_blank" rel="noopener">查看cv</a></p>
</blockquote>
<a id="more"></a>
<p>正在做 - 2020/6<br><code>uniapp v2.7</code><br><code>ECharts v4.8</code><br><code>vue-element-admin v4</code><br><code>Element ui</code> (维护频率变低，要流失到ant了- -)</p>
<p>小目标 - 2020<br>更新博客-&gt;github标绿/天</p>
<p>计划项 - 2020<br><code>quasar</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">ui库吧</span><br></pre></td></tr></table></figure>
<p><code>vue stable v3</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">API解构，更hooks了</span><br></pre></td></tr></table></figure>
<p><code>webpack stable v5</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">微前端的模块化</span><br><span class="line">服务暴露独立编译的模块，宿主远程引用</span><br><span class="line">避免重复加载</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>如果你有更有意思的推荐，可以在下方留言给我~</p>
</blockquote>
<hr>
]]></content>
  </entry>
  <entry>
    <title>通过await在definePorperty中的表现重新认识async</title>
    <url>/2020/06/12/%E9%80%9A%E8%BF%87await%E5%9C%A8definePorperty%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86async/</url>
    <content><![CDATA[<blockquote>
<p>defineProperty中无法获取await get()的值<br>再来看看async/await</p>
</blockquote>
<a id="more"></a>
<p>群里聊天时看到抛出的一个问题和相关代码，<code>Object.defineProperty</code>中的get使用await为啥不能同步获取到值<br>用这俩语法糖执行同步任务也有一段时间了，看到这个问题还是有点懵，经过实践解决了这个问题<br>那通过<code>MDN</code>重新再了解一下async/await  </p>
<hr>
<h2 id="异步转同步的发展过程"><a href="#异步转同步的发展过程" class="headerlink" title="异步转同步的发展过程"></a>异步转同步的发展过程</h2><ul>
<li>ajax需要在callback中获取结果，当有请求结果和请求参数有相互依赖时需要多层嵌套，出现回调地狱的代码问题  </li>
<li>而Promise可以在then()中拿到结果，让每步调用写法更清晰，解决回调地狱  </li>
<li>async更简洁，更优雅的错误处理，易于调试  </li>
</ul>
<p><code>async</code>定义一个返回Promise对象的异步函数<br><code>await</code>会暂停异步函数的执行,并等待Promise执行，然后继续执行异步函数，并返回结果<br>是generator生成器的语法糖  </p>
<h2 id="通过俩例子了解一下async-await"><a href="#通过俩例子了解一下async-await" class="headerlink" title="通过俩例子了解一下async/await"></a>通过俩例子了解一下async/await</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'异步结果'</span>, val)</span><br><span class="line">            res(val)</span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'异步getData'</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getVal</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> getData(val)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'正常的异步转同步'</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'getVal'</span>, getVal(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>会发现打印的是一个Promise对象 pending状态，这也符合async的返回，而内部的函数是正常同步执行的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData2</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'异步2结果'</span>, val)</span><br><span class="line">            res(val)</span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'异步2getData2'</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getVal2</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> getData2(val)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'依旧正常的异步转同步'</span>, result)</span><br><span class="line">&#125;</span><br><span class="line">getVal2(<span class="number">33</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'这行还是会先于getVal2执行的哦'</span>)</span><br></pre></td></tr></table></figure>
<p>原来，async/await 保证的是，同一个作用域中存在同步代码和异步代码时，等待获取到promise结果后再执行后续代码</p>
<h2 id="如何解决get中的await取值"><a href="#如何解决get中的await取值" class="headerlink" title="如何解决get中的await取值"></a>如何解决get中的await取值</h2><p>定义一个函数，改变对象的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">target, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="comment">// console.log('执行get', val)</span></span><br><span class="line">            <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    res(<span class="string">'success'</span>)</span><br><span class="line">                &#125;, <span class="number">2000</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// console.log('结束执行Promise', res, val)</span></span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'设置新的值'</span>, newVal)</span><br><span class="line">            val = newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为什么get()中使用async不会生效呢</span></span><br><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</span><br><span class="line">def(a, <span class="string">'id'</span>, <span class="number">1</span>);</span><br><span class="line">a.id = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.id---'</span>, a.id) <span class="comment">// 可以看到返回的是 Promise &#123; &lt;pending&gt; &#125;</span></span><br></pre></td></tr></table></figure>
<p>通过上文关于async/await的语法含义，解决这个问题就很简单了<br>目的是获取get中的await返回val而不是promise<br>通过代理包装一层async/await，就能正常获取get()的值  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取指定对象的当前值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myProxy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对指定对象执行加法运算</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myProxyAddition</span>(<span class="params">obj, key, num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> myProxy(obj[key])</span><br><span class="line">    <span class="keyword">let</span> new_result = result + num;</span><br><span class="line">    obj[key] = new_result;</span><br><span class="line">    <span class="keyword">return</span> new_result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对指定对象执行加法运算</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myProxySubtraction</span>(<span class="params">obj, key, num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> myProxy(obj[key])</span><br><span class="line">    <span class="keyword">let</span> new_result = result - num;</span><br><span class="line">    obj[key] = new_result;</span><br><span class="line">    <span class="keyword">return</span> new_result;</span><br><span class="line">&#125;</span><br><span class="line">myProxyAddition(a, <span class="string">'id'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// myProxySubtraction(a, 'id', 3);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计时器的结果,每隔1秒返回</span></span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> myProxy(a.id)</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        clearInterval(timer)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    myProxyAddition(a, <span class="string">'id'</span>, <span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环的结果,2秒后一起返回</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>].map(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    myProxyAddition(a, <span class="string">'id'</span>, <span class="number">1</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>虽然实际开发中不会遇到defineProperty中await get()的情况，但是通过这次的例子可以加深对语法糖的理解~</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>接口返回10万条数据前端如何加载</title>
    <url>/2020/06/11/%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E10%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<blockquote>
<p>震惊！后端大哥偷懒不分页，前端如何在不影响性能时加载大量数据</p>
</blockquote>
<a id="more"></a>

<p>原文:<a href="https://zhuanlan.zhihu.com/p/147178478" target="_blank" rel="noopener">刘小夕</a></p>
<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"appScrollData"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"poll"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="初级方案，直接渲染"><a href="#初级方案，直接渲染" class="headerlink" title="初级方案，直接渲染"></a>初级方案，直接渲染</h2><p>数据量庞大将导致页面性能极具降低, 造成页面卡顿</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处直接使用了原文中的获取数据方式，只做了同步转换</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">way1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'开始创建'</span>)</span><br><span class="line">        <span class="built_in">console</span>.time(<span class="string">'普通创建对象'</span>)</span><br><span class="line">        <span class="keyword">let</span> box = <span class="built_in">document</span>.createElement(<span class="string">"ul"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">            div1.innerHTML = <span class="string">`<span class="subst">$&#123;res.data[i].title&#125;</span> <span class="subst">$&#123;res.data[i].name&#125;</span> <span class="subst">$&#123;res.data[i].text&#125;</span>`</span></span><br><span class="line">            box.appendChild(div1)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(box, res.data)</span><br><span class="line">        app.appendChild(box)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">'普通创建对象'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 文档碎片创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">way2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'开始创建'</span>)</span><br><span class="line">        <span class="built_in">console</span>.time(<span class="string">'文档碎片创建对象'</span>)</span><br><span class="line">        <span class="keyword">var</span> box = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">            div1.innerHTML = <span class="string">`<span class="subst">$&#123;res.data[i].title&#125;</span> <span class="subst">$&#123;res.data[i].name&#125;</span> <span class="subst">$&#123;res.data[i].text&#125;</span>`</span></span><br><span class="line">            box.appendChild(div1)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(box, res.data)</span><br><span class="line">        app.appendChild(box)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">'文档碎片创建对象'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// way1();</span></span><br><span class="line"><span class="comment">// way2();</span></span><br></pre></td></tr></table></figure>

<p>这里用到了 console.time/console.timeEnd 计算函数运行时长<br>注意为什么<code>console.timeEnd</code>放在了<code>setTimeout</code>中？<br>事件循环先宏任务，再微任务，最后更新ui<br>setTimeout属于宏任务<br>这里需要得到能够渲染数据后的运行时长，所以放在了下一轮宏任务中，能够准确获取总</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 10w数据  普通                    文档碎片</span><br><span class="line">&#x2F;&#x2F; chrome   10521.47412109375ms     12217.3671875ms</span><br><span class="line">&#x2F;&#x2F; edge     8409.425048828125ms     8900.69287109375ms</span><br><span class="line">&#x2F;&#x2F; firefox  828ms                   卡崩溃了</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(createDocumentFragment真的更快吗？大家可以测试告诉我)</p>
</blockquote>
<h2 id="中级方案，懒加载-分页"><a href="#中级方案，懒加载-分页" class="headerlink" title="中级方案，懒加载+分页"></a>中级方案，懒加载+分页</h2><p>渲染首屏，后续窗口滚动时防抖优化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getApiData = [];</span><br><span class="line"><span class="keyword">let</span> way3Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分页</span></span><br><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line"><span class="keyword">let</span> curPage = <span class="number">1</span>; <span class="comment">// 当前的页数</span></span><br><span class="line"><span class="keyword">let</span> pageSize = <span class="number">30</span>; <span class="comment">// 每一页展示的数量 * data 传入的数据量</span></span><br><span class="line"><span class="keyword">let</span> prevY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">way3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        getApiData = res.data;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> time = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        clearTimeout(time);</span><br><span class="line">        time = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听scroll事件，使用getBoundingClientRect获取底部空占位元素相对于可视窗口的距离进行懒加载</span></span><br><span class="line"><span class="comment">// 回滚时需要单向锁</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollAndLoading</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.scrollY &gt; prevY) &#123; <span class="comment">// 判断用户是否向下滚动</span></span><br><span class="line">        prevY = <span class="built_in">window</span>.scrollY; <span class="comment">// 在向下滚动并且滚动高度大于上一次时更新</span></span><br><span class="line">        <span class="keyword">if</span> (poll.getBoundingClientRect().top &lt;= <span class="built_in">window</span>.innerHeight) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getApiData.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'getApiData数据还未请求返回'</span>);</span><br><span class="line">            <span class="comment">// 请求下一页数据,每次渲染量为pageSize</span></span><br><span class="line">            curPage++;</span><br><span class="line">            way3Data = getApiData.slice(pageSize * (curPage - <span class="number">1</span>), pageSize * curPage)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'开始创建'</span>, way3Data.length / getApiData.length)</span><br><span class="line">            <span class="built_in">console</span>.time(<span class="string">'文档碎片创建对象'</span>)</span><br><span class="line">            <span class="keyword">var</span> box = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; way3Data.length; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">                div1.innerHTML = <span class="string">`<span class="subst">$&#123;way3Data[i].title&#125;</span> <span class="subst">$&#123;way3Data[i].name&#125;</span> <span class="subst">$&#123;way3Data[i].text&#125;</span>`</span></span><br><span class="line">                box.appendChild(div1)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(box, way3Data)</span><br><span class="line">            app.appendChild(box)</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.timeEnd(<span class="string">'文档碎片创建对象'</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// way3();</span></span><br><span class="line"><span class="comment">// const getWay3Data = debounce(scrollAndLoading, 300)</span></span><br><span class="line"><span class="comment">// window.addEventListener('scroll', getWay3Data, false)</span></span><br></pre></td></tr></table></figure>

<h2 id="高级方案，更优雅的实现方式"><a href="#高级方案，更优雅的实现方式" class="headerlink" title="高级方案，更优雅的实现方式"></a>高级方案，更优雅的实现方式</h2><ul>
<li>js缓冲器来分片处理</li>
<li>虚拟长列表 核心思路就是每次只渲染可视区域的列表数,当滚动后动态的追加元素并通过顶部padding来撑起整个滚动内容</li>
<li>web worker来将需要在前端进行大量计算的逻辑移入进去, 保证js主进程的快速响应, 让web worker线程在后台计算</li>
<li>模糊搜索，二分法优化</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的写法每轮是取数组第一项，并执行添加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multistep</span>(<span class="params">steps, taskHandle, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// var tasks = steps.concat();</span></span><br><span class="line">    <span class="keyword">var</span> tasks = steps;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> task = tasks.shift(); <span class="comment">// 每次执行一步</span></span><br><span class="line">        <span class="comment">// task.apply(null, args || []); //调用Apply参数必须是数组</span></span><br><span class="line">        taskHandle(task);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// arguments.callee代表multistep函数</span></span><br><span class="line">            setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">25</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">25</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">way4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        getApiData = res.data;</span><br><span class="line">        multistep(getApiData, <span class="function"><span class="keyword">function</span>(<span class="params">_arr</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// console.time('文档碎片创建对象')</span></span><br><span class="line">            <span class="keyword">let</span> box = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">            <span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">            div1.innerHTML = <span class="string">`<span class="subst">$&#123;_arr.title&#125;</span> <span class="subst">$&#123;_arr.name&#125;</span> <span class="subst">$&#123;_arr.text&#125;</span>`</span>;</span><br><span class="line">            box.appendChild(div1);</span><br><span class="line">            app.appendChild(box);</span><br><span class="line">            <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">            <span class="comment">//     console.timeEnd('文档碎片创建对象')</span></span><br><span class="line">            <span class="comment">// &#125;)</span></span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'way4完成'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// way4()</span></span><br></pre></td></tr></table></figure>
<p>这里用分片处理，每个事件循环周期处理几十条数据,每轮5ms<br>步骤的集合，每次执行的依赖参数，完成结果回调</p>
<hr>
<p>无论采取什么方案，最终目的是释放主线程，让用户可进行交互操作时，无卡顿感知</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>创建新的window隔离沙箱</title>
    <url>/2020/06/11/%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84window%E9%9A%94%E7%A6%BB%E6%B2%99%E7%AE%B1/</url>
    <content><![CDATA[<blockquote>
<p>一起来了解下~<br><code>target=&quot;_blank</code>的安全隐患<br>当window下的全局方法被污染了，如何获取到原本的全局方法getComputedStyle</p>
</blockquote>
<a id="more"></a>

<p>前情提要<br>  1、 <code>target=&quot;_blank&quot;</code>的安全/性能隐患<br>  2、window被污染后当前网页找到一个新的window</p>
<hr>
<p>看到一篇文章，讲的是<code>&lt;a/&gt;</code>标签的<code>target=&quot;_blank&quot;</code>的安全/性能隐患<br>众所周知，这个操作会打开一个新窗口</p>
<ul>
<li>有数据表面国外站点倾向于当前页跳转，有连贯性，减少窗口数量</li>
<li>而国内站点倾向于打开新窗口，优化搜索结果及返回页</li>
</ul>
<h2 id="那会有什么安全-性能隐患呢？"><a href="#那会有什么安全-性能隐患呢？" class="headerlink" title="那会有什么安全/性能隐患呢？"></a>那会有什么安全/性能隐患呢？</h2><p>window.opener获取到来源页面的window对象，即时跨域也不受影响 <code>excuse me?</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父 http://xx.xx.xx.xx:8000/父.html</span></span><br><span class="line">&lt;a href=<span class="string">"http://localhost:8000/子.html"</span> target=<span class="string">"_blank"</span>&gt;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子 http:/</span><span class="regexp">/localhost:8000/</span>子.html</span><br><span class="line"><span class="built_in">window</span>.opener.location = <span class="string">'https://www.baidu.com'</span></span><br></pre></td></tr></table></figure>
<p>在ip跨域时，竟然真的触发了父跳转，这被钓鱼可咋办</p>
<p><code>target=&quot;_blank&quot;</code>的窗口和父窗口公用一个进程，so资源占用你懂的</p>
<blockquote>
<p>如何保障你的网站外链合规</p>
</blockquote>
<ul>
<li>为了防止CSRF攻击<ul>
<li>父页面跳转到钓鱼登录页</li>
<li>发送带参get请求</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父 在a标签上加属性</span></span><br><span class="line">&lt;a rel=<span class="string">"noopener"</span> /&gt;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">&lt;a rel=<span class="string">"noreferrer"</span>/&gt;</span><br><span class="line"><span class="comment">/////////////////////////////</span></span><br><span class="line"><span class="comment">// 或者重写open()</span></span><br><span class="line"><span class="keyword">var</span> window_open = <span class="built_in">window</span>.open();</span><br><span class="line">window_open.opener = <span class="literal">null</span>;</span><br><span class="line">window_open.location = <span class="string">'yourUrl'</span>;</span><br><span class="line">window_open.target = <span class="string">"_blank"</span>;</span><br></pre></td></tr></table></figure>
<p>这样子窗口就是独立的进程了</p>
<p>hexo的主题已经支持这个方案了，不过插件生态好像并没有，（比如文末的本文链接- -,可以提issue了）</p>
<h2 id="如何找到新的window"><a href="#如何找到新的window" class="headerlink" title="如何找到新的window"></a>如何找到新的window</h2><p>回忆起遇到了这么一题，getComputedStyle方法被重写了，要获取css伪元素的content中的文字，当前页面的window被污染了，从哪里得到新的window呢</p>
<blockquote>
<p>iframe和open</p>
</blockquote>
<p>以getComputedStyle举例，这里就放部分代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父</span></span><br><span class="line">#t1::before &#123;content: '我是父t1';&#125;</span><br><span class="line"><span class="built_in">window</span>.getComputedStyle = <span class="string">""</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'通过子获取父style'</span>, <span class="built_in">window</span>.frames[<span class="string">'iframe1'</span>].contentWindow.getComputedStyle(<span class="built_in">document</span>.getElementById(<span class="string">'t1'</span>), <span class="string">':before'</span>).content)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'调用子方法'</span>,<span class="built_in">window</span>.frames[<span class="string">'iframe1'</span>].contentWindow.funcLeo_c())</span><br><span class="line"><span class="comment">// 子</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'从子获取父style'</span>, <span class="built_in">window</span>.getComputedStyle(<span class="built_in">window</span>.parent.document.getElementById(<span class="string">'t1'</span>), <span class="string">':before'</span>).content)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'调用父方法'</span>,<span class="built_in">window</span>.parent.funcLeo_p())</span><br></pre></td></tr></table></figure>

<p>当然还有上文提到的open()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="built_in">window</span>.open(<span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.log(win.getComputedStyle(<span class="built_in">document</span>.getElementById(<span class="string">'t1'</span>), <span class="string">':before'</span>).content)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>不一样的console-log</title>
    <url>/2020/06/10/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84console-log/</url>
    <content><![CDATA[<blockquote>
<p>来看看 控制台中console的各种实现~</p>
</blockquote>
<a id="more"></a>

<ul>
<li>console.log 用于输出普通信息</li>
<li>console.info 用于输出提示性信息</li>
<li>console.error 用于输出错误信息</li>
<li>console.warn 用于输出警示信息</li>
<li>console.group&amp;console.groupEnd 输出一组信息</li>
<li>console.table 信息通过表格展示</li>
<li>console.count 函数执行次数</li>
<li>console.dir将Dom 树结构输出</li>
<li>console.time 计时开始</li>
<li>console.timeEnd 计时结束</li>
<li>console.profile&amp;console.profileEnd 查看CPU使用相关信息、</li>
<li>console.timeLine&amp;console.timeLineEnd 记录一段时间轴</li>
<li>console.trace 堆栈跟踪相关的调试</li>
</ul>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>复制代码贴入console中试试看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 换行</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第一行\n第二行'</span>);</span><br><span class="line"><span class="comment">// 样式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'%c换个颜色'</span>,<span class="string">'color:blue;'</span>);</span><br><span class="line"><span class="comment">// 图片</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"%c "</span>,<span class="string">"background: url(https://gitby-leo.github.io/images/avatar.jpg) no-repeat center;padding-left:80px;padding-bottom: 80px;"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="字符画"><a href="#字符画" class="headerlink" title="字符画"></a>字符画</h2><p>打开<a href="http://patorjk.com/" target="_blank" rel="noopener">http://patorjk.com/</a>找到<a href="http://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type%20Something%20" target="_blank" rel="noopener">Text to ASCII Art Generator</a></p>
<p>目前支持315种英文字符样式</p>
<p>字符生成复制后直接放console</p>
<p>npm包，如<a href="https://www.npmjs.com/package/figlet" target="_blank" rel="noopener">figlet</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开控制台可见</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`</span></span><br><span class="line"><span class="string"> __    ____  _____ </span></span><br><span class="line"><span class="string">(  )  ( ___)(  _  )</span></span><br><span class="line"><span class="string"> )(__  )__)  )(_)( </span></span><br><span class="line"><span class="string">(____)(____)(_____)</span></span><br><span class="line"><span class="string">`</span>)</span><br></pre></td></tr></table></figure>
<script>
console.log(`
 __    ____  _____ 
(  )  ( ___)(  _  )
 )(__  )__)  )(_)( 
(____)(____)(_____)
`) 
</script>

<pre><code class="js">&lt;script&gt;
<span class="built_in">console</span>.log(<span class="string">`</span>
<span class="string">          _____            _____                   _______         </span>
<span class="string">         /\    \          /\    \                 /::\    \        </span>
<span class="string">        /::\____\        /::\    \               /::::\    \       </span>
<span class="string">       /:::/    /       /::::\    \             /::::::\    \      </span>
<span class="string">      /:::/    /       /::::::\    \           /::::::::\    \     </span>
<span class="string">     /:::/    /       /:::/\:::\    \         /:::/~~\:::\    \    </span>
<span class="string">    /:::/    /       /:::/__\:::\    \       /:::/    \:::\    \   </span>
<span class="string">   /:::/    /       /::::\   \:::\    \     /:::/    / \:::\    \  </span>
<span class="string">  /:::/    /       /::::::\   \:::\    \   /:::/____/   \:::\____\ </span>
<span class="string"> /:::/    /       /:::/\:::\   \:::\    \ |:::|    |     |:::|    |</span>
<span class="string">/:::/____/       /:::/__\:::\   \:::\____\|:::|____|     |:::|    |</span>
<span class="string">\:::\    \       \:::\   \:::\   \::/    / \:::\    \   /:::/    / </span>
<span class="string"> \:::\    \       \:::\   \:::\   \/____/   \:::\    \ /:::/    /  </span>
<span class="string">  \:::\    \       \:::\   \:::\    \        \:::\    /:::/    /   </span>
<span class="string">   \:::\    \       \:::\   \:::\____\        \:::\__/:::/    /    </span>
<span class="string">    \:::\    \       \:::\   \::/    /         \::::::::/    /     </span>
<span class="string">     \:::\    \       \:::\   \/____/           \::::::/    /      </span>
<span class="string">      \:::\    \       \:::\    \                \::::/    /       </span>
<span class="string">       \:::\____\       \:::\____\                \::/____/        </span>
<span class="string">        \::/    /        \::/    /                 ~~              </span>
<span class="string">         \/____/          \/____/                                  </span>
<span class="string"></span>
<span class="string">`</span>) </code></pre>
<p></script></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>用Web Components写摄像头组件</title>
    <url>/2020/06/08/%E7%94%A8Web%20Components%E5%86%99%E6%91%84%E5%83%8F%E5%A4%B4%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>Web Components中最佳特性就是shadow DOM的防污染封装<br>来看看怎么实现一个摄像头组件吧~</p>
</blockquote>
<a id="more"></a>

<p>原文:<a href="https://www.w3cplus.com/javascript/how-to-build-the-simple-camera-component.html" target="_blank" rel="noopener">大漠w3c</a></p>
<hr>
<ul>
<li>使用MediaDevices API获取相机访问权限</li>
<li>使用video元素播放MediaStream</li>
<li>使用canvas元素以blob或base64形式拍照</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;simple-camera&gt;&lt;/simple-camera&gt;</span></span><br><span class="line"><span class="comment">// &lt;button id="btnPhoto"&gt;拍一张&lt;/button&gt;</span></span><br><span class="line"><span class="comment">// &lt;button id="btnBase64Photo"&gt;转为base64&lt;/button&gt;</span></span><br><span class="line"><span class="comment">// &lt;img id="base64Img" src="#" alt=""&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCamera</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125; <span class="comment">// 当元素连接到DOM时调用这个函数</span></span><br><span class="line">    connectedCallback() &#123; </span><br><span class="line">        <span class="comment">// shadow样式保持 </span></span><br><span class="line">        <span class="keyword">const</span> shadow = <span class="keyword">this</span>.attachShadow(&#123;</span><br><span class="line">            mode: <span class="string">'open'</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.videoElement = <span class="built_in">document</span>.createElement(<span class="string">'video'</span>);</span><br><span class="line">        <span class="keyword">this</span>.canvasElement = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">        <span class="keyword">this</span>.videoElement.setAttribute(<span class="string">'playsinline'</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.canvasElement.style.display = <span class="string">'none'</span>;</span><br><span class="line"></span><br><span class="line">        shadow.appendChild(<span class="keyword">this</span>.videoElement);</span><br><span class="line">        shadow.appendChild(<span class="keyword">this</span>.canvasElement)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配给目标元素执行</span></span><br><span class="line">    open(constraints) &#123;</span><br><span class="line">        <span class="comment">// 本地测试不要使用ip，要用localhost，否则没有navigator.mediaDevices</span></span><br><span class="line">        <span class="keyword">return</span> navigator.mediaDevices.getUserMedia(constraints)</span><br><span class="line">            .then(<span class="function">(<span class="params">mediaStream</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 分配MediaStream </span></span><br><span class="line">                <span class="keyword">this</span>.videoElement.srcObject = mediaStream;</span><br><span class="line">                <span class="comment">// 加载时播放流 </span></span><br><span class="line">                <span class="keyword">this</span>.videoElement.onloadedmetadata = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.videoElement.play()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从video元素中绘制帧</span></span><br><span class="line">    _drawImage() &#123;</span><br><span class="line">        <span class="keyword">const</span> imageWidth = <span class="keyword">this</span>.videoElement.videoWidth;</span><br><span class="line">        <span class="keyword">const</span> imageHeight = <span class="keyword">this</span>.videoElement.videoHeight;</span><br><span class="line">        <span class="keyword">this</span>.canvasElement.width = imageWidth;</span><br><span class="line">        <span class="keyword">this</span>.canvasElement.height = imageHeight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> context = <span class="keyword">this</span>.canvasElement.getContext(<span class="string">'2d'</span>);</span><br><span class="line">        context.drawImage(<span class="keyword">this</span>.videoElement, <span class="number">0</span>, <span class="number">0</span>, imageWidth, imageHeight);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            imageHeight,</span><br><span class="line">            imageWidth</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// canvas的toBlob()转为同步</span></span><br><span class="line">    takeBlobPhoto() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">            imageHeight,</span><br><span class="line">            imageWidth</span><br><span class="line">        &#125; = <span class="keyword">this</span>._drawImage();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.canvasElement.toBlob(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">                resolve(&#123;</span><br><span class="line">                    blob,</span><br><span class="line">                    imageHeight,</span><br><span class="line">                    imageWidth</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// canvase转base64</span></span><br><span class="line">    takeBase64Photo(&#123;</span><br><span class="line">        type,</span><br><span class="line">        quality</span><br><span class="line">    &#125; = &#123;</span><br><span class="line">        type: <span class="string">'png'</span>,</span><br><span class="line">        quality: <span class="number">1</span></span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">            imageHeight,</span><br><span class="line">            imageWidth</span><br><span class="line">        &#125; = <span class="keyword">this</span>._drawImage();</span><br><span class="line">        <span class="keyword">const</span> base64 = <span class="keyword">this</span>.canvasElement.toDataURL(<span class="string">'image/'</span> + type, quality);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            base64,</span><br><span class="line">            imageHeight,</span><br><span class="line">            imageWidth</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用自定义元素了</span></span><br><span class="line">customElements.define(<span class="string">'simple-camera'</span>, SimpleCamera)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> camera = <span class="built_in">document</span>.querySelector(<span class="string">'simple-camera'</span>)</span><br><span class="line">    <span class="keyword">const</span> btnBlobPhoto = <span class="built_in">document</span>.querySelector(<span class="string">'#btnBlobPhoto'</span>)</span><br><span class="line">    <span class="keyword">const</span> btnBase64Photo = <span class="built_in">document</span>.querySelector(<span class="string">'#btnBase64Photo'</span>)</span><br><span class="line">    <span class="keyword">const</span> base64Img = <span class="built_in">document</span>.getElementById(<span class="string">'base64Img'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> camera.open(&#123;</span><br><span class="line">        video: &#123;</span><br><span class="line">            facingMode: <span class="string">'user'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'摄像头开启失败'</span>, err)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    btnPhoto.addEventListener(<span class="string">'click'</span>, <span class="keyword">async</span> event =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> photo = <span class="keyword">await</span> camera.takeBlobPhoto()</span><br><span class="line">        <span class="built_in">console</span>.log(photo)</span><br><span class="line">        base64Img.src = URL.createObjectURL(photo.blob);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    btnBase64Photo.addEventListener(<span class="string">'click'</span>, <span class="keyword">async</span> event =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> photo = camera.takeBase64Photo(&#123;</span><br><span class="line">            type: <span class="string">'jpeg'</span>,</span><br><span class="line">            quality: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(photo)</span><br><span class="line">        base64Img.src = photo.base64;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>javascript</category>
        <category>Web Component</category>
      </categories>
      <tags>
        <tag>Web Component</tag>
      </tags>
  </entry>
  <entry>
    <title>js中var/let/const的区别</title>
    <url>/2020/05/31/js%E4%B8%ADvar/let/const%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>三种变量声明很常见，就来说点不一样的  </p>
<ul>
<li>原来还有全局对象和顶层对象  </li>
<li>为什么我定义的变量和函数无法delete</li>
</ul>
</blockquote>
<a id="more"></a>

<p>刚接触js时，声明一个变量会用var或者function，共2种</p>
<ul>
<li>var声明的全局变量</li>
<li>var在函数范围内声明的局部变量</li>
<li>eval中声明的全局变量。</li>
</ul>
<p>在es6中，新增了let/const/import/class，共6种</p>
<hr>
<h2 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h2><p>浏览器环境中顶层对象是window，Node中是global对象</p>
<ul>
<li>ES5中，顶层对象的属性等价于全局变量</li>
<li>ES6中，var、function声明的全局变量<strong>属于</strong>顶层对象，其他4个则<strong>不属于</strong>顶层对象<br>,所以es6中的全局变量和顶层对象的属性分离。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.info(<span class="built_in">window</span>.b);  <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.info(<span class="built_in">window</span>.c);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.info(<span class="keyword">this</span>.len)</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// undefined,此时this为window</span></span><br><span class="line"><span class="keyword">let</span> Person = &#123;</span><br><span class="line">	len: <span class="number">5</span>,</span><br><span class="line">	say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		fn(); <span class="comment">// undefined 此时this为window</span></span><br><span class="line">		<span class="built_in">arguments</span>[<span class="number">0</span>](); <span class="comment">// undefined 此时调用fn方法，arguments对象里没有len属性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.say(fn);<span class="comment">// this为Person</span></span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>arguments.length表示传入函数的实参数量</li>
<li>函数本身的length属性代表的是函数定义时给出的参数个数</li>
</ul>
<hr>
<h2 id="变量删除"><a href="#变量删除" class="headerlink" title="变量删除"></a>变量删除</h2><ul>
<li>var全局声明的变量是<strong>无法删除</strong>的，configurable=false</li>
<li>var函数作用域内声明的变量是<strong>无法删除</strong>的，没有依赖的父对象</li>
<li>eval()会创建属性，configurable=true,所以可以删除</li>
</ul>
<p>同理，函数也是对象，声明的函数也会遵循var的方式，判断是否可以删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">window</span>, <span class="string">'a'</span>));      <span class="comment">// delete b =&gt; false</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">2</span>; <span class="comment">// delete b =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// delete aa =&gt; false</span></span><br><span class="line">(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bb</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">delete</span> bb; <span class="comment">// false</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>所以如果要删除已定义的变量，可以赋值覆盖掉它，或者是在局部作用域中创建，等待内存回收</p>
<p>垃圾回收有2大条件</p>
<ul>
<li>未被引用的对象会被自动回收</li>
<li>不可访问的对象会被自动回收，比如虽然2对象互相引用，但是外部不可访问也会被回收</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>33行实现react</title>
    <url>/2020/05/30/33%E8%A1%8C%E5%AE%9E%E7%8E%B0react/</url>
    <content><![CDATA[<blockquote>
<p>一种简易的类react架构的实现，了解react，<br>全文添加中文注释，方便理解</p>
</blockquote>
<a id="more"></a>

<ul>
<li>取得状态并返回虚拟dom</li>
<li>状态改变，返回新的虚拟dom</li>
<li>将虚拟dom渲染为真实dom</li>
<li>更新真实dom</li>
</ul>
<p>前置知识点</p>
<ul>
<li><a href="http://www.mithriljs.net/" target="_blank" rel="noopener">Mithril</a> 现代化的 JS 轻量框架,内置了路由和 XHR 工具<ul>
<li>m() 函数可以描述任何 HTML 结构</li>
<li>m.render(root, ‘’) 挂载</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 结构args =&gt; tag, attrs, classes</span></span><br><span class="line">    <span class="keyword">let</span> [attrs, [head, ...tail]] = [&#123;&#125;, args]</span><br><span class="line">    <span class="keyword">let</span> [tag, ...classes] = head.split(<span class="string">'.'</span>)</span><br><span class="line">    <span class="keyword">if</span> (tail.length &amp;&amp; !m.isRenderable(tail[<span class="number">0</span>])) [attrs, ...tail] = tail</span><br><span class="line">    <span class="comment">// 合并class</span></span><br><span class="line">    <span class="keyword">if</span> (attrs.class) classes = [...classes, ...attrs.class]</span><br><span class="line">    <span class="comment">// 把已经使用的attrs做浅拷贝，删除class的值</span></span><br><span class="line">    attrs = &#123;...attrs&#125;; <span class="keyword">delete</span> attrs.class</span><br><span class="line">    <span class="comment">// 创建子数组，递归地将嵌套项拍平到该数组中，并忽略空值</span></span><br><span class="line">    <span class="keyword">const</span> children = []</span><br><span class="line">    <span class="keyword">const</span> addChildren = <span class="function"><span class="params">v</span>=&gt;</span>v === <span class="literal">null</span>? <span class="literal">null</span> : <span class="built_in">Array</span>.isArray(v)? v.map(addChildren) : children.push(v)</span><br><span class="line">    addChildren(tail)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">__m</span>: <span class="literal">true</span>, <span class="attr">tag</span>: tag || <span class="string">'div'</span>, attrs, classes, children&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否可以渲染null,字符串，数字，虚拟节点，数组</span></span><br><span class="line">m.isRenderable = <span class="function"><span class="params">v</span> =&gt;</span>v === <span class="literal">null</span> || [<span class="string">'string'</span>, <span class="string">'number'</span>].includes(<span class="keyword">typeof</span> v) || v.__m || <span class="built_in">Array</span>.isArray(v)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收真实dom和虚拟dom</span></span><br><span class="line"><span class="comment">// 把所需的虚拟dom的属性和类更新到真实dom</span></span><br><span class="line">m.update = <span class="function">(<span class="params">el, v</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 如果是文本元素，需要设置数据</span></span><br><span class="line">    <span class="keyword">if</span> (!v.__m) <span class="keyword">return</span> el.data === <span class="string">`<span class="subst">$&#123;v&#125;</span>`</span> || (el.data = v)</span><br><span class="line">    <span class="comment">// 设置添加class</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> v.classes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!el.classList.contains(name)) el.classList.add(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> el.classList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!v.classes.includes(name)) el.classList.remove(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置添加attributes</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> <span class="built_in">Object</span>.keys(v.attrs))&#123;</span><br><span class="line">        <span class="keyword">if</span> (el[name] !== v.attrs[name]) el[name] = v.attrs[name]</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> &#123;name&#125; <span class="keyword">of</span> el.attributes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(v.attrs).includes(name) &amp;&amp; name !== <span class="string">'class'</span>) el.removeAttribute(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定一个虚拟DOM节点，生成一个真实dom节点，否则生成一个真实textNode值。</span></span><br><span class="line">m.makeEl = <span class="function"><span class="params">v</span>=&gt;</span>v.__m? <span class="built_in">document</span>.createElement(v.tag) : <span class="built_in">document</span>.createTextNode(v)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染，真实Dom和虚拟Dom</span></span><br><span class="line"><span class="comment">// a) 获取新老节点的子项</span></span><br><span class="line"><span class="comment">// b) 清除多余的旧节点</span></span><br><span class="line"><span class="comment">// c) 遍历每个新虚拟节点</span></span><br><span class="line"><span class="comment">//  1、通过index获取匹配的旧节点，如果没有则新增节点</span></span><br><span class="line"><span class="comment">//  2、如果没有匹配的旧元素，创建一个新元素加入父级</span></span><br><span class="line"><span class="comment">//  3、如果不匹配(标签名/节点)，就替换父级上的匹配项为新元素</span></span><br><span class="line"><span class="comment">//  4、更新节点的属性/类</span></span><br><span class="line"><span class="comment">//  5、递归子节点</span></span><br><span class="line"><span class="comment">// 高效追加到元素列表,耗时O(n)</span></span><br><span class="line">m.render = <span class="function">(<span class="params">parent, v</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> olds = parent.childNodes || []</span><br><span class="line">    <span class="keyword">const</span> news = v.children || [] </span><br><span class="line">    <span class="comment">// 遍历次数是新旧节点的属性长度之差</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> _ <span class="keyword">of</span> <span class="built_in">Array</span>(<span class="built_in">Math</span>.max(<span class="number">0</span>, olds.length - news.length))) &#123;</span><br><span class="line">        parent.removeChild(parent.lastChild)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// entries返回可枚举属性的键值对数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [i, child] <span class="keyword">of</span> news.entries())&#123; </span><br><span class="line">        <span class="keyword">let</span> el = olds[i] || m.makeEl(child) </span><br><span class="line">        <span class="comment">// 旧的属性的值存在</span></span><br><span class="line">        <span class="keyword">if</span> (!olds[i])&#123;</span><br><span class="line">            parent.appendChild(el)  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">const</span> mismatch = (el.tagName || <span class="string">''</span>) !== (child.tag || <span class="string">''</span>).toUpperCase()</span><br><span class="line">        <span class="keyword">if</span> (mismatch) &#123;</span><br><span class="line">            (el = m.makeEl(child)) &amp;&amp; parent.replaceChild(el, olds[i])</span><br><span class="line">        &#125;</span><br><span class="line">        m.update(el, child) </span><br><span class="line">        m.render(el, child) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原文：<a href="https://leontrolski.github.io/33-line-react.html" target="_blank" rel="noopener">https://leontrolski.github.io/33-line-react.html</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex getter</title>
    <url>/2020/05/24/vuex%20getter/</url>
    <content><![CDATA[<blockquote>
<p>Vuex的5大属性，state，getters，mutations，actions和modules<br>getters到底能做什么</p>
</blockquote>
<a id="more"></a>

<hr>
<p>写业务时没有太在意state/getter读值的区别，直到面试时遇到了这样一个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue中computed和vuex中getters有什么相同点</span><br></pre></td></tr></table></figure>
<p>leo：纳尼，这两者还有关联？<br>面试官：你真的用过vuex?<br>leo：emmm</p>
<hr>
<p>vuex嘛，大家都知道是中心化的状态管理模式，单向数据流，如图  </p>
<div style="width: 50%; margin: auto">

<p><img src="state-view-actions.png" alt="单向数据流"></div></p>
<p>state保存状态，getters获取state，mutations同步执行改变state，actions异步执行</p>
<h2 id="如何获取state状态"><a href="#如何获取state状态" class="headerlink" title="如何获取state状态"></a>如何获取state状态</h2><p>方案一</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.state.aaa</span><br><span class="line"><span class="keyword">this</span>.$store.getter.bbb</span><br></pre></td></tr></table></figure>
<p>方案二</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">'aaa'</span>]),</span><br><span class="line">    ...mapGetters([<span class="string">'bbb'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么提供了2种方法获取state，他们有什么区别呢"><a href="#为什么提供了2种方法获取state，他们有什么区别呢" class="headerlink" title="为什么提供了2种方法获取state，他们有什么区别呢"></a>为什么提供了2种方法获取state，他们有什么区别呢</h2><ul>
<li>state获取时直接返回</li>
<li>getter可以在获取state时，对state进行操作后返回</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">    getMyListGreaterThanNum(state, getters) &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123; <span class="comment">// 把属性变成函数属性</span></span><br><span class="line">        <span class="keyword">return</span> state.myList.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; num) </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$store.getters[<span class="string">"getMyListGreaterThanNum"</span>](<span class="number">1</span>)</span><br><span class="line"><span class="keyword">this</span>.$store.getters.getMyListGreaterThanNum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="computed和getters相同点"><a href="#computed和getters相同点" class="headerlink" title="computed和getters相同点"></a>computed和getters相同点</h2><ul>
<li>缓存，和computed一样，当依赖的state改变才会重新计算</li>
</ul>
<p>在getters中是属性不是函数,不能直接传参</p>
<h2 id="mapGetters-是什么"><a href="#mapGetters-是什么" class="headerlink" title="mapGetters 是什么"></a>mapGetters 是什么</h2><ul>
<li>mapGetters辅助函数，直接返回一个对象，仅仅是将 store 中的 getter 映射到局部计算属性</li>
</ul>
<p>每次调用都需要this.$store.getters.xxx，非常麻烦，可以用mapGetters语法糖直接合并入computed</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">'getMyListGreaterThanNum'</span>]),</span><br><span class="line">    ...mapGetters(<span class="string">"myStore2"</span>, [<span class="string">"getMyListGreaterThanNum"</span>]);<span class="comment">// 分模块</span></span><br><span class="line">    ...mapGetters(<span class="string">"myStore2"</span>, &#123;<span class="attr">getMyList</span>: <span class="string">"getMyListGreaterThanNum"</span>&#125;);<span class="comment">// 重命名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$storestore.getters[<span class="string">"myStore2/getMyListGreaterThanNum"</span>]</span><br></pre></td></tr></table></figure>

<h2 id="mapGetters源码实现"><a href="#mapGetters源码实现" class="headerlink" title="mapGetters源码实现"></a>mapGetters源码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reduce the code which written in Vue.js for getting the getters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>[namespace] - Module's namespace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object|Array&#125;</span> <span class="variable">getters</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mapGetters = normalizeNamespace(<span class="function"><span class="keyword">function</span> (<span class="params">namespace, getters</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!isValidMap(getters)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'[vuex] mapGetters: mapper parameter must be either an Array or an Object'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    normalizeMap(getters).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ref</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> key = ref.key;</span><br><span class="line">      <span class="keyword">var</span> val = ref.val;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The namespace has been mutated by normalizeNamespace</span></span><br><span class="line">      val = namespace + val;</span><br><span class="line">      res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (namespace &amp;&amp; !getModuleByNamespace(<span class="keyword">this</span>.$store, <span class="string">'mapGetters'</span>, namespace)) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(val <span class="keyword">in</span> <span class="keyword">this</span>.$store.getters)) &#123;</span><br><span class="line">          <span class="built_in">console</span>.error((<span class="string">"[vuex] unknown getter: "</span> + val));</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters[val]</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// mark vuex getter for devtools</span></span><br><span class="line">      res[key].vuex = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeNamespace</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">namespace, map</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> namespace !== <span class="string">'string'</span>) &#123;</span><br><span class="line">        map = namespace;</span><br><span class="line">        namespace = <span class="string">''</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namespace.charAt(namespace.length - <span class="number">1</span>) !== <span class="string">'/'</span>) &#123;</span><br><span class="line">        namespace += <span class="string">'/'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fn(namespace, map)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeMap</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidMap(map)) &#123;</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(map)</span><br><span class="line">      ? map.map(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123; <span class="keyword">return</span> (&#123; <span class="attr">key</span>: key, <span class="attr">val</span>: key &#125;); &#125;)</span><br><span class="line">      : <span class="built_in">Object</span>.keys(map).map(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123; <span class="keyword">return</span> (&#123; <span class="attr">key</span>: key, <span class="attr">val</span>: map[key] &#125;); &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>normalizeNamespace函数将传入的改成namespace/getters的分割样式，如果没有namespace，那么直接返回getters</li>
<li>normalizeMap函数将输入的getters对应成store的内部属性，可以使用对象来更改函数的名称</li>
<li>查找属性，找到返回this.$store.getters[val]</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vuex</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3预览</title>
    <url>/2020/05/17/vue3%E9%A2%84%E8%A7%88/</url>
    <content><![CDATA[<p>vue3 的api及语法有哪些改变</p>
<a id="more"></a>

<img src="/images/vue3预览/1.jpg" />
<img src="/images/vue3预览/2.jpg" />
<img src="/images/vue3预览/3.jpg" />
<img src="/images/vue3预览/4.jpg" />
<img src="/images/vue3预览/all.png" />





]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>reduce用法详解</title>
    <url>/2020/04/14/reduce%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<p>reduce()累加器，数组中的每个元素依次执行回调函数callback（初始值(或者上次回调函数的返回值)，当前元素值，当前索引，调用reduce的数组）<br>arr.reduce(callback, [initialValue])</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pre, cur, index);</span><br><span class="line">    <span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, sum); <span class="comment">// [1, 2, 3, 4] 10   初始值为1,循环3次</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pre, cur, index);</span><br><span class="line">    <span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr, sum); <span class="comment">// [1, 2, 3, 4] 10   初始值为0,循环4次</span></span><br></pre></td></tr></table></figure>

<p>求和或求积</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;<span class="comment">// 10</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> mul = arr.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x * y;<span class="comment">// 24</span></span><br><span class="line">&#125;, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>计算数组中每个元素出现的次数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Tiff'</span>, <span class="string">'Alice'</span>];</span><br><span class="line"><span class="keyword">var</span> nameNum = names.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (cur <span class="keyword">in</span> pre) &#123;</span><br><span class="line">		pre[cur]++</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pre[cur] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre  </span><br><span class="line">&#125;, &#123;&#125;) <span class="comment">// &#123; Alice: 2, Bob: 1, Tiff: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>对象属性求和</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">	&#123;<span class="attr">subject</span>: <span class="string">'math'</span>, <span class="attr">score</span>: <span class="number">10</span>&#125;,</span><br><span class="line">	&#123;<span class="attr">subject</span>: <span class="string">'chinese'</span>, <span class="attr">score</span>: <span class="number">10</span>&#125;,</span><br><span class="line">	&#123;<span class="attr">subject</span>: <span class="string">'english'</span>, <span class="attr">score</span>: <span class="number">10</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cur.score + pre</span><br><span class="line">&#125;, <span class="number">0</span>) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>数组去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!pre.includes(cur)) &#123;</span><br><span class="line">		<span class="keyword">return</span> pre.concat(cur)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> pre</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, [])  <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>数组对象去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">	&#123;<span class="attr">id</span>: <span class="number">0</span>, <span class="attr">name</span>: <span class="string">"小明"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">"小张"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">"小李"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">"小孙"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">"小周"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">"小陈"</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	obj[cur.id] ? <span class="string">''</span> : obj[cur.id] = <span class="literal">true</span> &amp;&amp; pre.push(cur);</span><br><span class="line">	<span class="keyword">return</span> pre</span><br><span class="line">&#125;, []) <span class="comment">// [ &#123;id: 0, name: “小明”&#125;, &#123;id: 1, name: “小张”&#125;,&#123;id: 2, name: “小李”&#125;,&#123;id: 3, name: “小孙”&#125;]</span></span><br></pre></td></tr></table></figure>

<p>数组拍平</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pre.concat(cur)  <span class="comment">// [0,1,2,3,4,5]</span></span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<p>数组多维拍平</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]]]</span><br><span class="line"><span class="keyword">var</span> newArr = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">		pre.concat(<span class="built_in">Array</span>.isArray(cur) ? newArr(cur) : cur)</span><br><span class="line">	&#125;, [])</span><br><span class="line">&#125; <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>React</category>
        <category>Reduce</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react useMemo&amp;useCallback</title>
    <url>/2020/04/01/react%20useMemo&amp;useCallback/</url>
    <content><![CDATA[<blockquote>
<p>useMemo和useCallback都会在组件第一次渲染的时候执行</p>
</blockquote>
<blockquote>
<p>之后会在其依赖的变量发生改变时再次执行</p>
</blockquote>
<blockquote>
<p>useMemo返回缓存的变量，useCallback返回缓存的函数</p>
</blockquote>
<p>多个state改变会重渲染多此，借助useMemo可以在指定state改变时才执行对应的方法</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expensive</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">改为</span><br><span class="line"><span class="keyword">const</span> expensive = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,[count])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>useCallback返回的是缓存的函数</p>
</blockquote>
<ul>
<li>将我们传递给它的函数fnB返回，并且将这个结果缓存；当依赖a变更时，会返回新的函数。</li>
<li>既然返回的是函数，我们无法很好的判断返回的函数是否变更，</li>
<li>所以我们可以借助ES6新增的数据类型Set来判断<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fnA = useCallback(fnB, [a])</span><br></pre></td></tr></table></figure>
如果存在父子组件，如果父更新，子也会更新，可以把useCallback返回的函数传给子props,这样就缓存不更新<br>等返回的函数更新后字才会更新</li>
</ul>
<p>所有依赖本地状态或props来创建函数，需要使用到缓存函数的地方，都是useCallback的应用场景</p>
<p>useEffect、useMemo、useCallback都是自带闭包的。也就是说，每一次组件的渲染，其都会捕获当前组件函数上下文中的状态(state, props)，所以每一次这三种hooks的执行，反映的也都是当前的状态，你无法使用它们来捕获上一次的状态。对于这种情况，我们应该使用ref来访问</p>
<p>类组件的shouldComponentUpdate和 PureComponent,为了减少重新 render 的次数，主要是减少父组件更新而子组件也更新的情况</p>
<p>React.memo是对标类组件PureComponent<br>子组件如果在 props 没有变化的情况下，就算父组件重新渲染了，子组件也不应该渲染<br>React.memo其实是一个高阶函数，传递一个组件进去，返回一个可以记忆的组件</p>
<p>如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myComponent(props) &#123;</span><br><span class="line">   &#x2F;* 使用 props 渲染 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--  prevProps !&#x3D; nextProps时返回false会重渲 --&gt;</span><br><span class="line">funtion areEqual(prevProps,nextProps)&#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">const MyComponent &#x3D; React.memo(myComponent,areEqual);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个组件重新重新渲染，一般三种情况：</p>
</blockquote>
<ul>
<li>要么是组件自己的状态改变</li>
<li>要么是父组件重新渲染，导致子组件重新渲染，但是父组件的 props 没有改版</li>
<li>要么是父组件重新渲染，导致子组件重新渲染，但是父组件传递的 props 改变</li>
</ul>
<blockquote>
<p>React 的性能优化方向主要是两个：</p>
</blockquote>
<ul>
<li>一个是减少重新 render 的次数(或者说减少不必要的渲染)，</li>
<li>另一个是减少计算的量</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
        <category>Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react-useEffect&amp;useReducer</title>
    <url>/2020/03/30/react-useEffect&amp;useReducer/</url>
    <content><![CDATA[<blockquote>
<p>use*** 格式定义的函数是react hooks的规范</p>
</blockquote>
<p>useEffect用于处理组件中的effect，通常用于请求数据，事件处理，订阅等相关操作</p>
<blockquote>
<p>最后return的【返回函数】可以作为状态切换的默认执行函数，执行下一个effect之前执行上一个effect【返回的函数】</p>
</blockquote>
<a id="more"></a>
<hr>
<ul>
<li><p>状态和状态更新函数来自与useState这个hooks，通过调用useState，来创建App组件的内部状态。初始状态是一个object，其中的hits为一个空数组</p>
</li>
<li><p>axios发起请求,使用useEffect来隔离副作用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> fetchData = <span class="keyword">async</span>()&#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> axios(<span class="string">'xxx'</span>);</span><br><span class="line">            setData(result.data);</span><br><span class="line">        &#125;</span><br><span class="line">        fetchData()</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">        &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">                &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">         &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>useEffect在组件mount时执行，但也会在组件更新时执行</p>
</blockquote>
</li>
<li><p>如果在useEffect中请求数据并setData会触发渲染,导致死循环<br>所以需要传递一个空数组作为参数，避免在更新时触发useEffect,只会在mount挂载时执行一次</p>
</li>
<li><p>第二参数用于监听指定变量的更新<br>如果参数中定义的变量更新了，则useEffect会再次执行</p>
</li>
<li><p>async函数会隐式返回promise，但是useEffect不返回内容，所以需要用方法包装async</p>
</li>
</ul>
<hr>
<blockquote>
<p>响应更新的例子，用户输入</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">    <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'redux'</span>);</span><br><span class="line">    <span class="keyword">const</span> [search, setSearch] = useState(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">const</span> [url, setUrl] = useState(<span class="string">'http://localhost/api/v1/search?query=redux'</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> fetchData = <span class="keyword">async</span>()=&gt;&#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> axios(<span class="string">'xxx?query='</span> + query);</span><br><span class="line">            setData(result.data);</span><br><span class="line">        &#125;</span><br><span class="line">        fetchData()</span><br><span class="line">    &#125;,[search])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> value=&#123;query&#125;</span><br><span class="line">                onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">            &lt;button type=<span class="string">"button"</span> onClick=&#123;() =&gt; setSearch(query)&#125;&gt;</span><br><span class="line">                Search</span><br><span class="line">            &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">                &lt;li key=&#123;item.objectID&#125;&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/</span>a&gt;</span><br><span class="line">                &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            ))&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/u</span>l&gt;</span><br><span class="line">        &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>query的任何一次变动都会请求后端，这样会带来比较大的访问压力。这个时候我们需要引入一个按钮，点击这个按钮再发起请求(query改为search)</p>
</li>
<li><p>每次点击按钮时，会把search的值设置为query，这个时候我们需要修改useEffect中的依赖项为search，这样每次点击按钮，search值变更，useEffect就会重新执行，避免不必要的变更</p>
</li>
<li><p>因为组件首先会在mount时获取数据。所以简单点，直接将的要请求的后端URL设置为search state的初始值</p>
</li>
<li><p>如果useEffect中出现其他外部变量也需要放入依赖数组中，所以btn依赖的query也提取到btn中，不转入useEffect</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'redux'</span>);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(</span><br><span class="line">    <span class="string">'http://localhost/api/v1/search?query=redux'</span>,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        value=&#123;query&#125;</span><br><span class="line">        onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"button"</span> onClick=&#123;() =&gt; setUrl(<span class="string">`http://localhost/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>)&#125;&gt;</span><br><span class="line">            Search</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li key=&#123;item.objectID&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/</span>a&gt;</span><br><span class="line">          &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>处理Loading和error</p>
</blockquote>
</li>
<li><p>在请求后端数据,展现loading的状态</p>
</li>
<li><p>不需要再loading变更时重新调用useEffect</p>
</li>
<li><p>处理错误,使用useState来创建一个新的state，然后在useEffect中特定的位置来更新这个state</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">    const [isLoading, setIsLoading] &#x3D; useState(false);</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        const fetchData &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">            setIsLoading(true);</span><br><span class="line">        </span><br><span class="line">            const result &#x3D; await axios(url);</span><br><span class="line">        </span><br><span class="line">            setData(result.data);</span><br><span class="line">            setIsLoading(false);</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        fetchData();</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &#123;isLoading ? (</span><br><span class="line">                &lt;div&gt;Loading ...&lt;&#x2F;div&gt;</span><br><span class="line">            ) : (</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                &#123;data.hits.map(item &#x3D;&gt; (</span><br><span class="line">                    &lt;li key&#x3D;&#123;item.objectID&#125;&gt;</span><br><span class="line">                    &lt;a href&#x3D;&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;&#x2F;li&gt;</span><br><span class="line">                ))&#125;</span><br><span class="line">                &lt;&#x2F;ul&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">        &lt;&#x2F;Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同名目录内有抽离自定义hooks组件的例子<br>使用useReducer整合逻辑</p>
</blockquote>
</li>
<li><p>使用了各种通过分离的state hooks来管理分散的：数据、状态，为了有关联的状态整合到一起，我们需要用到useReducer</p>
</li>
<li><p>useReducer 是一个轻量的redux，返回一个状态对象和一个可以改变状态对象的dispatch函数,dispatch函数接受action作为参数，action包含type和payload属性</p>
</li>
<li><p>useReducer将reducer函数和初始状态对象作为参数,即同时定义多个hooks</p>
</li>
<li><p>type属性告诉reducer需要应用哪个状态转换，并且reducer可以使用payload来创建新的状态</p>
</li>
<li><p>例子中的state是对象，导出时可以解构分离原有状态</p>
</li>
<li><p>取消数据请求,在请求还没有返回的时候卸载了组件会报错</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dataFetchReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'FETCH_INIT'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                isLoading: <span class="literal">true</span>,</span><br><span class="line">                isError: <span class="literal">false</span></span><br><span class="line">            &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">    isError: <span class="literal">false</span>,</span><br><span class="line">    data: initialData,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch(&#123; <span class="attr">type</span>: <span class="string">'FETCH_INIT'</span> &#125;);</span><br><span class="line">dispatch(&#123; <span class="attr">type</span>: <span class="string">'FETCH_SUCCESS'</span>, <span class="attr">payload</span>: result.data &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在没有hooks时，创建class组件，性能的优化通过immutable比较，</span><br><span class="line">1、在不相等的时候调用setState,</span><br><span class="line">2、在shouldComponentUpdate中判断前后的props和state，如果没有变化，则返回false来阻止更新</span><br><span class="line"></span><br><span class="line">在hooks出来后，无法通过判断前后状态来决定是否更新，每一次调用都会执行其内部的所有逻辑，可以发现每次改变都会触发父子组件渲染</span><br><span class="line">性能损耗通过useMemo 和useCallback解决</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>React</category>
        <category>Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>追踪用户关闭网页</title>
    <url>/2020/03/30/%E8%BF%BD%E8%B8%AA%E7%94%A8%E6%88%B7%E5%85%B3%E9%97%AD%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<blockquote>
<p>异步ajax、img标签上传数据、beacon API比较</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>1、异步ajax</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">'post'</span>, <span class="string">'/log'</span>, <span class="literal">true</span>);</span><br><span class="line">    xhr.setRequestHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">    xhr.send(<span class="string">'foo=bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unload'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    log();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">1</span>; m &lt; <span class="number">10000</span>; m++) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2、img标签上传数据<br>后缀img.jpg?c=xxxx</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reportData = <span class="function">(<span class="params">url, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">    <span class="keyword">const</span> params = [];</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        params.push(key+<span class="string">'='</span>+<span class="built_in">encodeURIComponent</span>(data[key]));</span><br><span class="line">    &#125;);</span><br><span class="line">    img.onload = <span class="function"><span class="params">()</span> =&gt;</span> img = <span class="literal">null</span>;</span><br><span class="line">    img.src = url+<span class="string">'?'</span>+params.join(<span class="string">'&amp;'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3、beacon API<br>70%不到的成功率</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.sendBeacon(<span class="string">'/log'</span>, <span class="string">'foo=bar'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<hr>
<p>beforeunload不能准确的判断刷新和关闭<br>navigator.sendBeacon不能捕捉直接关闭浏览器或任务管理器结束任务<br>还是后端监听心跳做比较好</p>
<hr>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>koa2简易实现</title>
    <url>/2020/03/27/koa2%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>核心功能洋葱模型</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Application http server 基本服务器框架</span><br><span class="line">Context 上下文 服务器框架基本数据结构的封装，解析响应http请求</span><br><span class="line">Middleware 中间件，洋葱模型机制</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>启动一个简单的http服务</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.end(<span class="string">'- -'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p>app.listen处理请求和端口监听</p>
<p>app.use处理中间件和请求</p>
<blockquote>
<p>myKoa</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware=<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    listen(...args)&#123;</span><br><span class="line">        <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.middleware);</span><br><span class="line">        server.listen(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    use(middleware)&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware = middleware</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line"><span class="comment">// const app = new Application()</span></span><br><span class="line"><span class="comment">// app.use((req,res)=&gt;&#123;res.end('- -')&#125;)</span></span><br><span class="line"><span class="comment">// app.listen(3000)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>构建Context</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此时app.use的回调函数是原生的req,res，而koa中是一个Context对象</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware=<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    listen(...args)&#123;</span><br><span class="line">        <span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 创建Context对象</span></span><br><span class="line">            <span class="keyword">const</span> ctx = <span class="keyword">new</span> Context(req,res);</span><br><span class="line">            <span class="comment">// 处理 app.use</span></span><br><span class="line">            <span class="keyword">this</span>.middleware(ctx);</span><br><span class="line">            <span class="comment">// 响应内容</span></span><br><span class="line">            ctx.res.end(ctx.body);</span><br><span class="line">        &#125;);</span><br><span class="line">        server.listen(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    use(middleware)&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware = middleware</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(req,res)&#123;</span><br><span class="line">        <span class="keyword">this</span>.req=req;</span><br><span class="line">        <span class="keyword">this</span>.res=res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line"><span class="comment">// const app = new Application()</span></span><br><span class="line"><span class="comment">// app.use(ctx=&gt;&#123;ctx.body('- -')&#125;)</span></span><br><span class="line"><span class="comment">// app.listen(3000)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>中间件</p>
</blockquote>
<p>手机中间件回调函数数组，并使用compose串联起来<br>对所有中间件函数通过compose函数来达到抽象效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middlewares);</span><br><span class="line"><span class="keyword">await</span> fn(ctx);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">await</span> compose(<span class="keyword">this</span>.middlwares,ctx);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.middlewares=[]</span><br><span class="line">    &#125;</span><br><span class="line">    listen(...args)&#123;</span><br><span class="line">        <span class="keyword">const</span> server = http.createServer(<span class="keyword">async</span> (req,res)=&gt;&#123;</span><br><span class="line">            <span class="keyword">const</span> ctx = <span class="keyword">new</span> Context(req,res);</span><br><span class="line">            <span class="comment">// 对中间件回调函数串联，洋葱模型</span></span><br><span class="line">            <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middlewares);</span><br><span class="line">            <span class="keyword">await</span> fn(ctx);</span><br><span class="line"></span><br><span class="line">            ctx.res.end(ctx.body);</span><br><span class="line">        &#125;);</span><br><span class="line">        server.listen(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    use(middleware)&#123;</span><br><span class="line">        <span class="keyword">this</span>.middlewares.push(middleware)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">    constructo(req,res)&#123;</span><br><span class="line">        <span class="keyword">this</span>.req=req;</span><br><span class="line">        <span class="keyword">this</span>.res=res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个中间件将会执行。后续每个会通过next执行<br>使用递归完成中间件的改造,实现洋葱模型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch=<span class="function">(<span class="params">i</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> middlewares[i](ctx,()=&gt;&#123;</span><br><span class="line">        dispatch(i+<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">dispatch(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch=<span class="function">(<span class="params">i</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> middleware = middlewares[i];</span><br><span class="line">    <span class="keyword">if</span>(i === middlewares.length)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> middleware(ctx,()=&gt;&#123;</span><br><span class="line">        dispatch(i+<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">dispatch(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>最后的compose</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middlewares</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">ctx</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> dispatch=<span class="function">(<span class="params">i</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> middleware = middlewares[i];</span><br><span class="line">            <span class="keyword">if</span>(i === middlewares.length)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> middleware(ctx,()=&gt;&#123;</span><br><span class="line">                dispatch(i+<span class="number">1</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// const app = new Application()</span></span><br><span class="line"><span class="comment">// app.use(async(ctx)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//    ctx.body('- -')</span></span><br><span class="line"><span class="comment">//    await next()</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// app.use(async (ctxnext)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//    ctx.body('- -')</span></span><br><span class="line"><span class="comment">//    await next()</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// app.use(async (ctx,next)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//    ctx.body='富士山</span></span><br><span class="line"><span class="comment">//    await next()</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// app.listen(3000)</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>label语法</title>
    <url>/2020/03/10/label%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>使用label语法在多层循环中精确返回指定位置</p>
</blockquote>
<a id="more"></a>
<p>主要用于break和continue的跳出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span> )&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        num++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// 95 循环在 i 为5，j 为5的时候跳出 j循环，但会继续执行 i 循环</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outPoint:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span> )&#123;</span><br><span class="line">                <span class="keyword">break</span> outPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        num++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// 55 循环在 i 为5，j 为5的时候跳出双循环，返回到outPoint层继续执行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i === <span class="number">5</span> &amp;&amp; j === <span class="number">5</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span> outermost;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// 95 continue outermost;语句的作用是跳出当前循环，并跳转到outermost（标签）下的for循环继续执行</span></span><br></pre></td></tr></table></figure>
<p>实际场景下应该不会出现三层及以上循环</p>
]]></content>
      <categories>
        <category>label</category>
      </categories>
      <tags>
        <tag>label</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Component</title>
    <url>/2020/02/28/Web%20Component/</url>
    <content><![CDATA[<blockquote>
<p>Web Component</p>
</blockquote>
<a id="more"></a>

<p><a href="https://segmentfault.com/a/1190000012440318" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012440318</a></p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>Web Component</category>
      </categories>
      <tags>
        <tag>Web Component</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtual Dom</title>
    <url>/2020/02/28/Virtual%20Dom/</url>
    <content><![CDATA[<blockquote>
<p>什么是Virtual Dom</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.jianshu.com/p/a036eaa2263a" target="_blank" rel="noopener">https://www.jianshu.com/p/a036eaa2263a</a><br><a href="https://www.jianshu.com/p/b189b2949b33" target="_blank" rel="noopener">https://www.jianshu.com/p/b189b2949b33</a></p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>Virtual Dom</category>
      </categories>
      <tags>
        <tag>Virtual Dom</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组拍平 扁平化的方式</title>
    <url>/2020/02/28/js%E6%95%B0%E7%BB%84%E6%8B%8D%E5%B9%B3%20%E6%89%81%E5%B9%B3%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>六种方式 拍平数组 扁平化数组</p>
</blockquote>
<a id="more"></a>
<p><code>var arr = [1,2,[3,4,5,[6,7,8],9],10,[11,12]];</code></p>
<blockquote>
<p>递归实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">let</span> arr1 = [];</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">            arr1 = arr1.concat(fn(val))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr1.push(val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arr1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>reduce实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev,cur</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prev.concat(<span class="built_in">Array</span>.isArray(cur)?fn(cur):cur)</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>flat</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.flat(<span class="literal">Infinity</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>扩展运算符</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr1 = [];</span><br><span class="line">    <span class="keyword">let</span> bStop = <span class="literal">true</span>;</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(val))&#123;</span><br><span class="line">            arr1.push(...val);</span><br><span class="line">            bStop = <span class="literal">false</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr1.push(val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(bStop)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(arr1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>toString</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = arr.toString().split(<span class="string">','</span>).map(<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(val)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>apply</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item)))&#123;</span><br><span class="line">           arr =  [].concat.apply([],arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>curl</title>
    <url>/2020/02/28/curl/</url>
    <content><![CDATA[<blockquote>
<p>curl使用指南<br><a href="https://www.jianshu.com/p/fc0eb6c60816" target="_blank" rel="noopener">https://www.jianshu.com/p/fc0eb6c60816</a></p>
</blockquote>
<a id="more"></a>
<p>curl 的用法指南 阮一峰<br><a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a><br>学习笔记之 curl 命令用法详解<br><a href="https://www.cnblogs.com/doseoer/p/7044344.html" target="_blank" rel="noopener">https://www.cnblogs.com/doseoer/p/7044344.html</a></p>
]]></content>
      <categories>
        <category>http请求</category>
      </categories>
      <tags>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2020/02/27/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>markdown语法</p>
</blockquote>
<a id="more"></a>

<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># h1 代表标题级数，最多6级标题</span><br></pre></td></tr></table></figure>
<h1 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h1><p>末尾加2个空格表示换行</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 无序列表</span><br><span class="line">    +次级</span><br><span class="line">    -次级</span><br><span class="line">    次级</span><br><span class="line">最后空行</span><br></pre></td></tr></table></figure>
<ul>
<li>列表<br>  +次级<br>  -次级<br>  次级</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.有序列表</span><br><span class="line">    1.次级</span><br><span class="line">    2.次级</span><br><span class="line">2.有序列表</span><br></pre></td></tr></table></figure>
<p>1.有序列表<br>    1.次级<br>    2.次级<br>2.有序列表</p>
<h1 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 一级引用</span><br><span class="line">&gt;&gt; 二级引用</span><br><span class="line">&gt;&gt;&gt; 三级引用</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一级引用</p>
<blockquote>
<p>二级引用</p>
<blockquote>
<p>三级引用</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<hr>
<h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[百度](https:&#x2F;&#x2F;www.baidu.com)</span><br></pre></td></tr></table></figure>
<p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![百度](https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;bd_logo1.png?where&#x3D;super)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.baidu.com/img/bd_logo1.png?where=super" alt="百度"></p>
<h1 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h1><p><code>代码框</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'123'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体*          _斜体_</span><br><span class="line">**加粗**        __加粗__</span><br><span class="line">***斜体加粗***  ___斜体加粗___</span><br></pre></td></tr></table></figure>
<p><em>斜体</em> <em>斜体</em><br><strong>加粗</strong> <strong>加粗</strong><br><strong><em>斜体加粗</em></strong> <strong><em>斜体加粗</em></strong></p>
<h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><p><code>~~待删除~~</code><br><del>待删除</del></p>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p><code>默认左对齐(:-)，右对齐(-:)，居中对齐(:-:)</code></p>
<table>
<thead>
<tr>
<th align="center">head</th>
<th align="left">head</th>
<th align="right">head</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">2</td>
<td align="right">3</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="right">head</th>
<th align="center">head</th>
<th>head</th>
</tr>
</thead>
<tbody><tr>
<td align="right">1</td>
<td align="center">2</td>
<td>3</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>head</th>
<th align="right">head</th>
<th align="center">head</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="right">2</td>
<td align="center">3</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>模板语法</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>hello hexo,你好 hexo</title>
    <url>/2020/02/22/hello-hexo/</url>
    <content><![CDATA[<blockquote>
<p>新建文章、创建标签和分类、阅读全文、搜索功能<br>next主题的使用方法</p>
</blockquote>
<a id="more"></a>
<h1 id="next主题的使用方法"><a href="#next主题的使用方法" class="headerlink" title="next主题的使用方法"></a>next主题的使用方法</h1><!-- 
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&auto=0&id=1386946644&height=66"></iframe> -->


<p>Hexo<br><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a><br>NexT<br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a><br>Hexo框架下用NexT(v7.0+)主题美化博客<br><a href="https://blog.csdn.net/weixin_39345384/article/details/80785373" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39345384/article/details/80785373</a><br>HEXO-NexT-V7-Gemini主题优化篇<br><a href="https://yangyang188.coding.me/archives/3575fa23/" target="_blank" rel="noopener">https://yangyang188.coding.me/archives/3575fa23/</a></p>
<!-- 复制粘贴工程师小程序
https://tj-xiajiahao.github.io/
git document
http://iissnan.com/progit/
主页
https://gitby-leo.github.io/ -->

<!-- ps导出精度会影响图片色彩，最好是导出最佳精度后压缩
NIM 调试扩展 nodejs
安装vscode .swig扩展支持
Parcel
MobX
https://cn.mobx.js.org/
web-cell
https://web-cell.dev/
😆 -->

<hr>
<h2 id="hexo的特点"><a href="#hexo的特点" class="headerlink" title="hexo的特点"></a>hexo的特点</h2><p>pjax：依赖jq的pushState+ajax库<br>无切换、高性能加载显示html，又能跟普通url兼容，而ajax引入hash会影响seo</p>
<hr>
<h3 id="启用数据目录"><a href="#启用数据目录" class="headerlink" title="启用数据目录"></a>启用数据目录</h3><p>在 hexo/source/_data 目录下新建 next.yml 文件，把 Next 的主题配置文件 next/_config.yml 内容全部复制到 next.yml，然后修改override为true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建额外目录文件：</span><br><span class="line">1、custom_file_path中增加一个路径，</span><br><span class="line">2、next&#x2F;scripts&#x2F;events&#x2F;lib&#x2F;injects-point.js中增加对应变量</span><br><span class="line">3、引用文件&#123;&#123;- next_inject(&#39;xxx&#39;) &#125;&#125;</span><br><span class="line">4、新建文件</span><br></pre></td></tr></table></figure>

<h2 id="定义-CSS-路径"><a href="#定义-CSS-路径" class="headerlink" title="定义 CSS 路径"></a>定义 CSS 路径</h2><p>Next 7.2 版本后取消了 \themes\next\source\css_custom\custom.styl，怪不得这个路径一直找不到，需要在配置文件里重新定义。此处的配置项基于数据目录功能，所以必须完成前面的「启用数据目录」才能生效。<br>next.yml中的custom_file_path，解注style并新建对应文件</p>
<h2 id="配置激活-失活时的网页标题"><a href="#配置激活-失活时的网页标题" class="headerlink" title="配置激活/失活时的网页标题"></a>配置激活/失活时的网页标题</h2><p>custom-script<br>yml配置文件里新建title_trick {enable,leave,enter}</p>
<h2 id="关联文章"><a href="#关联文章" class="headerlink" title="关联文章"></a>关联文章</h2><p>hexo-related-popular-posts 报错- -<br>lib/list-json.js中 要加try catch : ret.path  = pathFn.join(config.root , list.path)</p>
<h2 id="列表页添加可配置图片"><a href="#列表页添加可配置图片" class="headerlink" title="列表页添加可配置图片"></a>列表页添加可配置图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layout&#x2F;_macro&#x2F;post.swig中添加2处代码</span><br><span class="line">&lt;!--noindex--&gt;</span><br><span class="line">&#123;% if post.descriptionImage %&#125;</span><br><span class="line">  &lt;div class&#x3D;&quot;out-img-topic-descriptionImage&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&#123;&#123; post.descriptionImage &#125;&#125; class&#x3D;&quot;img-topic-descriptionImage&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">每个文章页头部添加需要显示的图片路径</span><br><span class="line">descriptionImage: &#39;&#39;</span><br><span class="line">&lt;!--&#x2F;noindex--&gt;</span><br></pre></td></tr></table></figure>
<h2 id="背景动态图片"><a href="#背景动态图片" class="headerlink" title="背景动态图片"></a>背景动态图片</h2><p>jquery-backstretch<br>可以放到bodyEnd中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;jquery-backstretch&#x2F;2.0.4&#x2F;jquery.backstretch.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  $(&quot;body&quot;).backstretch(&quot;https:&#x2F;&#x2F;背景图.jpg&quot;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="rating评分"><a href="#rating评分" class="headerlink" title="rating评分"></a>rating评分</h2><p>注册后填写网站的id</p>
<p>1) 可以配置评分方式，侧栏 &gt; Rating &gt; Setting，建议用 IP address 或 Device (cookie)，免登录，毕竟 Socials 里面的选项几乎都被墙，不适合国内网络环境。<br>2）建议在侧栏 &gt; Site &gt; Setting 中勾选 Private 选项，这样只能域名下使用</p>
<hr>
<h2 id="看板娘-桌宠"><a href="#看板娘-桌宠" class="headerlink" title="看板娘/桌宠"></a>看板娘/桌宠</h2><p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</a><br><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">https://github.com/xiazeyu/live2d-widget-models</a><br>npm install –save hexo-helper-live2d</p>
<p><del>/themes/next/layout/_layout.swig</del><br><del>body里添加{live2d()}</del><br>3.0不需要包含live2d(),只需安装依赖,models放入node_models内和站点文件配置live2d:</p>
<p>高定版本（高级定制<br><a href="https://github.com/stevenjoezhang/live2d-widget" target="_blank" rel="noopener">https://github.com/stevenjoezhang/live2d-widget</a><br>下载后放到目录/source/live2d-widget下，和_post同级<br>替换autoload.js中的live2d_path值和本地目录名称live2d-widget一致</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_layout.swig</span><br><span class="line">线上</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;stevenjoezhang&#x2F;live2d-widget@latest&#x2F;autoload.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">本地</span><br><span class="line">&lt;script src&#x3D;&quot;&#x2F;live2d-widget&#x2F;autoload.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p>首行缩进：空两格<br>&#160; &#160; &#160; &#160;开头<br><span style="background-color:#eee">字体高亮</span><br><code>字体高亮</code></p>

<table>
   <tr>
      <td colspan="6"><b>表格</b></td>
   </tr>
   <tr>
      <td>class</td><td>interface</td><td>byte</td><td>short</td><td>int</td><td>long</td>
   </tr>
   <tr>
      <td>class</td><td>interface</td><td>byte</td><td>short</td><td>int</td><td>long</td>
   </tr>
</table>



<hr>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图片根路径默认是source&#x2F;images</span><br><span class="line">![](&#x2F;images&#x2F;avatar.jpg)</span><br><span class="line">&#123;% img &#x2F;images&#x2F;avatar.jpg &quot;图片&quot; %&#125;</span><br><span class="line"></span><br><span class="line">fancybox放大预览，安装依赖后在配置页打开</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fancybox3 source&#x2F;lib&#x2F;fancybox</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;images&#x2F;avatar.jpg&quot; title&#x3D;&quot;放大预览&quot; alt&#x3D;&quot;放大预览&quot;&#x2F;&gt;</span><br><span class="line">&#123;% img &#x2F;images&#x2F;vi-vim-cheat-sheet.gif 600 600 &quot;点击查看大图:vi&#x2F;vim-cheat-sheet&quot; %&#125;</span><br><span class="line"></span><br><span class="line">themes&#x2F;next&#x2F;js&#x2F;utils内添加拦截，实现imageHref和imageTitle</span><br><span class="line">if ($image.hasClass(&#39;nofancybox&#39;)) &#123;</span><br><span class="line">  var imageHref &#x3D; $image.attr(&#39;href&#39;) </span><br><span class="line">  if(imageHref)&#123;</span><br><span class="line">    var imageWrapLink &#x3D; $image.wrap(&#96;&lt;a href&#x3D;$&#123;imageHref&#125; target&#x3D;&quot;_blank&quot;&gt;&lt;&#x2F;a&gt;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">  var imageTitle &#x3D; $image.attr(&#39;title&#39;) || $image.attr(&#39;alt&#39;);</span><br><span class="line">  if (imageTitle) &#123;</span><br><span class="line">    $image.after(&#96;&lt;p class&#x3D;&quot;image-caption&quot;&gt;$&#123;imageTitle&#125;&lt;&#x2F;p&gt;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;images&#x2F;avatar.jpg&quot; title&#x3D;&quot;不需要放大预览&quot; alt&#x3D;&quot;不需要放大预览&quot; class&#x3D;&quot;nofancybox&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<div style="display:flex;">
  <div style="flex:1">
    <img src="/images/avatar.jpg" title="放大预览" alt="放大预览"/>
  </div>
  <div style="flex:1">
    <img src="/images/avatar.jpg" title="不需要放大预览" alt="不需要放大预览" class="nofancybox"/>
  </div>
  <div style="flex:1">
    <img src="/images/avatar.jpg" title="跳转链接" alt="跳转链接" class="nofancybox" href="https://www.baidu.com" />
  </div>
</div>

<hr>
<h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br><span class="line"></span><br><span class="line">.md中top:true 或者true: 2控制多篇顺序</span><br><span class="line"></span><br><span class="line">添加样式themes&#x2F;hexo-theme-next&#x2F;layout&#x2F;_macr中&lt;div class&#x3D;&quot;post-meta&quot;&gt;里</span><br><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="随机副标题文案"><a href="#随机副标题文案" class="headerlink" title="随机副标题文案"></a>随机副标题文案</h2><p>站点_config.yml中：subtitle用-添加文案<br>/next/layout/_partials/header/brand.swig分割,数组随机显示</p>
<hr>
<h2 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h2><hr>
<h2 id="live2d"><a href="#live2d" class="headerlink" title="live2d"></a>live2d</h2><hr>
<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>如果没指定<code>[layout]</code>就使用<code>default_layout</code>中的默认模板</p>
<p>hexo new 文章名     // 简写新建<br>hexo new “文章名 1”  // 空格需要用引号<br>hexo new post 文章名 // 用post模板新建文章</p>
<p>npm install –save hexo-generator-index hexo-generator-archive hexo-generator-tag</p>
<hr>
<h2 id="个性化页面"><a href="#个性化页面" class="headerlink" title="个性化页面"></a>个性化页面</h2><p>站点_config.yml中skip_render配置过滤source下的指定目录或文件</p>
<hr>
<h2 id="创建标签和分类"><a href="#创建标签和分类" class="headerlink" title="创建标签和分类"></a>创建标签和分类</h2><p>hexo new page tags</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在tags&#x2F;index.md中加入</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<p>hexo new page categories</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories&#x2F;index.md中加入</span><br><span class="line">tags: &quot;categories&quot;</span><br></pre></td></tr></table></figure>

<p>文章页加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories: </span><br><span class="line">- Axx</span><br><span class="line">tags:</span><br><span class="line">- Bxx</span><br></pre></td></tr></table></figure>

<p>可以在scaffolds/post.md模板中加入categories:和tags:<br>每次hexo new 文章名时会自动包含分类和标签</p>
<hr>
<h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h2><p>npm install hexo-symbols-count-time –save</p>
<hr>
<h2 id="阅读全文"><a href="#阅读全文" class="headerlink" title="阅读全文"></a>阅读全文</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、md中手动&lt;!-- more --&gt;</span><br><span class="line">2、md中头部front-matter中使用description</span><br><span class="line">3、auto_excerpt功能在新版中弃用，换成npm包</span><br><span class="line">npm install hexo-excerpt --save</span><br><span class="line">主题_config.yml中&#96;添加&#96;:</span><br><span class="line">excerpt:</span><br><span class="line">  depth: 1</span><br><span class="line">  excerpt_excludes: []</span><br><span class="line">  more_excludes: []</span><br><span class="line">  hideWholePostExcerpts: false</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>引用algolia search:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、npm install --save hexo-algolia</span><br><span class="line">2、站点_config.yml中</span><br><span class="line">algolia:</span><br><span class="line">    applicationID: &#39;applicationID&#39;</span><br><span class="line">    indexName: &#39;indexName&#39;</span><br><span class="line">    chunkSize: 5000</span><br><span class="line"></span><br><span class="line">3、git bash中：</span><br><span class="line">$ export HEXO_ALGOLIA_INDEXING_KEY&#x3D;your Search key</span><br><span class="line">$ hexo algolia</span><br><span class="line">4、主题_config.yml中:</span><br><span class="line">algolia_search:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure>
<p>引用local search:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、npm install hexo-generator-searchdb --save</span><br><span class="line">2、站点_config.yml中</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line">4、主题_config.yml中:</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">5、hexo generate生成search.xml</span><br><span class="line">6、hexo server查看效果</span><br></pre></td></tr></table></figure>

<h2 id="hexo-admin后台管理"><a href="#hexo-admin后台管理" class="headerlink" title="hexo-admin后台管理"></a>hexo-admin后台管理</h2><p><code>DeprecationWarning: fs.SyncWriteStream is deprecated.</code>报错是因为node8.0+移除了方法，某插件依赖了这个方法<br>通过hexo –debug找到<br>在hexo-admin的依赖中找到hexo-fs/lib/fs.js并注释下面这行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.SyncWriteStream = fs.SyncWriteStream;</span><br></pre></td></tr></table></figure>

<!-- 发布配置局部信息
git config user.name xxx -->
]]></content>
      <categories>
        <category>hexo教程</category>
        <category>hexo入门</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World 欢迎来到hexo</title>
    <url>/2020/02/21/hello-world/</url>
    <content><![CDATA[<blockquote>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
</blockquote>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
