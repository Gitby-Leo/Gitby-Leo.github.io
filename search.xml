<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【23种设计模式】13代理模式</title>
    <url>/2020/08/09/%E3%80%9023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%9113%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>描述：为其他对象提供一种代理，以访问这个对象<br>优点：分为静态代理和动态代理<br>缺点：每个对象都需要对应一个代理类，原对象改变时需要代理对象也需要改变，增加函数处理时间  </p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>静态代理</p>
</blockquote>
<p>特点：被代理对象和代理对象，需要实现相同接口或者继承相同的父类</p>
<p>优点：不改变原对象，通过代理对象扩展原对象的功能</p>
<blockquote>
<p>动态代理</p>
</blockquote>
<p>特点：代理对象不需要接口，但目标对象要实现接口，动态地在内存中构建代理对象</p>
<p>优点：代理对象不需要实现接口</p>
<p>应用：远程代理，虚拟代理，保护代理，智能代理</p>
<hr>
<pre class="mermaid">classDiagram
  class Subject{
    <<interface>>
    doOperation() void
  }
  class RealSubject{
    +doOperation()
  }
  class MyProxy{
    -target:Subject
    constructor(realSubject : Subject)
    +doOperation()
  }
  Subject <|.. RealSubject :实现
  Subject <|.. MyProxy:实现
  RealSubject ..o MyProxy</pre>

<ul>
<li>接口类，需要实现一个方法</li>
<li>真实对象类，实现了这个方法</li>
<li>代理类，实例时缓存真实对象的类的实例，通过代理类调用真实对象的方法</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态代理</span></span><br><span class="line"><span class="keyword">interface</span> Subject &#123;</span><br><span class="line">    doOperation() : <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> RealSubject <span class="keyword">implements</span> Subject &#123;</span><br><span class="line">    <span class="keyword">public</span> doOperation() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我是RealSubject类，正在执行'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> MyProxy <span class="keyword">implements</span> Subject &#123;</span><br><span class="line">    <span class="keyword">private</span> target : Subject;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">realSubject : Subject</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.target = realSubject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> doOperation() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我是代理类'</span>);</span><br><span class="line">        <span class="keyword">this</span>.target.doOperation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> realSubject : Subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"><span class="keyword">const</span> myProxy : Subject = <span class="keyword">new</span> MyProxy(realSubject);</span><br><span class="line">myProxy.doOperation();</span><br></pre></td></tr></table></figure>

<ul>
<li>接口类，需要实现一个方法</li>
<li>真实对象类，实现了这个方法</li>
<li>代理类工厂，实例时缓存真实对象的类的实例，通过代理类的系统，也通过代理类调用真实对象的方法，</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态代理</span></span><br><span class="line"><span class="keyword">interface</span> Subject &#123;</span><br><span class="line">    doOperation() : <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> RealSubject <span class="keyword">implements</span> Subject &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> doOperation() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我是RealSubject类，正在执行'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ProxyFactory &#123;</span><br><span class="line">    <span class="keyword">private</span> target : <span class="built_in">any</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">target : <span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> getProxyInstance() : <span class="built_in">any</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Proxy(<span class="keyword">this</span>.target, &#123;</span><br><span class="line">            <span class="keyword">get</span>: <span class="function">(<span class="params">target, propKey</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 做的一些拦截处理</span></span><br><span class="line">                <span class="keyword">return</span> target[propKey];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target : Subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"><span class="keyword">const</span> proxyInstance : Subject = &lt;Subject&gt;<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">proxyInstance.doOperation();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【23种设计模式】12享元模式</title>
    <url>/2020/08/08/%E3%80%9023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%9112%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>描述：蝇量模式，共享对象支持大量的细粒度对象，内/外部状态，共享/非共享<br>优点：减少对象创建，降低内存<br>缺点：外部状态不随内部改变，提高复杂性  </p>
</blockquote>
<a id="more"></a>

<p>应用：缓冲池，连接池，相似对象</p>
<hr>
<pre class="mermaid">classDiagram
  class Flyweight {
    <<abstract>>
    +doOperation(extrinsicState  string)* void
  }
  class ConcreteFlyweight{
    -intrinsicState : string
    constructor(intrinsicState : string)
    +doOperation(extrinsicState : string)  void
  }
  class flyweightObject{
    <<interface>>
    [key : string] : Flyweight
  }
  class FlyweightFactory {
    -flyweights : flyweightObject
    constructor()
    +getFlyweight(intrinsicState : string)  Flyweight
  }
  Flyweight <|-- ConcreteFlyweight:继承
  flyweightObject --o FlyweightFactory :聚合
  Flyweight --o FlyweightFactory :聚合</pre>

<ul>
<li>抽象类，定义对象的内部，外部状态的接口<ul>
<li>产品类的具体实现，实现其方法</li>
</ul>
</li>
<li>享元工厂，返回具体实现的产品类</li>
<li>实例话一个工厂，通过工厂获取抽象类的实现，并缓存这些实例，调用实例的方法，即类的公有方法</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Flyweight &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> doOperation(extrinsicState : <span class="built_in">string</span>) : <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ConcreteFlyweight <span class="keyword">extends</span> Flyweight &#123;</span><br><span class="line">    <span class="keyword">private</span> intrinsicState : <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">intrinsicState : <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.intrinsicState = intrinsicState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> doOperation(extrinsicState : <span class="built_in">string</span>) : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`这是具体享元角色，内部状态为<span class="subst">$&#123;<span class="keyword">this</span>.intrinsicState&#125;</span>,外部状态为<span class="subst">$&#123;extrinsicState&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> flyweightObject &#123;</span><br><span class="line">    [key : <span class="built_in">string</span>] : Flyweight</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> FlyweightFactory &#123;</span><br><span class="line">    <span class="keyword">private</span> flyweights : flyweightObject;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.flyweights = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> getFlyweight(intrinsicState : <span class="built_in">string</span>) : Flyweight &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.flyweights[intrinsicState]) &#123;</span><br><span class="line">            <span class="keyword">const</span> flyweight : Flyweight = <span class="keyword">new</span> ConcreteFlyweight(intrinsicState);</span><br><span class="line">            <span class="keyword">this</span>.flyweights[intrinsicState] = flyweight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.flyweights[intrinsicState];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> factory : FlyweightFactory = <span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">    <span class="keyword">const</span> flyweight1 : Flyweight = factory.getFlyweight(<span class="string">"aa"</span>);</span><br><span class="line">    <span class="keyword">const</span> flyweight2 : Flyweight = factory.getFlyweight(<span class="string">"aa"</span>);</span><br><span class="line">    flyweight1.doOperation(<span class="string">'x'</span>);</span><br><span class="line">    flyweight2.doOperation(<span class="string">'y'</span>);</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【23种设计模式】11外观模式</title>
    <url>/2020/08/07/%E3%80%9023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%9111%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>描述：用统一的接口访问一个系统<br>优点：解耦，复杂接口变得方便可用，内部可维护，迪米特法则对内封装对外暴露<br>缺点：不开闭，修改子类需要也修改外观类  </p>
</blockquote>
<a id="more"></a>

<p>应用：封装子类，独立出子类，维护项目时，对部分功能封装为新的类，提高复用性</p>
<hr>
<pre class="mermaid">classDiagram
  class SubSystem{
    +doOperationA()  void
  }
  class Facade{
    -subSystem : SubSystem
    constructor()
    +doOperation()  void
  }
  SubSystem --o Facade</pre>

<ul>
<li>子类<ul>
<li>外观类访问子类的功能</li>
<li>并暴露子类的接口</li>
</ul>
</li>
<li>通过实例化这个外观类，可以调用子类的方法</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> SubSystemA &#123;</span><br><span class="line">    <span class="keyword">public</span> doOperationA() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'子系统A的举动'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> SubSystemB &#123;</span><br><span class="line">    <span class="keyword">public</span> doOperationB() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'子系统B的举动'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Facade &#123;</span><br><span class="line">    <span class="keyword">private</span> subSystemA : SubSystemA;</span><br><span class="line">    <span class="keyword">private</span> subSystemB : SubSystemB;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subSystemA = <span class="keyword">new</span> SubSystemA();</span><br><span class="line">        <span class="keyword">this</span>.subSystemB = <span class="keyword">new</span> SubSystemB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> doOperation() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.subSystemA.doOperationA();</span><br><span class="line">        <span class="keyword">this</span>.subSystemB.doOperationB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> facade : Facade = <span class="keyword">new</span> Facade();</span><br><span class="line">facade.doOperation();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【23种设计模式】10组合模式</title>
    <url>/2020/08/07/%E3%80%9023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%9110%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>描述：部分-整体模式，将对象组合成树形结构，单个对象和组合对象使用上一致<br>优点：调用简单，部分的属性和整体的属性一致，可扩展，易于查找父节点<br>缺点：抽象的节点需保持近似或一样的属性和方法  </p>
</blockquote>
<a id="more"></a>

<p>应用：遍历组织结构、处理树形结构，比如树形菜单、文件夹管理，组合即树形</p>
<hr>
<pre class="mermaid">classDiagram
  class Component {
    <<abstract>>
    #name : string
    constructor(name : string)
    +doOperation()* void
    +add(component : Component)  void
    +remove(component : Component)  void
    +getChildren() Array<Component>
  }
  class Composite{
    -componentList : any;
    constructor(name : string)
    +doOperation()* void
    +add(component : Component)  void
    +remove(component : Component)  void
    +getChildren() Array<Component>
  }
  class Leaf{
    constructor(name : string)
    +doOperation()* void
  }
  Component <|-- Composite : 继承
  Composite o--  Component: 集合
  Component <|-- Leaf : 叶子继承</pre>

<ul>
<li>抽象构建组件，默认属性和方法<ul>
<li>树枝节点实现类<ul>
<li>区别在于多了存储getChildren和管理add/remove子组件</li>
</ul>
</li>
<li>叶子节点实现类</li>
</ul>
</li>
<li>实例化树枝节点和叶子节点<ul>
<li>叶子节点可添加入树枝节点中</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Component &#123;</span><br><span class="line">    <span class="keyword">protected</span> name : <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name : <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> doOperation() : <span class="built_in">void</span>;</span><br><span class="line">    <span class="keyword">public</span> add(component : Component) : <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> remove(component : Component) : <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> getChildren() : <span class="built_in">Array</span>&lt;Component&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Composite <span class="keyword">extends</span> Component &#123;</span><br><span class="line">    <span class="comment">// 构件容器</span></span><br><span class="line">    <span class="keyword">private</span> componentList : <span class="built_in">any</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name : <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.componentList = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> doOperation() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`这是容器<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>，处理一些逻辑业务！`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> add(component : Component) : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.componentList.push(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> remove(component : Component) : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> componentIndex = <span class="keyword">this</span>.componentList.findIndex(<span class="function">(<span class="params">value : Component, index : <span class="built_in">Number</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value == component;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.componentList.splice(componentIndex, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> getChildren() : <span class="built_in">Array</span>&lt;Component&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.componentList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Leaf <span class="keyword">extends</span> Component &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name : <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> doOperation() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`这是叶子节点<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>，处理一些逻辑业务！`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root : Component  = <span class="keyword">new</span> Composite(<span class="string">'root'</span>);</span><br><span class="line">    <span class="keyword">const</span> node1 : Component = <span class="keyword">new</span> Leaf(<span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">const</span> node2 : Component = <span class="keyword">new</span> Composite(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">const</span> node3 : Component = <span class="keyword">new</span> Leaf(<span class="string">'3'</span>);</span><br><span class="line">    root.add(node1);</span><br><span class="line">    root.add(node2);</span><br><span class="line">    root.add(node3);</span><br><span class="line">    <span class="keyword">const</span> node2_1 : Component = <span class="keyword">new</span> Leaf(<span class="string">"2_1"</span>);</span><br><span class="line">    node2.add(node2_1);</span><br><span class="line">    <span class="keyword">const</span> children1 = root.getChildren();</span><br><span class="line">    <span class="built_in">console</span>.log(children1);</span><br><span class="line">    root.remove(node2);</span><br><span class="line">    <span class="keyword">const</span> children2 = root.getChildren();</span><br><span class="line">    <span class="built_in">console</span>.log(children2);</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【23种设计模式】9装饰者模式</title>
    <url>/2020/08/06/%E3%80%9023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%919%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>描述：对象易于动态添加新功能，开闭原则<br>优点：装饰类和被装饰类解耦，代替继承，动态展类的功能<br>缺点：过度使用，增加复杂度  </p>
</blockquote>
<a id="more"></a>

<p>应用：给类扩展功能，动态增加和删除功能，基础功能组合的新功能</p>
<hr>
<pre class="mermaid">classDiagram
  class Component {
    <<abstract>>
    +operate()* viod
  }
  class ConcreteComponent{
    +operate() void
  }
  class Decorator{
    <<abstract>>
    -component : Component
    constructor(component : Component )
    +operate() void
  }
  class ConcreteDecorator{
    constructor(component : Component)
    -methodA() void
    +operate() void
  }
  Component <|-- ConcreteComponent :继承
  Component <|-- Decorator :继承
  Component --o Decorator :聚合
  Decorator <|-- ConcreteDecorator :继承</pre>

<ul>
<li>抽象类<ul>
<li>具体类继承抽象类</li>
</ul>
</li>
<li>装饰器抽象类<ul>
<li>实现具体装饰者</li>
</ul>
</li>
<li>实例化具体类<ul>
<li>对实例进行装饰，</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象构件</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Component &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> operate() : <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体构件</span></span><br><span class="line"><span class="keyword">class</span> ConcreteComponent <span class="keyword">extends</span> Component &#123;</span><br><span class="line">    <span class="keyword">public</span> operate() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'do something'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 装饰角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Decorator <span class="keyword">extends</span> Component &#123;</span><br><span class="line">    <span class="keyword">private</span> component : Component = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">component : Component </span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> operate() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.component.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体装饰者</span></span><br><span class="line"><span class="keyword">class</span> ConcreteDecoratorA <span class="keyword">extends</span> Decorator &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">component : Component</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义自己的修饰方法</span></span><br><span class="line">    <span class="keyword">private</span> methodA() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'methodA修饰'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写父类方法</span></span><br><span class="line">    <span class="keyword">public</span> operate() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.methodA();</span><br><span class="line">        <span class="keyword">super</span>.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ConcreteDecoratorB <span class="keyword">extends</span> Decorator &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">component : Component</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义自己的修饰方法</span></span><br><span class="line">    <span class="keyword">private</span> methodB() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'methodB修饰'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写父类方法</span></span><br><span class="line">    <span class="keyword">public</span> operate() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.methodB();</span><br><span class="line">        <span class="keyword">super</span>.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> component : Component = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">    <span class="comment">// 第一次装饰</span></span><br><span class="line">    component = <span class="keyword">new</span> ConcreteDecoratorA(component);</span><br><span class="line">    <span class="comment">// 第二次装饰</span></span><br><span class="line">    component = <span class="keyword">new</span> ConcreteDecoratorB(component);</span><br><span class="line">    <span class="comment">// 装饰后运行</span></span><br><span class="line">    component.operate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【23种设计模式】8桥接模式</title>
    <url>/2020/08/06/%E3%80%9023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%918%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>描述：抽象和实现区分，且可以单独改变<br>优点：解耦，减少子类个数<br>缺点：需要识别独立变化的维度，有局限性  </p>
</blockquote>
<a id="more"></a>

<p>应用：继承过多导致类繁杂，转账分类，消息管理</p>
<hr>
<pre class="mermaid">classDiagram
  class Implementor{
    doSomething() void
    doAnything() void
  }
  class ConcreteImplementor{
    +doSomething() void
    +doAnything() void
  }
  class Abstraction{
    <<abstract>>
    -imp: Implementor
    constructor(imp : Implementor)
    +request() void
  }
  class RefinedAbstraction{
    constructor(imp : Implementor)
    +request() void
  }
  Implementor <|.. ConcreteImplementor :接口实现
  Abstraction o-- Implementor :聚合
  Abstraction <|-- RefinedAbstraction :抽象类继承</pre>

<ul>
<li>接口定义某角色要做的事情<ul>
<li>具体类实现接口</li>
</ul>
</li>
<li>抽象类，聚合这个角色接口<ul>
<li>继承这个抽象类</li>
</ul>
</li>
<li>实例化具体类<ul>
<li>对实例的功能进行抽象，得到新实例</li>
<li>调用新实例的方法</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现接口角色</span></span><br><span class="line"><span class="keyword">interface</span> Implementor &#123;</span><br><span class="line">    doSomething() : <span class="built_in">void</span>;</span><br><span class="line">    doAnything() : <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现角色</span></span><br><span class="line"><span class="keyword">class</span> ConcreteImplementor1 <span class="keyword">implements</span> Implementor &#123;</span><br><span class="line">    <span class="keyword">public</span> doSomething() : <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> doAnything() : <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ConcreteImplementor2 <span class="keyword">implements</span> Implementor &#123;</span><br><span class="line">    <span class="keyword">public</span> doSomething() : <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> doAnything() : <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Abstraction &#123;</span><br><span class="line">    <span class="keyword">private</span> imp : Implementor;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">imp : Implementor</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.imp = imp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自身的行为和属性</span></span><br><span class="line">    <span class="keyword">public</span> request() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.imp.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体抽象化角色</span></span><br><span class="line"><span class="keyword">class</span> RefinedAbstraction <span class="keyword">extends</span> Abstraction &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">imp : Implementor</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(imp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> request() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 自己写一些处理业务</span></span><br><span class="line">        <span class="keyword">super</span>.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// 定义一个实现化角色</span></span><br><span class="line"><span class="keyword">const</span> imp : Implementor = <span class="keyword">new</span> ConcreteImplementor1();</span><br><span class="line"><span class="comment">// 定义一个抽象化角色</span></span><br><span class="line"><span class="keyword">const</span> abs : Abstraction = <span class="keyword">new</span> RefinedAbstraction(imp);</span><br><span class="line"><span class="comment">// 执行上下文</span></span><br><span class="line">abs.request();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【23种设计模式】7适配器模式</title>
    <url>/2020/08/04/%E3%80%9023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%917%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>描述：将一个类的接口变换为另一个，匹配两个不同类<br>优点：提高类的复用性<br>缺点：类适配器的适配者需要暴露方法，对象适配器替换时麻烦  </p>
</blockquote>
<a id="more"></a>

<p>应用：接口不规范的类进行转换，使用接口中的部分方法</p>
<hr>
<blockquote>
<p>类适配器</p>
</blockquote>
<pre class="mermaid">classDiagram
  class Target{
    <<Interface>>
    request() void
  }
  class Adaptee{
    constructor()
    +specificRequest() void
  }
  class Adapter{
    constructor()
    +request() void
  }
  Target <|.. Adapter:实现
  Adaptee <|-- Adapter:继承</pre>

<ul>
<li>目标对象接口</li>
<li>被适配者类</li>
<li>适配器，用来继承类、实现接口</li>
<li>实例调用的是被适配者类的逻辑</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="keyword">interface</span> Target &#123;</span><br><span class="line">    request() : <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被适配者</span></span><br><span class="line"><span class="keyword">class</span> Adaptee &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 这是源角色，有自己的的业务逻辑</span></span><br><span class="line">    <span class="keyword">public</span> specificRequest() : <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="keyword">class</span> Adapter <span class="keyword">extends</span> Adaptee <span class="keyword">implements</span> Target &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> request() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target : Target = <span class="keyword">new</span> Adapter();</span><br><span class="line">target.request();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象适配器</p>
</blockquote>
<pre class="mermaid">classDiagram
  class Target{
    <<Interface>>
    request() void
  }
  class Adaptee{
    constructor()
    +specificRequest() void
  }
  class Adapter{
    -adaptee: Adaptee
    constructor(adaptee : Adaptee)
    +request() void
  }
  Target <|.. Adapter:实现
  Adaptee --o Adapter:聚合</pre>

<ul>
<li>目标对象接口</li>
<li>被适配者类</li>
<li>适配器，用来实现接口，被适配者类私有化</li>
<li>通过适配器传入实例的方式进行实例化，并调用相关方法</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="keyword">interface</span> Target &#123;</span><br><span class="line">    request() : <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被适配者</span></span><br><span class="line"><span class="keyword">class</span> Adaptee &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 这是源角色，有自己的的业务逻辑</span></span><br><span class="line">    <span class="keyword">public</span> specificRequest() : <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="keyword">class</span> Adapter <span class="keyword">implements</span> Target &#123;</span><br><span class="line">    <span class="keyword">private</span> adaptee : Adaptee;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">adaptee : Adaptee</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> request() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> target : Target = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">target.request();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接口适配器</p>
</blockquote>
<pre class="mermaid">classDiagram
  class Adaptee{
    <<Interface>>
    operation1() void
    operation2() void
  }
  class AbsAdapter{
    +operation1() void
    +operation2() void
  }
  class UseClass{
    operation1() void
  }
  Adaptee <|.. AbsAdapter :实现
  AbsAdapter <.. UseClass :依赖</pre>

<ul>
<li>目标对象接口</li>
<li>被适配者类,实现目标对象接口</li>
<li>新的类，重写适配者类的函数内容</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Adaptee &#123;</span><br><span class="line">    operation1() : <span class="built_in">void</span>;</span><br><span class="line">    operation2() : <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> AbsAdapter <span class="keyword">implements</span> Adaptee &#123;</span><br><span class="line">    <span class="keyword">public</span> operation1() : <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> operation2() : <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> UseClass <span class="keyword">extends</span> AbsAdapter &#123;</span><br><span class="line">    <span class="keyword">public</span> operation1() : <span class="built_in">void</span> &#123;&#125;<span class="comment">// 重写该类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【23种设计模式】6建造者模式</title>
    <url>/2020/08/04/%E3%80%9023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%916%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>描述：对象的构建与表示分离，同样的构建过程创建不同的表示<br>优点：解耦对象和它的构建过程，建造者独立，容易扩展<br>缺点：需要对象有较多的共同点，对象内部变化导致建造者变多  </p>
</blockquote>
<a id="more"></a>

<p>应用：指定属性构建对象，组装小对象，组成大对象</p>
<hr>
<pre class="mermaid">classDiagram
  class Product{
    +doSomething() void
  }
  class Builder{
    <<abstract>>
    +buildPartA()* void
    +buildPartB()* void
    +buildProduct()* Product
  }
  class ConcreteBuilder{
    -product Product
    constructor(product : Product)
    +buildPartA() void
    +buildPartB() void
    +buildProduct() Product
  }
  class Director{
    -_builder : Builder
    constructor(builder : Builder)
    setbuilder(builder : Builder)
    +constructorProduct()
  }
  Director o-- Builder :聚合
  Builder <|.. ConcreteBuilder :实现
  Product <.. ConcreteBuilder :依赖</pre>

<ul>
<li>对建造者抽象，指定需要抽象出哪些产品<ul>
<li>实现建造者</li>
</ul>
</li>
<li>指挥者，处理建造的流程</li>
<li>实例化一个建造者，交给指挥者，指挥者的实例进行构建</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品角色</span></span><br><span class="line"><span class="keyword">class</span> Product &#123;</span><br><span class="line">    <span class="keyword">public</span> doSomething() : <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 独立业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象建造者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Builder &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> buildPartA() : <span class="built_in">void</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> buildPartB() : <span class="built_in">void</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> buildPartC() : <span class="built_in">void</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> buildProduct() : Product;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体建造者</span></span><br><span class="line"><span class="keyword">class</span> ConcreteBuilder <span class="keyword">extends</span> Builder &#123;</span><br><span class="line">    <span class="keyword">private</span> product : Product;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">product : Product</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.product = product;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> buildPartA() : <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> buildPartB() : <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> buildPartC() : <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 最终组建一个产品</span></span><br><span class="line">    <span class="keyword">public</span> buildProduct() : Product &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指挥者</span></span><br><span class="line"><span class="keyword">class</span> Director &#123;</span><br><span class="line">    <span class="keyword">private</span> _builder : Builder;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">builder : Builder</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> builder(builder : Builder) &#123;</span><br><span class="line">        <span class="keyword">this</span>._builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将处理建造的流程交给指挥者</span></span><br><span class="line">    <span class="keyword">public</span> constructorProduct() &#123;</span><br><span class="line">        <span class="keyword">this</span>._builder.buildPartA();</span><br><span class="line">        <span class="keyword">this</span>._builder.buildPartB();</span><br><span class="line">        <span class="keyword">this</span>._builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._builder.buildProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> builder : Builder = <span class="keyword">new</span> ConcreteBuilder(<span class="keyword">new</span> Product());</span><br><span class="line"><span class="keyword">const</span> director : Director = <span class="keyword">new</span> Director(builder);</span><br><span class="line"><span class="keyword">const</span> product : Product = director.constructorProduct();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【23种设计模式】5原型模式</title>
    <url>/2020/08/03/%E3%80%9023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%915%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>描述：用原型实例指定创建对象的种类，拷贝原型创建新对象<br>优点：简化创建新对象的过程，动态获取对象运行时，属性修改父变子变<br>缺点：修改已有类时，违反开闭原则  </p>
</blockquote>
<a id="more"></a>

<p>应用：创建成本较大的场景，需要动态获取当前对象运行状态的场景</p>
<hr>
<pre class="mermaid">classDiagram
  class Prototype{
    <<interface>>
    clone():Prototype
  }
  class Dog{
    +name: string
    +birthYear: number
    +sex: string
    +presentYear: number
    constructor()
    +getDiscription() string
    +clone() Prototype
  }
  Prototype <|-- Dog :实现</pre>

<ul>
<li>原型对象接口<ul>
<li>实例实现类</li>
</ul>
</li>
<li>实例调用类中的方法</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Prototype &#123;</span><br><span class="line">    clone():Prototype;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">implements</span> Prototype &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">public</span> birthYear: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">public</span> sex: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">public</span> presentYear: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"lili"</span>;</span><br><span class="line">        <span class="keyword">this</span>.birthYear = <span class="number">2015</span>;</span><br><span class="line">        <span class="keyword">this</span>.sex = <span class="string">"男"</span>;</span><br><span class="line">        <span class="keyword">this</span>.presentYear = <span class="number">2018</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> getDiscription(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`狗狗叫<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>,性别<span class="subst">$&#123;<span class="keyword">this</span>.sex&#125;</span>,<span class="subst">$&#123;<span class="keyword">this</span>.presentYear&#125;</span>年<span class="subst">$&#123;<span class="keyword">this</span>.presentYear - <span class="keyword">this</span>.birthYear&#125;</span>岁了`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现复制</span></span><br><span class="line">    <span class="keyword">public</span> clone(): Prototype &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="built_in">console</span>.log(dog.getDiscription());</span><br><span class="line"><span class="comment">// 拷贝不会影响原实例</span></span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="built_in">Object</span>.create(dog);</span><br><span class="line">dog1.presentYear = <span class="number">2020</span>;</span><br><span class="line"><span class="built_in">console</span>.log(dog1.getDiscription());</span><br><span class="line"><span class="keyword">const</span> dog2 = dog.clone();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'--'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.getDiscription());</span><br><span class="line"><span class="built_in">console</span>.log(dog1.getDiscription());</span><br><span class="line"><span class="built_in">console</span>.log(dog2.getDiscription());</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【23种设计模式】4抽象工厂模式</title>
    <url>/2020/08/03/%E3%80%9023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%914%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>描述：  创建相关的对象提供接口，无须指定具体类<br>优点：  便于新增产品<br>缺点：  调整产品结构麻烦，违反开闭原则  </p>
</blockquote>
<a id="more"></a>

<p>应用：无需关注对象创建过程，稳定结构的产品类，每次新增产品</p>
<hr>
<pre class="mermaid">classDiagram
  class AbstractProductA
  <<interface>> AbstractProductA
  class AbstractProductB
  <<interface>> AbstractProductB

  class AbstractFactory{
    <<interface>>
    createProductA()* AbstractProductA
    createProductB()* AbstractProductB
  }
  class ConcreteFactory1{
    constructor()
    +createProductA() AbstractProductA
    +createProductB() AbstractProductB
  }
  class ConcreteFactory2{
    constructor()
    +createProductA() AbstractProductA
    +createProductB() AbstractProductB
  }
  class ConcreteProductA1
  class ConcreteProductB1
  AbstractProductA <|.. ConcreteProductA1:实现
  AbstractProductB <|.. ConcreteProductA1:实现
  AbstractProductA <|.. ConcreteProductB1:实现
  AbstractProductB <|.. ConcreteProductB1:实现
  AbstractFactory <|.. ConcreteFactory1 :实现
  AbstractFactory <|.. ConcreteFactory2 :实现
  ConcreteProductA1 <.. ConcreteFactory1:依赖
  ConcreteProductB1 <.. ConcreteFactory2:依赖</pre>

<ul>
<li>产品接口 &amp; 产品工厂接口  <ul>
<li>产品实现类 &amp; 工厂实现类</li>
</ul>
</li>
<li>工厂实现类依赖产品实现类</li>
<li>工厂的实例的产品方法创建产品实例</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象产品A接口</span></span><br><span class="line"><span class="keyword">interface</span> AbstractProductA &#123;&#125;</span><br><span class="line"><span class="comment">// 抽象产品B接口</span></span><br><span class="line"><span class="keyword">interface</span> AbstractProductB &#123;&#125;</span><br><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">interface</span> AbstractFactory &#123;</span><br><span class="line">    createProductA() : AbstractProductA;</span><br><span class="line">    createProductB() : AbstractProductB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// implements实现接口中定义的抽象方法</span></span><br><span class="line"><span class="comment">// 具体产品A1</span></span><br><span class="line"><span class="keyword">class</span> ConcreteProductA1 <span class="keyword">implements</span> AbstractProductA &#123;&#125;</span><br><span class="line"><span class="comment">// 具体产品A2</span></span><br><span class="line"><span class="keyword">class</span> ConcreteProductA2 <span class="keyword">implements</span> AbstractProductA &#123;&#125;</span><br><span class="line"><span class="comment">// 具体产品B1</span></span><br><span class="line"><span class="keyword">class</span> ConcreteProductB1 <span class="keyword">implements</span> AbstractProductB &#123;&#125;</span><br><span class="line"><span class="comment">// 具体产品B2</span></span><br><span class="line"><span class="keyword">class</span> ConcreteProductB2 <span class="keyword">implements</span> AbstractProductA &#123;&#125;</span><br><span class="line"><span class="comment">// 具体工厂1</span></span><br><span class="line"><span class="keyword">class</span> ConcreteFactory1 <span class="keyword">implements</span> AbstractFactory &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> createProductA() : AbstractProductA &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> createProductB() : AbstractProductB &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体工厂2</span></span><br><span class="line"><span class="keyword">class</span> ConcreteFactory2 <span class="keyword">implements</span> AbstractFactory &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> createProductA() : AbstractProductA &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> createProductB() : AbstractProductB &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// 工厂实例</span></span><br><span class="line"><span class="keyword">const</span> factory1 : AbstractFactory = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line"><span class="keyword">const</span> factory2 : AbstractFactory = <span class="keyword">new</span> ConcreteFactory2();</span><br><span class="line"><span class="comment">// 实例创建产品</span></span><br><span class="line"><span class="keyword">const</span> productA1 : AbstractProductA = factory1.createProductA();</span><br><span class="line"><span class="keyword">const</span> productA2 : AbstractProductA = factory2.createProductA();</span><br><span class="line"><span class="keyword">const</span> productB1 : AbstractProductB = factory1.createProductB();</span><br><span class="line"><span class="keyword">const</span> productB2 : AbstractProductB = factory2.createProductB();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【23种设计模式】3工厂方法模式</title>
    <url>/2020/08/03/%E3%80%9023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%913%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>描述：封装一个创建对象的类，由子类决定需要实例化的类<br>优点：添加新产品要添加一个具体工厂和具体产品，符合开放封闭<br>缺点：类的个数多</p>
</blockquote>
<a id="more"></a>

<p>应用：创建对象时，需要灵活可扩展的类时</p>
<hr>
<blockquote>
<p>简单工厂&amp;工厂方法区别</p>
</blockquote>
<ul>
<li>简单工厂<ul>
<li>工厂类中包含了必要的判断逻辑，根据条件动态的实例化相关的类，不同的实例会有不同的运算</li>
<li>添加新需求时，需要修改原有的类，不但对扩展开放，也对修改开放了</li>
</ul>
</li>
<li>工厂方法<ul>
<li>依赖倒转倒转原则，把工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法，所有要生成的工厂都去实现这一个接口</li>
</ul>
</li>
</ul>
<pre class="mermaid">classDiagram
    class Product{
        <<interface>>
        method1()
        method2()
    }
    class ConcreteProduct_1{
        constructor()
        method1()
        method2()
    }
    class Creator {
        <<abstract>>
        +createProduct()* Product
    }
    class ConcreteCreator{
        constructor()
        +createProduct() Product
    }
    ConcreteCreator --|> Creator:继承
    ConcreteCreator ..> ConcreteProduct_1:依赖
    ConcreteProduct_1 ..|> Product:实现</pre>

<ul>
<li>产品接口<ul>
<li>产品实现类</li>
</ul>
</li>
<li>产品工厂<ul>
<li>依赖产品实现类</li>
<li>创建产品实例</li>
</ul>
</li>
<li>工厂的实例创建产品</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象产品接口</span></span><br><span class="line"><span class="keyword">interface</span> Product&#123;</span><br><span class="line">    method1() : <span class="built_in">void</span>;</span><br><span class="line">    method2() : <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体产品一</span></span><br><span class="line"><span class="keyword">class</span> ConcreteProduct_1 <span class="keyword">implements</span> Product &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    method1() &#123;&#125;</span><br><span class="line">    method2() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Creator &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> createProduct(<span class="keyword">type</span> : <span class="built_in">number</span>) : Product;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">class</span> ConcreteCreator <span class="keyword">extends</span> Creator &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ts中，在继承的父类中包含abstract时必须在子类实现此方法</span></span><br><span class="line">    <span class="keyword">public</span> createProduct(<span class="keyword">type</span> : <span class="built_in">number</span>) : Product &#123;</span><br><span class="line">        <span class="keyword">let</span> product = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct_1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="number">2</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct_2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> creator : Creator = <span class="keyword">new</span> ConcreteCreator();</span><br><span class="line"><span class="keyword">const</span> myProduct : Product = creator.createProduct(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【23种设计模式】2简单工厂模式</title>
    <url>/2020/08/01/%E3%80%9023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%912%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>描述：封装一个创建对象的类<br>优点：解耦，父类不需要知道子类细节<br>缺点：工厂职责重，扩展困难，违反开闭原则  </p>
</blockquote>
<a id="more"></a>

<p>应用：工厂负责创建个别对象</p>
<hr>
<pre class="mermaid">classDiagram
    class Product
    <<interface>> Product
    class ConcreteProduct1{
        constructor()
    }
    class Factory {
        +createProduct()$ Product
    }
    Factory --> ConcreteProduct1:依赖
    ConcreteProduct1 ..|> Product:实现</pre>

<ul>
<li>产品接口<ul>
<li>产品实现类</li>
</ul>
</li>
<li>工厂类依赖产品实现类</li>
<li>工厂的实例创建产品</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象产品接口</span></span><br><span class="line"><span class="keyword">interface</span> Product&#123;&#125;</span><br><span class="line"><span class="comment">// 具体产品类</span></span><br><span class="line"><span class="keyword">class</span> ConcreteProduct1 <span class="keyword">implements</span> Product &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单工厂</span></span><br><span class="line"><span class="keyword">class</span> Factory &#123;</span><br><span class="line">    <span class="comment">// 工厂的公有方法根据接收的参数不同，实例化不同对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> createProduct(<span class="keyword">type</span> : <span class="built_in">number</span>) : Product &#123;</span><br><span class="line">        <span class="keyword">let</span> product = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="keyword">type</span> === <span class="number">2</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> product = Factory.createProduct(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(product);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【23种设计模式】1单例模式</title>
    <url>/2020/07/31/%E3%80%9023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%911%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>描述：一个类只有一个实例<br>优点：减少内存，共享访问<br>缺点：不宜扩展和测试  </p>
</blockquote>
<a id="more"></a>

<p>应用：用于需要频繁创建的对象</p>
<hr>
<p>两种实现</p>
<pre class="mermaid">classDiagram
    class Singleton {
        -constructor()
        -getInstance
        +getInstance()
    }</pre>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉模式，类的实例在初始化时创建</span></span><br><span class="line"><span class="keyword">class</span> Singleton &#123;</span><br><span class="line">    <span class="comment">// 构造类私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="comment">// 类的内部，【立即】创建对象实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> instance : Singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">// 公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> getInstance() : Singleton &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Singleton.getInstance(), <span class="string">'11111'</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉模式，类的实例在调用时创建</span></span><br><span class="line"><span class="keyword">class</span> Singleton &#123;</span><br><span class="line">    <span class="comment">// 构造类私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="comment">// 类的内部创建空对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> instance: Singleton = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 公有的静态方法，【调用时】返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> getInstance() : Singleton &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.instance === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Singleton.getInstance(), <span class="string">'2222'</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【23种设计模式】介绍</title>
    <url>/2020/07/30/%E3%80%9023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<p>开启前端系列之设计模式（TS）</p>
</blockquote>
<a id="more"></a>

<p><a href="http://c.biancheng.net/view/1317.html" target="_blank" rel="noopener">设计模式</a>无关何种语言，可以使代码具有可扩展性、可复用性，减少冗余</p>
<p>最近要对项目进行重构，因此结合typescript复习一下设计模式，增加代码健壮性</p>
<p>【8月开启的新篇章】将会结合codepen和mermaid 流程图</p>
<hr>
<blockquote>
<p>7大原则演化为23种设计模式</p>
</blockquote>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>一个类只负责一件事</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>一个类对另一个类的依赖建立在最小接口上</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>细节依赖抽象，面向接口编程</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>子类不要重写父类方法</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>对扩展开放，对修改关闭</p>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>只与直接对象/组件通信</p>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>优先使用组合或者聚合关系复用，少用继承关系复用</p>
<hr>
<hr>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><blockquote>
<p>创建对象，抽象实例化对象的过程，只需使用不用关注逻辑</p>
</blockquote>
<p>单例模式、简单工厂模式、工厂方法模式、抽象模式、原型模式、建造者模式</p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><blockquote>
<p>组装现有的类，设计交互方式，实现某些功能</p>
</blockquote>
<p>适配器模式、桥接模式、装饰着模式、组合模式、外观模式、享元模式、代理模式</p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><blockquote>
<p>不同的对象之间划分责任，算法抽象化，不仅仅关注类和对象的结构，更重要的是相互作用，划分类与对象的职责，实现合理的交互</p>
</blockquote>
<p>模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐画流程图的工具</title>
    <url>/2020/07/29/%E6%8E%A8%E8%8D%90%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<blockquote>
<p>当然也是需要结合 markdown &amp;&amp; vscode 使用</p>
</blockquote>
<a id="more"></a>

<h2 id="markdown-流程图，需要安装扩展"><a href="#markdown-流程图，需要安装扩展" class="headerlink" title="markdown 流程图，需要安装扩展"></a>markdown 流程图，需要安装扩展</h2><p>Markdown Preview Mermaid Support</p>
<blockquote>
<p>支持流程图、饼状图、序列图、类图、状态图、甘特图、ER 图</p>
</blockquote>
<p><a href="https://mermaid-js.github.io/mermaid/" target="_blank" rel="noopener">https://mermaid-js.github.io/mermaid/</a></p>
<!-- https://www.imooc.com/article/292708 -->
<!-- uml EA -->

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">5 种流程图方向</span><br><span class="line">TB 从上到下 = TD</span><br><span class="line">BT 从下到上</span><br><span class="line">RL 从右到左</span><br><span class="line">LR 从左到右</span><br></pre></td></tr></table></figure>

<blockquote>
<p>5 种节点图形</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">节点</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id[txt]</td>
<td align="center">矩形</td>
</tr>
<tr>
<td align="center">id4(txt)</td>
<td align="center">圆角矩形</td>
</tr>
<tr>
<td align="center">id3&gt;txt]</td>
<td align="center">不对称的矩形</td>
</tr>
<tr>
<td align="center">id1{txt}</td>
<td align="center">菱形</td>
</tr>
<tr>
<td align="center">id2((txt))</td>
<td align="center">圆形</td>
</tr>
</tbody></table>
<blockquote>
<p>9 种节点连接</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">连线</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–&gt;</td>
<td align="center">实现箭头</td>
</tr>
<tr>
<td align="center">—</td>
<td align="center">实线连接</td>
</tr>
<tr>
<td align="center">-.-</td>
<td align="center">虚线连接</td>
</tr>
<tr>
<td align="center">-.-&gt;</td>
<td align="center">虚线箭头指向</td>
</tr>
<tr>
<td align="center">==&gt;</td>
<td align="center">加粗箭头指向</td>
</tr>
<tr>
<td align="center">– 描述 —</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">– 描述 –&gt;</td>
<td align="center">支持`–&gt;</td>
</tr>
<tr>
<td align="center">-. 描述 .-&gt;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">== 描述 ==&gt;</td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>流程图</p>
</blockquote>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- mermaid --&gt;</span></span></span><br><span class="line">graph TD</span><br><span class="line">  step1[开始] --&gt; step2&#123;判断&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>子流程图</p>
</blockquote>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- mermaid --&gt;</span></span></span><br><span class="line">graph LR</span><br><span class="line"><span class="code">    c1--&gt;a2</span></span><br><span class="line"><span class="code">    subgraph 子内容区域</span></span><br><span class="line"><span class="code">        a1--&gt;a2</span></span><br><span class="line"><span class="code">    end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>自定义样式</p>
</blockquote>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- mermaid --&gt;</span></span></span><br><span class="line">graph LR</span><br><span class="line"><span class="code">    s1(Start)--&gt;s2(Stop)</span></span><br><span class="line"><span class="code">    style s1 fill:#f9f,stroke:#333,stroke-width:4px,fill-opacity:0.5</span></span><br><span class="line"><span class="code">    style s2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 10,5</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- mermaid --&gt;</span></span></span><br><span class="line">graph LR</span><br><span class="line"><span class="code">    start[开始] --&gt; input[输入A,B,C]</span></span><br><span class="line"><span class="code">    input --&gt; conditionA&#123;A是否大于B&#125;</span></span><br><span class="line"><span class="code">    conditionA -- YES --&gt; conditionC&#123;A是否大于C&#125;</span></span><br><span class="line"><span class="code">    conditionA -- NO --&gt; conditionB&#123;B是否大于C&#125;</span></span><br><span class="line"><span class="code">        conditionC -- YES --&gt; printA[输出A]</span></span><br><span class="line"><span class="code">        conditionC -- NO --&gt; printC[输出C]</span></span><br><span class="line"><span class="code">        conditionB -- YES --&gt; printB[输出B]</span></span><br><span class="line"><span class="code">        conditionB -- NO --&gt; printC[输出C]</span></span><br><span class="line"><span class="code">    printA --&gt; stop[结束]</span></span><br><span class="line"><span class="code">    printC --&gt; stop</span></span><br><span class="line"><span class="code">    printB --&gt; stop</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>更好的推荐，vscode - drawio 插件，当然drawio也有在线网页版本</p>
</blockquote>
<h2 id="js下载速度很慢啊"><a href="#js下载速度很慢啊" class="headerlink" title="js下载速度很慢啊"></a>js下载速度很慢啊</h2><h2 id="hexo中使用mermaid"><a href="#hexo中使用mermaid" class="headerlink" title="hexo中使用mermaid"></a>hexo中使用mermaid</h2><p>step1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -S hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure>

<p>step2</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml最底部加上</span></span><br><span class="line"><span class="comment"># 支持流程图mermaid</span></span><br><span class="line"><span class="attr">mermaid:</span> <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># default true</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">"8.6.0"</span> <span class="comment">#</span></span><br><span class="line">    <span class="attr">options:</span> <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span><br><span class="line">    <span class="comment"># startOnload: true  // default true</span></span><br></pre></td></tr></table></figure>

<p>step3</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- next主题默认已配置 --&gt;</span></span></span><br><span class="line">在<span class="emphasis">_data/next.yml或者.next/_</span>config.yml上找到Mermaid并启用</span><br></pre></td></tr></table></figure>

<p>step4</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">没遇到写footer.swig的不需要修改</span><br><span class="line">刷新页面，等待加载</span><br></pre></td></tr></table></figure>

<p>step5</p>
<p>样式问题修改</p>
<p>如网页渲染的classDiagram的<a href="https://mermaid-js.github.io/mermaid/#/classDiagram" target="_blank" rel="noopener">font-size</a>搜索Sample stylesheet</p>
<p>vs code自定义样式表，设置-<code>Markdown: Styles</code>-项目文件夹中添加css，如<code>source\\_data\\styles_markdown.css</code></p>
<p>如graph可以用style id1 fill:#f9f</p>
<pre class="mermaid">graph LR
    c1-->a2
    subgraph 子内容区域
        a1-->a2
    end</pre>

<pre class="mermaid" style="text-align: center;">
            sequenceDiagram
            
          </pre>

<pre class="mermaid">sequenceDiagram
  participant Alice
  participant Bob
  Alice->John: Hello John, how are you?
  loop Healthcheck
      John->John: Fight against hypochondria
  end
  Note right of John: Rational thoughts <br/>prevail...
  John-->Alice: Great!
  John->Bob: How about you?
  Bob-->John: Jolly good!</pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>一个可视化的git命令学习网站</title>
    <url>/2020/07/27/%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84git%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<blockquote>
<p>不用再纠结git命令不会写了</p>
</blockquote>
<a id="more"></a>

<p><a href="https://oschina.gitee.io/learn-git-branching/" target="_blank" rel="noopener">learn-git-branching</a> ，so easy</p>
<p>以下仅为个人记录</p>
<hr>
<h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><ul>
<li>提交 git commit -m “”</li>
</ul>
<h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><ul>
<li>创建新分支 git checkout -b feature</li>
</ul>
<h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><ul>
<li>查看 hash 记录 git log</li>
</ul>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ul>
<li><p>创建新节点 git merge feature</p>
</li>
<li><p>线性提交历史 git rebase master</p>
</li>
</ul>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><ul>
<li>HEAD，指向当前分支上的最近提交记录</li>
<li>分离 HEAD，是指向某个具体提交而不是分支名<ul>
<li>git checkout ‘hash’ 指向某次提交即可分离 HEAD</li>
</ul>
</li>
</ul>
<h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h3><ul>
<li><p>^符号移动一步</p>
<ul>
<li>git checkout master^</li>
<li>git checkout HEAD^</li>
</ul>
</li>
<li><p>~符号移动多步</p>
<ul>
<li>git checkout HEAD~2</li>
</ul>
</li>
<li><p>移动分支，当前分支指向另一个提交</p>
<ul>
<li>git branch -f master HEAD~3</li>
<li>git branch -f feature #hash</li>
</ul>
</li>
</ul>
<h3 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h3><ul>
<li><p>git reset</p>
<ul>
<li>git reset HEAD~1,变更还在，但是处于未加入暂存区状态</li>
</ul>
</li>
<li><p>git revert</p>
<ul>
<li>git revert HEAD,产生新节点 C，用于标识撤销的节点 B，内容和节点 A 一致</li>
</ul>
</li>
</ul>
<h3 id="整理提交记录"><a href="#整理提交记录" class="headerlink" title="整理提交记录"></a>整理提交记录</h3><ul>
<li>当知道所需要的提交记录（并且还知道这些提交记录的哈希值）</li>
<li>git cherry-pick #hash 将一些提交复制到当前所在的位置（HEAD）下面<ul>
<li>git cherry-pick C2 C4，在当前分支上，把其他的分支内容拿过来</li>
</ul>
</li>
</ul>
<h3 id="交互式rebase"><a href="#交互式rebase" class="headerlink" title="交互式rebase"></a>交互式rebase</h3><ul>
<li>不清楚想要的提交记录的哈希值</li>
<li>rebase -interactive,简写为 -i,打开一个 ui 框操作（文本框）</li>
<li>git rebase -i HEAD~4</li>
</ul>
<h3 id="本地栈式提交"><a href="#本地栈式提交" class="headerlink" title="本地栈式提交"></a>本地栈式提交</h3><ul>
<li>开发调试时添加了打印语句，不需要这些项</li>
<li>让 Git 复制解决问题的那一个提交记录，git rebase -i 或 git cherry-pick</li>
<li>本地 master-bug-console-bugfix，4 个节点<ul>
<li>方法 1：git rebase -i HEAD~3 &amp; git checkout master &amp; git merge bugFix 删除中间项后 merge</li>
<li>方法 2：git checkout master &amp; git cherry-pick bugfix 直接把 bugfix 节点转移</li>
</ul>
</li>
</ul>
<h3 id="提交的技巧"><a href="#提交的技巧" class="headerlink" title="提交的技巧"></a>提交的技巧</h3><p>分支 1 提交后，基于最新提交创建分支 2，再次提交，想修改分支 1 的提交记录中的内容（移动想要修改的到最前面），但可能存在 rebase 导致的冲突</p>
<ul>
<li>先用 git rebase -i 将提交重新排序，然后把我们想要修改的提交记录挪到最前<ul>
<li>再 commit –amend 来进行一些小修改</li>
<li>再 git rebase -i 来将他们调回原来的顺序</li>
<li>最后 master 移到修改的最前端</li>
</ul>
</li>
<li>git rebase -i HEAD~2 –solution-ordering C3,C2 ，重新排序<ul>
<li>git commit –amend，创建新的提交节点</li>
<li>git rebase -i HEAD~2 –solution-ordering C2’’,C3’，重新排序</li>
<li>git rebase caption master，合并</li>
</ul>
</li>
</ul>
<p>cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上（只要不是 HEAD 上游的提交就没问题）</p>
<ul>
<li>git checkout master<ul>
<li>git cherry-pick C2，在 master 后加入新节点 c2</li>
<li>git commit –amend，创建新的提交节点</li>
<li>git cherry-pick C3，将 c3 作为最新节点合并</li>
</ul>
</li>
</ul>
<h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><ul>
<li>永远指向某个提交记录的标识，大版本，特性，bug</li>
<li>git tag v1 C1 命名标签 v1，指向提交记录 C1<ul>
<li>git tag v1 side~1，side 的上一级打标签</li>
<li>git checkout v1，head 指向标签</li>
</ul>
</li>
</ul>
<h3 id="最近的锚点"><a href="#最近的锚点" class="headerlink" title="最近的锚点"></a>最近的锚点</h3><p><code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</code></p>
<ul>
<li>tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。当 ref 提交记录上有某个标签时，则只输出标签名称</li>
<li>git describe <ref>，得到当前提交记录所在分支的最近节点及距离</li>
</ul>
<h3 id="多分支-rebase"><a href="#多分支-rebase" class="headerlink" title="多分支 rebase"></a>多分支 rebase</h3><ul>
<li>有序的提交历史，两两合并<ul>
<li>git rebase master bugFix</li>
<li>git rebase bugFix side</li>
</ul>
</li>
<li>【禁止】git rebase c1,git rebase c2 后用 git rebase -i HEAD~2 排序，这样树无法看了</li>
</ul>
<h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><ul>
<li>例子 1，找记录节点<ul>
<li>git checkout HEAD<del>,git checkout HEAD^2,git checkout HEAD</del>2</li>
<li>git checkout HEAD<del>^2</del>2，简化</li>
</ul>
</li>
<li>例子 2，为记录节点定义一个引用<ul>
<li>git checkout c1,git branch bugWork,git checkout master</li>
<li>git branch bugWork master^^2^</li>
</ul>
</li>
</ul>
<h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ul>
<li>需要把 master 分支上最近的几次提交做不同的调整后，分别添加到各个的分支上。</li>
<li>one 需要重新排序并删除 C5<ul>
<li>git cherry-pick C4 C3 C2</li>
</ul>
</li>
<li>two 仅需要重排排序<ul>
<li>git cherry-pick C5 C4 C3 C2</li>
</ul>
</li>
<li>three 只需要提交一次。<ul>
<li>git branch -f three C2</li>
</ul>
</li>
</ul>
<h3 id="fetch-pull-push"><a href="#fetch-pull-push" class="headerlink" title="fetch/pull/push"></a>fetch/pull/push</h3><ul>
<li>git fetch 更新状态（不改变文件），从远程仓库下载本地仓库中缺失的提交记录，更新远程分支指针</li>
<li>git pull 是 git fetch 和 git merge 的缩写</li>
</ul>
<p>举例</p>
<ul>
<li><p>提交分支，master，本地开发完成，发现远端是 new master，四种处理</p>
<ul>
<li>本地变基，远端线性提交记录<ul>
<li>git fetch;git rebase origin/master;git push;</li>
<li>git pull –rebase;git push;</li>
</ul>
</li>
<li>本地合并，远端合并<ul>
<li>git fetch;git merge origin/master;git push;</li>
<li>git pull;git push;</li>
</ul>
</li>
</ul>
</li>
<li><p>合并特性分支，本地多个分支,但新功能只在最后做一次推送集成</p>
<ul>
<li>方案 1<ul>
<li>git fetch;git checkout new;git cherry-pick xx xx xx;git branch -f master HEAD;git checkout master;git push;</li>
</ul>
</li>
<li>方案 2<ul>
<li>git fetch;git rebase o/master side1;git rebase side1 side2;git rebase side2 master;</li>
</ul>
</li>
</ul>
</li>
<li><p>和 merge 的对比</p>
<ul>
<li>Rebase 使你的提交树变得很干净, 所有的提交都在一条线上，但修改了提交树的历史</li>
<li>git checkout mastre;git merge c1;git merge c2;git push;</li>
</ul>
</li>
<li><p>远程分支</p>
<ul>
<li>git checkout -b totallyNotMaster o/master，创建 totallyNotMaster 分支，用于跟踪远程分支 o/master</li>
<li>git branch -u o/master foo，本地 foo 分支跟踪 o/master</li>
<li>git branch -u o/master，本地当前分支跟踪 o/master</li>
</ul>
</li>
<li><p>提交</p>
<ul>
<li>git push origin master，切到本地仓库中的“master”分支，获取所有的提交，再到远程仓库“origin”中找到“master”分支，推送</li>
</ul>
</li>
<li><p>place 的参数</p>
<ul>
<li>当为 git push 指定 place 参数为 master 时，我们同时指定了提交记录的来源和去向。</li>
<li>git push origin <source>:<destination></li>
<li>git push origin master:new-branch，本地分支推送到远端新分支</li>
</ul>
</li>
<li><p>fetch 的参数</p>
<ul>
<li>git fetch origin foo，远程仓库的 foo 分支上，获取所有本地不存在的提交，放到本地的 o/foo 上</li>
<li>git push origin master:new-branch，本地 master 拉取远端 new-branch 分支</li>
</ul>
</li>
<li><p>省略 source</p>
<ul>
<li>git push origin :side，删除了远程仓库中的 side 分支</li>
<li>git fetch origin :bugFix，会在本地创建一个新分支</li>
</ul>
</li>
<li><p>git pull 是 fetch 后跟 merge 的缩写</p>
<ul>
<li>git pull origin foo 相当于：git fetch origin foo; git merge o/foo</li>
<li><code>git pull origin bar~1:bugFix</code> 相当于：<code>git fetch origin bar~1:bugFix; git merge bugFix</code></li>
<li>远端:本地</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>用api的方式写出正则表达式</title>
    <url>/2020/07/25/%E7%94%A8api%E7%9A%84%E6%96%B9%E5%BC%8F%E5%86%99%E5%87%BA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>super-expressive库及其api文档<br>【翻译】对应的中文文档方便理解</p>
</blockquote>
<a id="more"></a>

<p>一年前做编辑器二次开发相关项目时，涉及了正则处理就好好学习了下，然而现在都忘完了，最近发现了这个开源工具，通过api的方式生成所需要的正则表达式，COOL!</p>
<p>截至目前<a href="https://github.com/francisrstokes/super-expressive" target="_blank" rel="noopener">super-expressive</a> star 3k，但是还没有中文文档，截至发文时有50个</p>
<p>本篇是一篇翻译后的API中文文档，对示例将保持原样</p>
<hr>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><!-- 前置技能点https://www.softwhy.com/article-339-1.html -->

<details>
<summary><span style="color:#6868ff;">api列表</span></summary>
  - [SuperExpressive()](#SuperExpressive)
  - [.allowMultipleMatches](#allowMultipleMatches)
  - [.lineByLine](#lineByLine)
  - [.caseInsensitive](#caseInsensitive)
  - [.sticky](#sticky)
  - [.unicode](#unicode)
  - [.singleLine](#singleLine)
  - [.anyChar](#anyChar)
  - [.whitespaceChar](#whitespaceChar)
  - [.nonWhitespaceChar](#nonWhitespaceChar)
  - [.digit](#digit)
  - [.nonDigit](#nonDigit)
  - [.word](#word)
  - [.nonWord](#nonWord)
  - [.wordBoundary](#wordBoundary)
  - [.nonWordBoundary](#nonWordBoundary)
  - [.newline](#newline)
  - [.carriageReturn](#carriageReturn)
  - [.tab](#tab)
  - [.nullByte](#nullByte)
  - [.anyOf](#anyOf)
  - [.capture](#capture)
  - [.namedCapture(name)](#namedCapturename)
  - [.backreference(index)](#backreferenceindex)
  - [.namedBackreference(index)](#namedBackreferenceindex)
  - [.group](#group)
  - [.end()](#end())
  - [.assertAhead](#assertAhead)
  - [.assertNotAhead](#assertNotAhead)
  - [.optional](#optional)
  - [.zeroOrMore](#zeroOrMore)
  - [.zeroOrMoreLazy](#zeroOrMoreLazy)
  - [.oneOrMore](#oneOrMore)
  - [.oneOrMoreLazy](#oneOrMoreLazy)
  - [.exactly(n)](#exactlyn)
  - [.atLeast(n)](#atLeastn)
  - [.between(x, y)](#betweenx-y)
  - [.betweenLazy(x, y)](#betweenLazyx-y)
  - [.startOfInput](#startOfInput)
  - [.endOfInput](#endOfInput)
  - [.anyOfChars(chars)](#anyOfCharschars)
  - [.anythingButChars(chars)](#anythingButCharschars)
  - [.anythingButString(str)](#anythingButStringstr)
  - [.anythingButRange(a, b)](#anythingButRangea-b)
  - [.string(s)](#strings)
  - [.char(c)](#charc)
  - [.range(a, b)](#rangea-b)
  - [.subexpression(expr, opts)](#subexpressionexpr-opts)
  - [.toRegexString()](#toRegexString)
  - [.toRegex()](#toRegex)
</details>

<h3 id="SuperExpressive"><a href="#SuperExpressive" class="headerlink" title="SuperExpressive()"></a>SuperExpressive()</h3><p>创建一个实例</p>
<h3 id="allowMultipleMatches"><a href="#allowMultipleMatches" class="headerlink" title=".allowMultipleMatches"></a>.allowMultipleMatches</h3><p>使用修饰符<code>/g</code>，表示查找所有可能的匹配</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .allowMultipleMatches</span><br><span class="line">  .string(<span class="string">'hello'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/hello/g</span><br></pre></td></tr></table></figure>

<h3 id="lineByLine"><a href="#lineByLine" class="headerlink" title=".lineByLine"></a>.lineByLine</h3><p>使用修饰符<code>/m</code>，表示多行匹配</p>
<p>字符串无论是否换行只有一个开始^和结尾$，<br>如果采用多行匹配，那么每一个行都有一个^和结尾$</p>
<p><a href="#startOfInput">.startOfInput</a> 和 <a href="#endOfInput">.endOfInput</a>标记作为行的开始和结束</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .lineByLine</span><br><span class="line">  .string(<span class="string">'^hello$'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\^hello\$/m</span><br></pre></td></tr></table></figure>

<h3 id="caseInsensitive"><a href="#caseInsensitive" class="headerlink" title=".caseInsensitive"></a>.caseInsensitive</h3><p>使用修饰符<code>/i</code>，表示匹配时应忽略大小写区分</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .caseInsensitive</span><br><span class="line">  .string(<span class="string">'HELLO'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/HELLO/i</span><br></pre></td></tr></table></figure>

<h3 id="sticky"><a href="#sticky" class="headerlink" title=".sticky"></a>.sticky</h3><p>使用修饰符<code>/y</code>，表示匹配时从lastIndex位置开始进行匹配,直到匹配失败时停止</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .sticky</span><br><span class="line">  .string(<span class="string">'hello'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/hello/y</span><br></pre></td></tr></table></figure>

<h3 id="unicode"><a href="#unicode" class="headerlink" title=".unicode"></a>.unicode</h3><p>使用修饰符<code>/u</code>，表示使用完全unicode匹配，即四个字节的UTF-16编码/Unicode字符</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .unicode</span><br><span class="line">  .string(<span class="string">'héllo'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/héllo/u</span><br></pre></td></tr></table></figure>

<h3 id="singleLine"><a href="#singleLine" class="headerlink" title=".singleLine"></a>.singleLine</h3><p>使用修饰符<code>/s</code>，表示单行匹配</p>
<p><a href="#startOfInput">.startOfInput</a> 和 <a href="#endOfInput">.endOfInput</a>标记作为行的开始和结束，和<a href="#anyChar">.anyChar</a>一起用时表示匹配新行</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .singleLine</span><br><span class="line">  .string(<span class="string">'hello'</span>)</span><br><span class="line">  .anyChar</span><br><span class="line">  .string(<span class="string">'world'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/hello.world/s</span><br></pre></td></tr></table></figure>

<h3 id="anyChar"><a href="#anyChar" class="headerlink" title=".anyChar"></a>.anyChar</h3><p>元字符<code>.</code>，匹配除换行以外的任何单个字符，和<a href="#singleLine">.singleLine</a>一起用时表示匹配新行</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .anyChar</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/./</span><br></pre></td></tr></table></figure>

<h3 id="whitespaceChar"><a href="#whitespaceChar" class="headerlink" title=".whitespaceChar"></a>.whitespaceChar</h3><p>元字符<code>\s</code>,匹配任何【空白】字符，【包括】特殊的空白字符：<code>\r\n\t\f\v</code></p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .whitespaceChar</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\s/</span><br></pre></td></tr></table></figure>

<h3 id="nonWhitespaceChar"><a href="#nonWhitespaceChar" class="headerlink" title=".nonWhitespaceChar"></a>.nonWhitespaceChar</h3><p>元字符<code>/S</code>，匹配任何【非空白】字符，【不包括】特殊空格字符：<code>\r\n\t\f\v</code></p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .nonWhitespaceChar</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\S/</span><br></pre></td></tr></table></figure>

<h3 id="digit"><a href="#digit" class="headerlink" title=".digit"></a>.digit</h3><p>元字符<code>/d</code>，匹配“0-9”中的任何数字</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .digit</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\d/</span><br></pre></td></tr></table></figure>

<h3 id="nonDigit"><a href="#nonDigit" class="headerlink" title=".nonDigit"></a>.nonDigit</h3><p>元字符<code>/D</code>，匹配任何非数字</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .nonDigit</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\D/</span><br></pre></td></tr></table></figure>

<h3 id="word"><a href="#word" class="headerlink" title=".word"></a>.word</h3><p>元字符<code>/w</code>，匹配任何字母数字（<code>a-z，a-z，0-9</code>）字符以及<code>_</code>。</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .word</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\w/</span><br></pre></td></tr></table></figure>

<h3 id="nonWord"><a href="#nonWord" class="headerlink" title=".nonWord"></a>.nonWord</h3><p>元字符<code>/W</code>，匹配任何非字母数字（<code>a-z，a-z，0-9</code>）字符，也不包括<code>_</code></p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .nonWord</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\W/</span><br></pre></td></tr></table></figure>

<h3 id="wordBoundary"><a href="#wordBoundary" class="headerlink" title=".wordBoundary"></a>.wordBoundary</h3><p>立即匹配（不消耗任何字符）</p>
<p>在<a href="#word">.word</a>匹配的字符和<a href="#word">.word</a>不匹配的字符之间（以任何顺序）</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .digit</span><br><span class="line">  .wordBoundary</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\d\b/</span><br></pre></td></tr></table></figure>

<h3 id="nonWordBoundary"><a href="#nonWordBoundary" class="headerlink" title=".nonWordBoundary"></a>.nonWordBoundary</h3><p>在由[.word]（#word）匹配的两个字符之间的位置匹配（不消耗任何字符）。</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .digit</span><br><span class="line">  .nonWordBoundary</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\d\B/</span><br></pre></td></tr></table></figure>

<h3 id="newline"><a href="#newline" class="headerlink" title=".newline"></a>.newline</h3><p>元字符<code>\n</code>，匹配换行符</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .newline</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\n/</span><br></pre></td></tr></table></figure>

<h3 id="carriageReturn"><a href="#carriageReturn" class="headerlink" title=".carriageReturn"></a>.carriageReturn</h3><p>元字符<code>\r</code>，匹配回车符</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .carriageReturn</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\r/</span><br></pre></td></tr></table></figure>

<h3 id="tab"><a href="#tab" class="headerlink" title=".tab"></a>.tab</h3><p>元字符<code>\t</code>，匹配制表符</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .tab</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\t/</span><br></pre></td></tr></table></figure>

<h3 id="nullByte"><a href="#nullByte" class="headerlink" title=".nullByte"></a>.nullByte</h3><p>元字符<code>\0</code>，匹配空字符，null或\u0000(Unicode十六进制编码)</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .nullByte</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\<span class="number">0</span>/</span><br></pre></td></tr></table></figure>

<h3 id="anyOf"><a href="#anyOf" class="headerlink" title=".anyOf"></a>.anyOf</h3><p>匹配指定元素之间的选择。需要用“.end()”完成</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .anyOf</span><br><span class="line">    .range(<span class="string">'a'</span>, <span class="string">'f'</span>)</span><br><span class="line">    .range(<span class="string">'0'</span>, <span class="string">'9'</span>)</span><br><span class="line">    .string(<span class="string">'XXX'</span>)</span><br><span class="line">  .end()</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/(?:XXX|[a-f0<span class="number">-9</span>])/</span><br></pre></td></tr></table></figure>

<h3 id="capture"><a href="#capture" class="headerlink" title=".capture"></a>.capture</h3><p>为正在处理的元素创建一个捕获组。需要用“.end()”完成，之后用<a href="#backreferenceindex">backreference(index)</a>引用</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .capture</span><br><span class="line">    .range(<span class="string">'a'</span>, <span class="string">'f'</span>)</span><br><span class="line">    .range(<span class="string">'0'</span>, <span class="string">'9'</span>)</span><br><span class="line">    .string(<span class="string">'XXX'</span>)</span><br><span class="line">  .end()</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/([a-f][<span class="number">0</span><span class="number">-9</span>]XXX)/</span><br></pre></td></tr></table></figure>

<h3 id="namedCapture-name"><a href="#namedCapture-name" class="headerlink" title=".namedCapture(name)"></a>.namedCapture(name)</h3><p>为后续元素创建命名的捕获组。需要用“.end()”完成。以后可以用<a href="#namedBackreferencename">namedBackreference（name）</a>或<a href="#backreferenceindex">backreference（index）</a>引用。</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .namedCapture(<span class="string">'interestingStuff'</span>)</span><br><span class="line">    .range(<span class="string">'a'</span>, <span class="string">'f'</span>)</span><br><span class="line">    .range(<span class="string">'0'</span>, <span class="string">'9'</span>)</span><br><span class="line">    .string(<span class="string">'XXX'</span>)</span><br><span class="line">  .end()</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">interestingStuff</span>&gt;</span>[a-f][0-9]XXX)/</span></span><br></pre></td></tr></table></figure>

<h3 id="namedBackreference-name"><a href="#namedBackreference-name" class="headerlink" title=".namedBackreference(name)"></a>.namedBackreference(name)</h3><p>完全匹配之前由<a href="#namedCapturename">namedCapture</a>匹配的内容。</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .namedCapture(<span class="string">'interestingStuff'</span>)</span><br><span class="line">    .range(<span class="string">'a'</span>, <span class="string">'f'</span>)</span><br><span class="line">    .range(<span class="string">'0'</span>, <span class="string">'9'</span>)</span><br><span class="line">    .string(<span class="string">'XXX'</span>)</span><br><span class="line">  .end()</span><br><span class="line">  .string(<span class="string">'something else'</span>)</span><br><span class="line">  .namedBackreference(<span class="string">'interestingStuff'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/(?&lt;interestingStuff&gt;[a-f][0-9]XXX)something else\k&lt;interestingStuff&gt;/</span><br></pre></td></tr></table></figure>

<h3 id="backreference-index"><a href="#backreference-index" class="headerlink" title=".backreference(index)"></a>.backreference(index)</h3><p>使用位置索引精确匹配之前由<a href="#capture">capture</a>或<a href="#namedCapturename">namedCapture</a>匹配的内容。注意regex索引从1开始，因此第一个捕获组的索引为1。</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .capture</span><br><span class="line">    .range(<span class="string">'a'</span>, <span class="string">'f'</span>)</span><br><span class="line">    .range(<span class="string">'0'</span>, <span class="string">'9'</span>)</span><br><span class="line">    .string(<span class="string">'XXX'</span>)</span><br><span class="line">  .end()</span><br><span class="line">  .string(<span class="string">'something else'</span>)</span><br><span class="line">  .backreference(<span class="number">1</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/([a-f][<span class="number">0</span><span class="number">-9</span>]XXX)something <span class="keyword">else</span>\<span class="number">1</span>/</span><br></pre></td></tr></table></figure>

<h3 id="group"><a href="#group" class="headerlink" title=".group"></a>.group</h3><p>创建一个非捕获的处理元素组。需要用“.end()”完成。</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .optional.group</span><br><span class="line">    .range(<span class="string">'a'</span>, <span class="string">'f'</span>)</span><br><span class="line">    .range(<span class="string">'0'</span>, <span class="string">'9'</span>)</span><br><span class="line">    .string(<span class="string">'XXX'</span>)</span><br><span class="line">  .end()</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/(?:[a-f][<span class="number">0</span><span class="number">-9</span>]XXX)?<span class="regexp">/</span></span><br></pre></td></tr></table></figure>

<h3 id="end"><a href="#end" class="headerlink" title=".end()"></a>.end()</h3><p>表示SuperExpressive分组的结束，例如<a href="#anyOf">.anyOf</a>、<a href="#group">.group</a>或<a href="#capture">.capture</a></p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .capture</span><br><span class="line">    .anyOf</span><br><span class="line">      .range(<span class="string">'a'</span>, <span class="string">'f'</span>)</span><br><span class="line">      .range(<span class="string">'0'</span>, <span class="string">'9'</span>)</span><br><span class="line">      .string(<span class="string">'XXX'</span>)</span><br><span class="line">    .end()</span><br><span class="line">  .end()</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/((?:XXX|[a-f0<span class="number">-9</span>]))/</span><br></pre></td></tr></table></figure>

<h3 id="assertAhead"><a href="#assertAhead" class="headerlink" title=".assertAhead"></a>.assertAhead</h3><p>断言，在不使用进程元素的情况下找到它们。需要用“.end()”完成。</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .assertAhead</span><br><span class="line">    .range(<span class="string">'a'</span>, <span class="string">'f'</span>)</span><br><span class="line">  .end()</span><br><span class="line">  .range(<span class="string">'a'</span>, <span class="string">'z'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/(?=[a-f])[a-z]/</span><br></pre></td></tr></table></figure>

<h3 id="assertNotAhead"><a href="#assertNotAhead" class="headerlink" title=".assertNotAhead"></a>.assertNotAhead</h3><p>断言，在没有使用这些元素的情况下<strong>找不到</strong>。需要用“.end()”完成。</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .assertNotAhead</span><br><span class="line">    .range(<span class="string">'a'</span>, <span class="string">'f'</span>)</span><br><span class="line">  .end()</span><br><span class="line">  .range(<span class="string">'g'</span>, <span class="string">'z'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/(?![a-f])[g-z]/</span><br></pre></td></tr></table></figure>

<h3 id="optional"><a href="#optional" class="headerlink" title=".optional"></a>.optional</h3><p>断言，进程元素可能匹配，也可能不匹配</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .optional.digit</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\d?<span class="regexp">/</span></span><br></pre></td></tr></table></figure>

<h3 id="zeroOrMore"><a href="#zeroOrMore" class="headerlink" title=".zeroOrMore"></a>.zeroOrMore</h3><p>断言，进程元素可能不匹配，或者可能多次匹配。</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .zeroOrMore.digit</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\d*<span class="regexp">/</span></span><br></pre></td></tr></table></figure>

<h3 id="zeroOrMoreLazy"><a href="#zeroOrMoreLazy" class="headerlink" title=".zeroOrMoreLazy"></a>.zeroOrMoreLazy</h3><p>断言，进程元素可能不匹配，或者可能匹配多次，但要尽可能少</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .zeroOrMoreLazy.digit</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\d*?<span class="regexp">/</span></span><br></pre></td></tr></table></figure>

<h3 id="oneOrMore"><a href="#oneOrMore" class="headerlink" title=".oneOrMore"></a>.oneOrMore</h3><p>断言，进程元素可以匹配一次，也可以匹配多次</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .oneOrMore.digit</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\d+<span class="regexp">/</span></span><br></pre></td></tr></table></figure>

<h3 id="oneOrMoreLazy"><a href="#oneOrMoreLazy" class="headerlink" title=".oneOrMoreLazy"></a>.oneOrMoreLazy</h3><p>断言，继续元素可以匹配一次，也可以匹配多次，但要尽可能少</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .oneOrMoreLazy.digit</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\d+?<span class="regexp">/</span></span><br></pre></td></tr></table></figure>

<h3 id="exactly-n"><a href="#exactly-n" class="headerlink" title=".exactly(n)"></a>.exactly(n)</h3><p>断言，前一个元素将精确匹配“n”次</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .exactly(<span class="number">5</span>).digit</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\d&#123;<span class="number">5</span>&#125;/</span><br></pre></td></tr></table></figure>

<h3 id="atLeast-n"><a href="#atLeast-n" class="headerlink" title=".atLeast(n)"></a>.atLeast(n)</h3><p>断言，继续的元素将至少匹配“n”次</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .atLeast(<span class="number">5</span>).digit</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\d&#123;<span class="number">5</span>,&#125;/</span><br></pre></td></tr></table></figure>

<h3 id="between-x-y"><a href="#between-x-y" class="headerlink" title=".between(x, y)"></a>.between(x, y)</h3><p>断言，前一个元素将在“x”和“y”时间之间匹配</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .between(<span class="number">3</span>, <span class="number">5</span>).digit</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\d&#123;<span class="number">3</span>,<span class="number">5</span>&#125;/</span><br></pre></td></tr></table></figure>

<h3 id="betweenLazy-x-y"><a href="#betweenLazy-x-y" class="headerlink" title=".betweenLazy(x, y)"></a>.betweenLazy(x, y)</h3><p>断言，前一个元素将在“x”和“y”时间之间匹配，但要尽可能少地匹配。</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .betweenLazy(<span class="number">3</span>, <span class="number">5</span>).digit</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/\d&#123;<span class="number">3</span>,<span class="number">5</span>&#125;?<span class="regexp">/</span></span><br></pre></td></tr></table></figure>

<h3 id="startOfInput"><a href="#startOfInput" class="headerlink" title=".startOfInput"></a>.startOfInput</h3><p>使用<a href="#lineByLine">.lineByLine</a>时，断言输入的开始或行的开始</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .startOfInput</span><br><span class="line">  .string(<span class="string">'hello'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/^hello/</span><br></pre></td></tr></table></figure>

<h3 id="endOfInput"><a href="#endOfInput" class="headerlink" title=".endOfInput"></a>.endOfInput</h3><p>使用<a href="#lineByLine">.lineByLine</a>时，断言输入的结尾或行的结尾</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .string(<span class="string">'hello'</span>)</span><br><span class="line">  .endOfInput</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/hello$/</span><br></pre></td></tr></table></figure>

<h3 id="anyOfChars-chars"><a href="#anyOfChars-chars" class="headerlink" title=".anyOfChars(chars)"></a>.anyOfChars(chars)</h3><p>匹配提供的字符串“chars”中的任何字符</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .anyOfChars(<span class="string">'aeiou'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/[aeiou]/</span><br></pre></td></tr></table></figure>

<h3 id="anythingButChars-chars"><a href="#anythingButChars-chars" class="headerlink" title=".anythingButChars(chars)"></a>.anythingButChars(chars)</h3><p>匹配任何字符，但提供的字符串“chars”中的任何字符除外</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .anythingButChars(<span class="string">'aeiou'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/[^aeiou]/</span><br></pre></td></tr></table></figure>

<h3 id="anythingButString-str"><a href="#anythingButString-str" class="headerlink" title=".anythingButString(str)"></a>.anythingButString(str)</h3><p>匹配与“str”长度相同的任何字符串，但“str”中按顺序定义的字符除外</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .anythingButString(<span class="string">'aeiou'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/(?:[^a][^e][^i][^o][^u])/</span><br></pre></td></tr></table></figure>

<h3 id="anythingButRange-a-b"><a href="#anythingButRange-a-b" class="headerlink" title=".anythingButRange(a, b)"></a>.anythingButRange(a, b)</h3><p>匹配任何字符，但由“a”和“b”指定的<a href="#rangea-b">.range</a>捕获的字符除外</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .anythingButRange(<span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/[^<span class="number">0</span><span class="number">-9</span>]/</span><br></pre></td></tr></table></figure>

<h3 id="string-s"><a href="#string-s" class="headerlink" title=".string(s)"></a>.string(s)</h3><p>与字符串“s”完全匹配</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .string(<span class="string">'hello'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/hello/</span><br></pre></td></tr></table></figure>

<h3 id="char-c"><a href="#char-c" class="headerlink" title=".char(c)"></a>.char(c)</h3><p>与字符“c”完全匹配</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .char(<span class="string">'x'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/x/</span><br></pre></td></tr></table></figure>

<h3 id="range-a-b"><a href="#range-a-b" class="headerlink" title=".range(a, b)"></a>.range(a, b)</h3><p>匹配“a”和“b”之间的任何字符。排序由字符ASCII或unicode值定义</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .range(<span class="string">'a'</span>, <span class="string">'z'</span>)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/[a-z]/</span><br></pre></td></tr></table></figure>

<h3 id="subexpression-expr-opts"><a href="#subexpression-expr-opts" class="headerlink" title=".subexpression(expr, opts?)"></a>.subexpression(expr, opts?)</h3><ul>
<li>opts.命名空间，指在子表达式中的所有命名捕获组上使用字符串格式的命名空间，以避免与您自己命名的组发生命名冲突(默认=<code>&#39;&#39;</code>)</li>
<li>opts.忽略标志，如果设置为true，则应忽略此子表达式指定的任何标志(默认 = <code>true</code>)</li>
<li>opts.忽略开始和结束，如果设置为true，则应忽略此子表达式指定的任何startOfInput/endOfInput(默认 = <code>true</code>)</li>
</ul>
<p>匹配内联的另一个SuperExpressive实例。可用于创建库，或将代码模块化. 默认情况下，将忽略标志和输入标记的开始/结束, 但是可以在options对象中显式地打开</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A reusable SuperExpressive...</span></span><br><span class="line"><span class="keyword">const</span> fiveDigits = SuperExpressive().exactly(<span class="number">5</span>).digit;</span><br><span class="line"></span><br><span class="line">SuperExpressive()</span><br><span class="line">  .oneOrMore.range(<span class="string">'a'</span>, <span class="string">'z'</span>)</span><br><span class="line">  .atLeast(<span class="number">3</span>).anyChar</span><br><span class="line">  .subexpression(fiveDigits)</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/[a-z]+.&#123;<span class="number">3</span>,&#125;\d&#123;<span class="number">5</span>&#125;/</span><br></pre></td></tr></table></figure>

<h3 id="toRegexString"><a href="#toRegexString" class="headerlink" title=".toRegexString()"></a>.toRegexString()</h3><p>输出SuperExpression模型的正则表达式的字符串形式</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .allowMultipleMatches</span><br><span class="line">  .lineByLine</span><br><span class="line">  .startOfInput</span><br><span class="line">  .optional.string(<span class="string">'0x'</span>)</span><br><span class="line">  .capture</span><br><span class="line">    .exactly(<span class="number">4</span>).anyOf</span><br><span class="line">      .range(<span class="string">'A'</span>, <span class="string">'F'</span>)</span><br><span class="line">      .range(<span class="string">'a'</span>, <span class="string">'f'</span>)</span><br><span class="line">      .range(<span class="string">'0'</span>, <span class="string">'9'</span>)</span><br><span class="line">    .end()</span><br><span class="line">  .end()</span><br><span class="line">  .endOfInput</span><br><span class="line">  .toRegexString();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line"><span class="string">"/^(?:0x)?([A-Fa-f0-9]&#123;4&#125;)$/gm"</span></span><br></pre></td></tr></table></figure>

<h3 id="toRegex"><a href="#toRegex" class="headerlink" title=".toRegex()"></a>.toRegex()</h3><p>输出SuperExpression模型的正则表达式</p>
<p><strong>Example</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SuperExpressive()</span><br><span class="line">  .allowMultipleMatches</span><br><span class="line">  .lineByLine</span><br><span class="line">  .startOfInput</span><br><span class="line">  .optional.string(<span class="string">'0x'</span>)</span><br><span class="line">  .capture</span><br><span class="line">    .exactly(<span class="number">4</span>).anyOf</span><br><span class="line">      .range(<span class="string">'A'</span>, <span class="string">'F'</span>)</span><br><span class="line">      .range(<span class="string">'a'</span>, <span class="string">'f'</span>)</span><br><span class="line">      .range(<span class="string">'0'</span>, <span class="string">'9'</span>)</span><br><span class="line">    .end()</span><br><span class="line">  .end()</span><br><span class="line">  .endOfInput</span><br><span class="line">  .toRegex();</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">/^(?:<span class="number">0</span>x)?([A-Fa-f0<span class="number">-9</span>]&#123;<span class="number">4</span>&#125;)$/gm</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue插件封装一个video组件</title>
    <url>/2020/07/24/vue%E6%8F%92%E4%BB%B6%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAvideo%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>使用<code>@vue/cli-service-global</code>快速启动插件环境<br>codepen预览代码</p>
</blockquote>
<a id="more"></a>

<p>关于cli-service-global这个工具，是在面试线上做题时遇到的，配合vue/cli启动环境写两个功能，可以快速安装&amp;启动原型开发环境，本文是基于video.js对<code>&lt;video&gt;</code>进行封装，并由于长代码贴出来没有一i是，故放于code上展示</p>
<hr>
<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line">npm install -g @vue/cli-service-global</span><br><span class="line"></span><br><span class="line">npm install -S video.js</span><br><span class="line">npm install -S videojs-markers</span><br></pre></td></tr></table></figure>

<p>入口文件是index.js/main.js/app.vue/App.vue</p>
<p>vue serve 启动,或者vue serve xxx.vue<br>vue build 打包,或者vue build xxx.vue</p>
<ul>
<li>/目录/<ul>
<li>package.json</li>
<li>App.vue</li>
<li>test.vue</li>
<li>/assets/<ul>
<li>image&amp;video</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="codepen"><a href="#codepen" class="headerlink" title="codepen"></a>codepen</h2><p>众所周知，codepen是一款展示html/css/js的分(she)享(jiao)工(ruan)具(jian)</p>
<p>那如何放vue代码呢</p>
<p>没有搜索到相关方法，良久 未解，只好一个个点进去看，终于：</p>
<p>左侧explore探索下的topics话题，选择vue，Open Vue Editor</p>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>进入了<code>https://codepen.io/pen/editor/vue</code>，美滋滋，代码略长就可以直接放codepen上了<br>（关闭result面版）</p>
<iframe id="cp_embed_XWXGxYK" src="//codepen.io/gitby-leo/embed/XWXGxYK?height=456&theme-id=dark&slug-hash=XWXGxYK&default-tab=css,js,result&embed-version=2" scrolling="no" frameborder="no" height="456" allowTransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>暂时还未在codepen上找到多文件的预览方式，就继续贴代码吧（关闭result查看效果）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件test.vue</span><br><span class="line">&lt;video-player</span><br><span class="line">    ref&#x3D;&quot;video&quot;</span><br><span class="line">    :src&#x3D;&quot;videoSrc&quot;</span><br><span class="line">    type&#x3D;&quot;video&#x2F;mp4&quot;</span><br><span class="line">    :options&#x3D;&quot;videoOptions&quot;</span><br><span class="line">    :markers&#x3D;&quot;videoMarkers&quot;</span><br><span class="line">    webkit-playsinline&#x3D;&quot;true&quot;</span><br><span class="line">&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">import VideoPlayer from &quot;.&#x2F;App.vue&quot;;</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      videoSrc: videoMp4,</span><br><span class="line">      videoOptions: &#123;</span><br><span class="line">        autoplay: false,</span><br><span class="line">        controls: true,</span><br><span class="line">        poster: posterJpg</span><br><span class="line">      &#125;,</span><br><span class="line">      videoMarkers: &#123;</span><br><span class="line">        markers: [</span><br><span class="line">          &#123;</span><br><span class="line">            time: 10,</span><br><span class="line">            text: &quot;点位一&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            time: 20,</span><br><span class="line">            text: &quot;点位二&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    videoBtnHandler(type) &#123;</span><br><span class="line">      console.log(type);</span><br><span class="line">      this.$refs.video.player[type] &amp;&amp; this.$refs.video.player[type]();</span><br><span class="line">    &#125;,</span><br><span class="line">    changeVideo() &#123;</span><br><span class="line">      this.$refs.video.player[&quot;src&quot;] &amp;&amp;</span><br><span class="line">        this.$refs.video.player[&quot;src&quot;](videoMp42);</span><br><span class="line">    &#125;,</span><br><span class="line">    changeVideo2() &#123;</span><br><span class="line">      this.videoSrc &#x3D; videoMp42;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺少预览是因为codepen 要pro高级版才可以上传，基本是基于video.js的功能做了封装到vue</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>GrowingIO用户行为分析工具</title>
    <url>/2020/07/23/GrowingIO%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<blockquote>
<p>关于GrowingIO工具</p>
</blockquote>
<a id="more"></a>

<p>虽然之前工作内容涉及很多埋点事件，也写过简单的手动埋点脚本，但一直没有系统了解过埋点工具里能做什么，涉及的专有名词都是什么意思，这次了解 GrowingIO 时就做个记录吧</p>
<hr>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>核心：<code>用户</code>、<code>行为</code>、<code>分析</code></p>
<h3 id="用户模型"><a href="#用户模型" class="headerlink" title="用户模型"></a>用户模型</h3><p>不同的分析场景，需要不同的模型进行处理</p>
<h4 id="访问用户"><a href="#访问用户" class="headerlink" title="访问用户"></a>访问用户</h4><p>终端 生成 唯一标识 ID，<code>一个终端关联一个用户</code>的行为，可以理解为 openid</p>
<p>清除缓存或卸载后会更新此类 id</p>
<ul>
<li>四种 sdk<ul>
<li>web:<ul>
<li>存储到 Cookie/Storage</li>
<li>uuid 通用唯一标识符</li>
</ul>
</li>
<li>ios:【文档说依次获取？这是对于访客】<ul>
<li>存储到 keychain ios 的密码管理系统中</li>
<li>IDFA 苹果官方唯一允许广告获取用户的信息,每次打开关闭都会更新，无法追踪个人信息，不可用于识别用户</li>
<li>IDFV 一台设备中同一个应用厂商的 app 标识符 IDFV 相同，如果用户卸载了而不是删除同一厂商的所有 app，并重新安装，IDFV 会改变，同一厂商的生产版本 app 和开发版本 app 的 IDFV 也不同</li>
<li>GUID 全球唯一标识符，广泛用于微软的平台，ios 应该也有自己的一套格式</li>
</ul>
</li>
<li>android:<ul>
<li>MD5 加密后将之存储至设备本地文件系统</li>
<li>Android ID 有 5 种， IMEI 设备串号，MAC 地址，SIM ID 手机卡唯一标识，Android id 每次系统初始化后的 id，Serial Number 序列号</li>
<li>IMEI</li>
<li>UUID</li>
</ul>
</li>
<li>mini<ul>
<li>存储到 Cookie/Storage</li>
<li>UUID</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="登录用户"><a href="#登录用户" class="headerlink" title="登录用户"></a>登录用户</h4><p>数据库 保存 唯一标识 ID，登录注册后用于跨平台之间的身份识别，<code>多个终端关联一个用户</code>的行为，可以理解为 unionid</p>
<p>用于分析多端用户注册、访问频率、事件行为等用户属性&amp;行为分析</p>
<h4 id="用户属性"><a href="#用户属性" class="headerlink" title="用户属性"></a>用户属性</h4><p>id 只能满足用户数量的分析，需要拆分某一个用户的属性、特征分析用户行为</p>
<ul>
<li>登录用户属性<ul>
<li>用户基本信息</li>
<li>分类</li>
<li>标签</li>
</ul>
</li>
<li>访问用户属性<ul>
<li>匿名用户，如未登录时的小程序</li>
</ul>
</li>
</ul>
<h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><h4 id="什么是事件"><a href="#什么是事件" class="headerlink" title="什么是事件"></a>什么是事件</h4><p>统计和分析用户行为的记录</p>
<p>用户、时间、行为、行为作用的对象</p>
<p>用户-&gt; 访问 -&gt; 页面 -&gt; 动作， 这样导出为树形层级直观可见</p>
<h5 id="访问事件"><a href="#访问事件" class="headerlink" title="访问事件"></a>访问事件</h5><ul>
<li>用户设备信息<ul>
<li>操作系统及版本、设备品牌、设备型号、设备类型（手机/平板）、设备制造商、浏览器及版本、系统语言、屏幕大小、设备方向</li>
</ul>
</li>
<li>用户位置信息<ul>
<li>国家、地区、城市名称、国家代码</li>
</ul>
</li>
<li>用户访问的应用信息<ul>
<li>应用平台、App 版本</li>
</ul>
</li>
<li>页面信息<ul>
<li>域名、页面</li>
<li>访问来源、页面来源</li>
</ul>
</li>
</ul>
<h5 id="页面事件"><a href="#页面事件" class="headerlink" title="页面事件"></a>页面事件</h5><ul>
<li>域名/包名</li>
<li>页面 url</li>
<li>页面来源</li>
</ul>
<h5 id="动作事件"><a href="#动作事件" class="headerlink" title="动作事件"></a>动作事件</h5><ul>
<li>用户点击元素、浏览元素、提交表单、元素位置</li>
</ul>
<h4 id="埋点事件"><a href="#埋点事件" class="headerlink" title="埋点事件"></a>埋点事件</h4><p>写对应代码，通过触发 sdk 提供的 api 上报数据</p>
<p>客户端埋点、服务端埋点</p>
<h4 id="无埋点事件"><a href="#无埋点事件" class="headerlink" title="无埋点事件"></a>无埋点事件</h4><p>不写代码，捕获用户行为，通过 sdk 自动采集生成的事件</p>
<ul>
<li>比如监听如下事件<ul>
<li>page 事件 切换页面时</li>
<li>vst 事件 新的访问时</li>
<li>activate 事件 当 App 首次激活打开时</li>
<li>reengage 事件 由 GrowingIO Deep Link 唤醒 App 时</li>
<li>click 事件 当用户对 App 上的可点击元素有点击行为时</li>
<li>change 事件 当用户对 App 上的输入元素有改变的行为时<br>imp 事件 当有元素展现时</li>
</ul>
</li>
</ul>
<h3 id="统计模型"><a href="#统计模型" class="headerlink" title="统计模型"></a>统计模型</h3><h4 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h4><p>用来统计事件的量</p>
<ul>
<li>预定义指标:访问量、浏览量</li>
<li>无埋点指标：页面点击或元素点击</li>
<li>埋点指标：订单金额</li>
</ul>
<h4 id="维度"><a href="#维度" class="headerlink" title="维度"></a>维度</h4><p>用于分解、过滤以及对比指标的角度、属性</p>
<p>网址浏览量 5000 次，分解为 ie 和 chrome 不同的浏览量</p>
<ul>
<li>从高到低<ul>
<li>访问级维度</li>
<li>页面级维度</li>
<li>动作级维度<ul>
<li>无埋点事件维度</li>
<li>埋点事件维度</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>维度的层级关系，高维度用于分解低维度事件的指标，</p>
<h4 id="预定义指标"><a href="#预定义指标" class="headerlink" title="预定义指标"></a>预定义指标</h4><blockquote>
<p>用户级指标</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">用户级指标</th>
<th align="center">用户总量统计</th>
</tr>
</thead>
<tbody><tr>
<td align="center">访问量</td>
<td align="center">访问用户的数量</td>
</tr>
<tr>
<td align="center">新访问量</td>
<td align="center">一年内的访问用户的数量</td>
</tr>
<tr>
<td align="center">登录量</td>
<td align="center">登录用户的数量</td>
</tr>
<tr>
<td align="center">新登录量</td>
<td align="center">第一次登录用户的数量</td>
</tr>
</tbody></table>
<blockquote>
<p>访问级指标</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">访问级指标</th>
<th align="center">衡量网站总体访问情况</th>
</tr>
</thead>
<tbody><tr>
<td align="center">访问量</td>
<td align="center">访问的数量/次数</td>
</tr>
<tr>
<td align="center">每次访问页面浏览量</td>
<td align="center">每次访问浏览的页面的数量 <br> = <code>页面浏览量/访问量</code></td>
</tr>
<tr>
<td align="center">人均访问页数</td>
<td align="center">每次访问浏览的页面的数量 <br> = <code>页面浏览量/访问量</code></td>
</tr>
<tr>
<td align="center">人均访问次数</td>
<td align="center">每个用户实际浏览网页数 <br> = <code>页面浏览量/用户量</code></td>
</tr>
<tr>
<td align="center">总访问时长</td>
<td align="center">所有访问的总时长，分钟为单位，排除小于 1s 和大于 1 天，排除 web 端最后页面的访问时长</td>
</tr>
<tr>
<td align="center">平均访问时长</td>
<td align="center">每次访问时长 <br> = <code>总访问时长/访问量</code></td>
</tr>
<tr>
<td align="center">人均访问时长</td>
<td align="center">每个用户的访问时长 <br> = <code>总访问时长/用户量</code></td>
</tr>
<tr>
<td align="center">退出次数</td>
<td align="center">该页面作为用户一次访问中的最后一个页面的访问的次数</td>
</tr>
<tr>
<td align="center">退出率</td>
<td align="center">该页面作为退出页的次数，占这个页面被访问的总体数量的比例 <br> = <code>退出次数/访问量</code></td>
</tr>
<tr>
<td align="center">总页面停留时长</td>
<td align="center">当前页面上停留的总时长，不统计停留时长大于 3 个小时的页面</td>
</tr>
<tr>
<td align="center">平均页面停留时长</td>
<td align="center">当前页面上停留的平均时长 <br> = <code>总页面停留时长/（页面浏览量-退出次数）</code></td>
</tr>
<tr>
<td align="center">进入量</td>
<td align="center">访问用户进入网站的数量。</td>
</tr>
<tr>
<td align="center">访问用户人均进入次数</td>
<td align="center">每个访问用户进入网站/小程序进行访问的数量 <br> = <code>进入量/访问用户量</code></td>
</tr>
<tr>
<td align="center">总进入时长</td>
<td align="center">该页面作为用户一次访问中的第一个页面的访问的时长，以分钟作为单位</td>
</tr>
<tr>
<td align="center">平均进入时长</td>
<td align="center">每次进入网站/小程序进行访问的平均时长 <br> = <code>总进入时长/进入量</code></td>
</tr>
<tr>
<td align="center">每次进入页面浏览量</td>
<td align="center">每次进入带来的页面浏览的数量 <br> = <code>进入总页面浏览量/进入量</code></td>
</tr>
<tr>
<td align="center">跳出次数</td>
<td align="center">访问一个页面就离开的次数,一次访问中只访问了一个页面</td>
</tr>
<tr>
<td align="center">跳出率</td>
<td align="center">只有一个页面浏览的访问占所有访问的比率 <br> = <code>跳出次数/进入量</code></td>
</tr>
</tbody></table>
<blockquote>
<p>页面级指标</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">衡量页面的访问情况</th>
</tr>
</thead>
<tbody><tr>
<td align="center">页面浏览量</td>
<td align="center">用户实际浏览过的网页数量</td>
</tr>
<tr>
<td align="center">通过圈选定义的页面浏览量</td>
<td align="center">定义一个/一组页面的浏览量</td>
</tr>
</tbody></table>
<blockquote>
<p>事件级指标</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">事件级指标</th>
<th align="center">可以通过圈选和创建自定义事件来实现</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通过圈选定义的元素指标化后</td>
<td align="center">标化为“该元素点击（浏览）的人数或次数</td>
</tr>
<tr>
<td align="center">自定义事件</td>
<td align="center">埋点创建的自定义事件</td>
</tr>
</tbody></table>
<h4 id="预定义维度"><a href="#预定义维度" class="headerlink" title="预定义维度"></a>预定义维度</h4><blockquote>
<p>用户来源维度</p>
</blockquote>
<p>.</p>
<blockquote>
<blockquote>
<p>访问来源（Web）‌</p>
</blockquote>
</blockquote>
<p>通过用户来源了解用户是怎样来到你的网站上的</p>
<table>
<thead>
<tr>
<th align="center">访问来源具体值</th>
<th align="center">场景</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">微信 - 公众号</td>
<td align="center">公众号中查看图文消息-点击“阅读原文”</td>
<td align="center">微信会返回“公众号”访问来源链接，即可以判断出公众号的来源。</td>
</tr>
<tr>
<td align="center">微信-朋友圈</td>
<td align="center">朋友圈里查看分享的页面类链接</td>
<td align="center">参数判断为朋友圈打开。</td>
</tr>
<tr>
<td align="center">微信-群聊</td>
<td align="center">查看分享给群组的页面链接</td>
<td align="center">参数判断为群组信息中打开。</td>
</tr>
<tr>
<td align="center">微信-好友</td>
<td align="center">查看分享给单个好友的页面链接</td>
<td align="center">参数判断为好友信息中打开。</td>
</tr>
<tr>
<td align="center">微信-二维码</td>
<td align="center">扫描二维码在微信中打开 H5 页面查看</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">微信-图文链接</td>
<td align="center">公众号直接给文字/图片链接，用户打开</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">微信-链接</td>
<td align="center">打开分享到朋友圈、群聊、单聊消息中的 URL 链接</td>
<td align="center">如果仅是 URL，只会追踪具体的 URL，但可以识别在微信环境中打开。</td>
</tr>
</tbody></table>
<blockquote>
<blockquote>
<p>一级访问来源</p>
</blockquote>
</blockquote>
<p>直接访问、搜索引擎、社交媒体、视频媒体、新闻媒体、外部链接</p>
<ul>
<li>直接访问<ul>
<li>直接在浏览器中输入了一个域名或使用书签进行访问</li>
<li>邮件中点击链接访问</li>
<li>从 Microsoft Office 或 PDF 文件中点击链接访问</li>
<li>短链接访问网站</li>
<li>App 点击链接访问</li>
<li>https 类型的 url 访问一个 http 类型的 url</li>
</ul>
</li>
<li>搜索引擎<ul>
<li>常见搜索百度、谷歌、必应啥的</li>
</ul>
</li>
<li>社交媒体<ul>
<li>微信、微博、知乎、以及境外社交媒体</li>
</ul>
</li>
<li>视频媒体<ul>
<li>腾讯视频、爱奇艺、优酷、b 站、斗鱼</li>
</ul>
</li>
<li>新闻媒体<ul>
<li>腾讯新闻、搜狐、头条</li>
</ul>
</li>
<li>外部链接<ul>
<li>除了以上的</li>
</ul>
</li>
</ul>
<blockquote>
<blockquote>
<p>搜索词</p>
</blockquote>
</blockquote>
<p>付费搜索的可以被解析</p>
<p>自然搜索的就不会被解析了</p>
<blockquote>
<blockquote>
<p>App 版本 &amp; App 渠道</p>
</blockquote>
</blockquote>
<p>.</p>
<blockquote>
<blockquote>
<p>广告监测</p>
</blockquote>
</blockquote>
<p>获取推广效果</p>
<p>UTM 渠道归因模式为非直接访问的最后一次访问</p>
<table>
<thead>
<tr>
<th align="center">UTM 参数</th>
<th align="center">使用方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">utm_source</td>
<td align="center">广告来源</td>
</tr>
<tr>
<td align="center">utm_medium</td>
<td align="center">广告媒介,CPC、Banner、EDM</td>
</tr>
<tr>
<td align="center">utm_campaign</td>
<td align="center">广告名称</td>
</tr>
<tr>
<td align="center">utm_term</td>
<td align="center">广告关键词</td>
</tr>
<tr>
<td align="center">utm_content</td>
<td align="center">广告内容</td>
</tr>
</tbody></table>
<blockquote>
<p>地域信息维度</p>
</blockquote>
<p>了解用户在哪里访问你的网站</p>
<table>
<thead>
<tr>
<th align="center">维度</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">城市名称</td>
<td align="center">GPS 或 ip 以城市作为维度值</td>
</tr>
<tr>
<td align="center">地区名称</td>
<td align="center">GPS 或 ip 包含国内省级以上行政区，以及国外地区</td>
</tr>
<tr>
<td align="center">国家代码</td>
<td align="center">英文缩写</td>
</tr>
<tr>
<td align="center">国家名称</td>
<td align="center">中文名称</td>
</tr>
<tr>
<td align="center">微信用户所在城市、省、国</td>
<td align="center">小程序特有维度</td>
</tr>
</tbody></table>
<blockquote>
<p>设备信息维度</p>
</blockquote>
<p>了解用户使用说明设备访问你的网站</p>
<blockquote>
<p>其他维度</p>
</blockquote>
<p>域名、页面、来源、元素内容、元素位置、 时间</p>
<h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>保存跟用户本身相关的信息</p>
<p>不要在用户变量中保存跟交互行为相关的信息，比如商品，可以使用页面级变量和转化变量来保存</p>
<p>登录用户变量用来保存跟登录用户本身相关的信息，例如用户的姓名，性别，会员卡等级等等</p>
<p>访问用户变量用来保存用户在非登录情况下跟用户本身相关的信息，例如用户的性别、A/B 测试分组等等</p>
<blockquote>
<p>归因模型</p>
</blockquote>
<p>比如银卡会员升级到了金卡后，他的后续行为事件归到登录用户变量中的哪一个值上</p>
<ul>
<li>最近<ul>
<li>离事件发生的时间最近的值，一段时间内的分配给银卡</li>
</ul>
</li>
<li>最终<ul>
<li>最终设置的值，归为金卡</li>
</ul>
</li>
</ul>
<h4 id="页面级变量"><a href="#页面级变量" class="headerlink" title="页面级变量"></a>页面级变量</h4><p>仅在当前页面内，作为维度，实际上就看产品或者看页面数据</p>
<ul>
<li>各个不同板块页面的用户访问情况分析，使用页面级变量保存页面所属板块的名称。</li>
<li>各个不同子站点的用户访问情况分析，使用页面级变量保存页面所属子站点的名称。</li>
<li>各个不同类型页面的用户访问情况分析，使用页面级变量保存页面所属的类型名称。例如功能引导页面，购物流程页面等。</li>
</ul>
<h4 id="埋点事件和事件级变量"><a href="#埋点事件和事件级变量" class="headerlink" title="埋点事件和事件级变量"></a>埋点事件和事件级变量</h4><blockquote>
<p>数据规划</p>
</blockquote>
<p>将数据需求转化为具体的“指标+维度”</p>
<p>对于电商在分析用户下单情况时，用户的下单量就是我们需要量化的“指标”，而每个订单所含具体商品、商品分类、优惠券信息、下单金额等就是“维度”</p>
<p>指标：订单总量<br>维度：商品 ID/名称、商品 SKU、优惠券名称、收货地址、下单金额</p>
<blockquote>
<p>转化变量</p>
</blockquote>
<p>转化变量是一种强大的变量类型，可以根据不同的业务需求去配置一个转化变量的归因方式和持久性范围。随着归因模型的不同，持久性范围的不同，用户发生的事件将会归到或者不归到某一个转化变量的值上。</p>
<blockquote>
<p>归因方式</p>
</blockquote>
<ul>
<li>最近<ul>
<li>当事件发生时，往前看，事件所有的权重将全部分配给转化变量中还在持久性范围之内并且离事件发生的时间点最近的值上</li>
</ul>
</li>
<li>线性<ul>
<li>当事件发生时，往前看，事件所有的权重将平均分配所有还在持久性范围之内，还没有失效的那些值上。</li>
</ul>
</li>
<li>最初<ul>
<li>当事件发生时，往前看，事件所有的权重将全部分配给转化变量中还在持久性范围之内并且离事件发生的时间点最远的那个值上。从用户的角度来说也就是还在持久性范围之内的最初的那个值获得发生事件的所有权重。</li>
</ul>
</li>
</ul>
<p>.</p>
<ul>
<li>使用最初归因模型，某个内部活动带来了多少注册，多少订单。</li>
<li>使用线性归因模型，内部搜索的效果怎样，某个具体的搜索词带来了多少订单，营业收入。</li>
<li>使用最近归因模型，同一个内部活动的不同入口分别带来了多少内部活动详情页面的浏览</li>
</ul>
<h2 id="产品分析"><a href="#产品分析" class="headerlink" title="产品分析"></a>产品分析</h2><h3 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h3><h3 id="漏斗分析"><a href="#漏斗分析" class="headerlink" title="漏斗分析"></a>漏斗分析</h3><h3 id="留存分析"><a href="#留存分析" class="headerlink" title="留存分析"></a>留存分析</h3><h3 id="分布分析"><a href="#分布分析" class="headerlink" title="分布分析"></a>分布分析</h3><h3 id="热图分析"><a href="#热图分析" class="headerlink" title="热图分析"></a>热图分析</h3><!-- https://docs.growingio.com/docs/product-manual/product-analysis/ -->









]]></content>
      <categories>
        <category>data analytic</category>
      </categories>
      <tags>
        <tag>data analytic</tag>
      </tags>
  </entry>
  <entry>
    <title>css控制动画播放暂停</title>
    <url>/2020/07/21/css%E6%8E%A7%E5%88%B6%E5%8A%A8%E7%94%BB%E6%92%AD%E6%94%BE%E6%9A%82%E5%81%9C/</url>
    <content><![CDATA[<blockquote>
<p>animation-play-state</p>
</blockquote>
<a id="more"></a>

<p>不需要用js，用css也能实现的效果</p>
<hr>
<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>animation-play-state<br>-webkit-animation-play-state<br>属性指定动画是正在运行还是暂停</p>
<p>paused / running</p>
<p>兼容ie10,但是不建议简写进animation属性中</p>
<h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><p>实现鼠标hover时的元素播放动画，取消hover后暂停</p>
<p><a href="https://codepen.io/gitby-leo/pen/oNbJKOw" target="_blank" rel="noopener">codepen</a></p>
<iframe id="cp_embed_oNbJKOw" src="//codepen.io/gitby-leo/embed/oNbJKOw?height=456&theme-id=dark&slug-hash=oNbJKOw&default-tab=css,js,result&embed-version=2" scrolling="no" frameborder="no" height="456" allowTransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe>


<h2 id="关于-active-amp-命名规范"><a href="#关于-active-amp-命名规范" class="headerlink" title="关于.active &amp; 命名规范"></a>关于.active &amp; 命名规范</h2><p>分离、无侵入、控制关系明确</p>
<ul>
<li>无侵入定位<ul>
<li>不使用keyframes决定初始位置</li>
<li>不使用keyframes中出现的属性定位</li>
</ul>
</li>
<li>居中定位准则<ul>
<li>元素定位在容器中间</li>
<li>定位方式为居中定位</li>
</ul>
</li>
</ul>
<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#aabbcc</span>;</span></span><br><span class="line">        animation-play-state: running;</span><br><span class="line">    &#125;</span><br><span class="line">    div &#123;</span><br><span class="line">        margin: 50px auto;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line">        animation: move 1s linear, rotate 2s linear infinite;</span><br><span class="line">        animation-fill-mode: forwards;</span><br><span class="line">        animation-play-state: paused;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-tag">div</span><span class="selector-pseudo">:active</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#eee</span>;</span></span><br><span class="line">        animation-play-state: running;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> move &#123;</span></span><br><span class="line">        100% &#123;</span><br><span class="line">            transform: translate(200px, 0) rotate(180deg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> rotate &#123;</span></span><br><span class="line">        100% &#123;</span><br><span class="line">            transform: translate(200px, 0) rotate(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>git提交规范</title>
    <url>/2020/07/20/git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<blockquote>
<p>规范的git信息在多人共同协作开发项目时很有帮助<br>commitizen工具用于规范提交信息</p>
</blockquote>
<a id="more"></a>

<p>分支命名，个人习惯：feature/需求_昵称</p>
<ul>
<li>feat： 新增一个功能</li>
<li>fix: 修复bug</li>
<li>style: 仅仅修改了空格、格式缩进等等，不改变代码逻辑</li>
<li>docs: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等</li>
<li>test: 测试用例，包括增加缺失用例或者修正测试用例</li>
<li>perf: 优化相关，比如提升性能、体验</li>
<li>refactor: 代码重构，没有加新功能或者修复bug</li>
</ul>
<h2 id="commitizen"><a href="#commitizen" class="headerlink" title="commitizen"></a>commitizen</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">commitizen</span> <span class="string">-D</span> <span class="comment"># 提交时填写所有必需的提交字段</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">cz-conventional-changelog</span> <span class="string">-D</span> <span class="comment"># 用来规范提交信息</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">-S</span> <span class="string">conventional-changelog-cli</span> <span class="comment"># 从git metadata生成变更日志</span></span><br></pre></td></tr></table></figure>

<p>在package.json中添加命令</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>:&#123;</span><br><span class="line">        <span class="attr">"commit"</span>: <span class="string">"git-cz"</span>, <span class="comment">// 替换git commit -m.</span></span><br><span class="line">        <span class="attr">"genlog"</span>: <span class="string">"conventional-changelog -p angular -i CHANGELOG.md -s"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"config"</span>:&#123;</span><br><span class="line">        <span class="attr">"commitizen"</span>:&#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"./node_modules/cz-conventional-changelog"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="规范提交文案"><a href="#规范提交文案" class="headerlink" title="规范提交文案"></a>规范提交文案</h2><p><code>npm run commit</code></p>
<p>每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>包括三个字段：type（必需）、scope（可选）和subject（必需）</p>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>类型feat/fix/test等</p>
<h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><p>说明 commit 影响的范围，比如数据层、控制层、视图层等等</p>
<h4 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h4><p>commit 目的的简短描述，不超过50个字符，动词开头</p>
<h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>详细描述，可以分成多行</p>
<h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><ul>
<li>不兼容变动，理由和方法</li>
<li>关闭 Issue：Closes #234</li>
</ul>
<h2 id="生成日志"><a href="#生成日志" class="headerlink" title="生成日志"></a>生成日志</h2><p><code>npm run genlog</code></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Marp用markdown制作PPT</title>
    <url>/2020/07/19/Marp%E7%94%A8markdown%E5%88%B6%E4%BD%9CPPT/</url>
    <content><![CDATA[<blockquote>
<p>Marp -&gt; ppt/pdf/html -&gt; with markdown</p>
</blockquote>
<a id="more"></a>

<p>最近需要搞一个技术分享，ppt的风格比较多，发现强大的md语法也能够生成ppt，就试试这种极简风格吧</p>
<p>下面是语法示例<br><code>xx.md</code>内容为之前博客文章内容</p>
<hr>
<h2 id="安装Marp-for-VS-Code插件"><a href="#安装Marp-for-VS-Code插件" class="headerlink" title="安装Marp for VS Code插件"></a>安装<code>Marp for VS Code</code>插件</h2><p>文件顶部必须有<code>marp: true</code>用于识别</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">marp: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>每页通过<code>---</code>分割，vscode编辑器通过按钮导出预览格式</p>
<ul>
<li>文件大小<ul>
<li>a.md    65kb(不含图片)</li>
<li>a.html  4kb(不含图片)</li>
<li>a.pdf   318kd(含图片)</li>
<li>a.ppt   240kb(含图片)</li>
</ul>
</li>
</ul>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">marp: true</span><br><span class="line">style: |</span><br><span class="line">  section &#123;&#125;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- Global style --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line">section.sectionEnd &#123;</span><br><span class="line"><span class="code">    align-items: center;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- paginate: true--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _header: 技术分享 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _footer: - --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># 技术分享——搭建Jenkins</span></span><br><span class="line"></span><br><span class="line">Leo</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _header: 关于部署 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- class: section0 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- footer: Powered By [Marp][Marp] --&gt;</span></span></span><br><span class="line"><span class="section">## 关于前端部署</span></span><br><span class="line"></span><br><span class="line">之前开发时部署采用的是手动打包，上传服务器的方式</span><br><span class="line"></span><br><span class="line">加入公司后，看到技术团队用的是自动化部署，即更新master分支后自动编译发布</span><br><span class="line"></span><br><span class="line">本次介绍前端如何结合Jenkins进行自动化部署</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _header: Jenkins介绍 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- class: section1 --&gt;</span></span></span><br><span class="line"><span class="section">## Jenkins介绍</span></span><br><span class="line"></span><br><span class="line">CI持续集成 - 自动检测源代码、拉取、构建的过程，减少集成问题</span><br><span class="line">CD持续部署 - 随时推向生产环境，降低每次发布的风险，快速迭代</span><br><span class="line"></span><br><span class="line">Jenkins是一个CI工具，简化部署工作流程，丰富的插件生态，可视化的界面配置</span><br><span class="line"></span><br><span class="line">其他还有很多CI/CD工具可用于不同场景下</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _header: 环境准备 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- class: section2 --&gt;</span></span></span><br><span class="line"><span class="section">## 环境准备</span></span><br><span class="line"></span><br><span class="line"><span class="code">`Github/Gitlab`</span>、<span class="code">`Centos ECS`</span>、<span class="code">`Jnkins`</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- ```cmd --&gt;</span></span></span><br><span class="line">$ yum install java  # 安装依赖</span><br><span class="line">$ yum install jenkins # 安装jenkins</span><br><span class="line">$ service jenkins start # 启动jenkins</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- ``` --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>访问server ip:8080</span><br><span class="line"><span class="bullet">- </span>初始化jenkins并安装通用插件</span><br><span class="line"><span class="bullet">- </span>配置完成后如右图</span><br><span class="line">![<span class="string">bg right:40%</span>][<span class="symbol">login</span>]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _header: 环境准备 --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">## 安装插件</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Rebuilder 用于重新执行构建命令</span><br><span class="line"><span class="bullet">- </span>SafeRestart 用于重启</span><br><span class="line"><span class="bullet">- </span>Webhook 触发器</span><br><span class="line"><span class="bullet">- </span>Publish Over SSH 登录目标服务器</span><br><span class="line"><span class="bullet">- </span>配置前端需要的node版本</span><br><span class="line"></span><br><span class="line">![<span class="string">bg vertical right 90%</span>][<span class="symbol">ManagePlugins</span>]</span><br><span class="line">![<span class="string">bg right 90%</span>][<span class="symbol">nodejs</span>]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _header: 环境准备 --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">## 创建任务</span></span><br><span class="line"></span><br><span class="line">创建任务后</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>关联 GitHub 仓库</span><br><span class="line"><span class="bullet">- </span>填写shell命令</span><br><span class="line"></span><br><span class="line">![<span class="string">bg vertical right 90%</span>][<span class="symbol">repository</span>]</span><br><span class="line">![<span class="string">bg right 90%</span>][<span class="symbol">build</span>]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _header: 环境准备 --&gt;</span></span></span><br><span class="line"><span class="section">## 自动部署</span></span><br><span class="line"></span><br><span class="line">通过Publish Over SSH插件实现连接服务器部署</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Source files 打包后的文件</span><br><span class="line"><span class="bullet">- </span>Remove prefix 删除的目录</span><br><span class="line"><span class="bullet">- </span>Remote directory 连接服务器的目录</span><br><span class="line"></span><br><span class="line">![<span class="string">bg vertical right 90%</span>][<span class="symbol">sshServerConfig</span>]</span><br><span class="line">![<span class="string">bg right 90%</span>][<span class="symbol">sshConfig</span>]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _header: 环境准备 --&gt;</span></span></span><br><span class="line"><span class="section">## Webhook</span></span><br><span class="line"></span><br><span class="line">Jenkins任务的构建触发器处填写自定义的token，用于和github的Webhook绑定</span><br><span class="line"></span><br><span class="line">再次提交代码，可以看到页面触发了新的任务，正在执行，还可以查看执行进度的具体log信息</span><br><span class="line"></span><br><span class="line">至此就完成了Jenkins的配置</span><br><span class="line"></span><br><span class="line">![<span class="string">bg vertical right 90%</span>][<span class="symbol">webhooks</span>]</span><br><span class="line">![<span class="string">bg right 90%</span>][<span class="symbol">progress</span>]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _header: 回顾流程 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- class: section6 --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">## 回顾流程</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>push本地代码到远端仓库</span><br><span class="line"><span class="bullet">- </span>Webhook监听自动触发jenkins上的构建动作</span><br><span class="line"><span class="bullet">- </span>完成安装node依赖、打包</span><br><span class="line"><span class="bullet">- </span>通过Publish Over SSH插件，将打包出来的文件，部署到目标服务器上</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _header: 关于Marp --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _footer: '' --&gt;</span></span></span><br><span class="line"><span class="section">## 关于Marp</span></span><br><span class="line"></span><br><span class="line">左下角的页尾有个Marp，是vs code中支持md语法的PPT制作插件，支持导出html,pdf,pptx</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _paginate: false--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- _footer: '' --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- class: sectionEnd --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">## END</span></span><br><span class="line"></span><br><span class="line">[<span class="symbol">Marp</span>]:<span class="link">https://marp.app/</span></span><br><span class="line">[<span class="symbol">login</span>]:<span class="link">./Marp用markdown制作PPT/images/login.jpg</span></span><br><span class="line">[<span class="symbol">ManagePlugins</span>]:<span class="link">./Marp用markdown制作PPT/images/ManagePlugins.jpg</span></span><br><span class="line">[<span class="symbol">nodejs</span>]:<span class="link">./Marp用markdown制作PPT/images/nodejs.jpg</span></span><br><span class="line">[<span class="symbol">sshServerConfig</span>]:<span class="link">./Marp用markdown制作PPT/images/sshServerConfig.jpg</span></span><br><span class="line">[<span class="symbol">sshConfig</span>]:<span class="link">./Marp用markdown制作PPT/images/sshConfig.jpg</span></span><br><span class="line">[<span class="symbol">repository</span>]:<span class="link">./Marp用markdown制作PPT/images/repository.jpg</span></span><br><span class="line">[<span class="symbol">build</span>]:<span class="link">./Marp用markdown制作PPT/images/build.jpg</span></span><br><span class="line">[<span class="symbol">webhooks</span>]:<span class="link">./Marp用markdown制作PPT/images/webhooks.jpg</span></span><br><span class="line">[<span class="symbol">progress</span>]:<span class="link">./Marp用markdown制作PPT/images/progress.jpg</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>持续集成之Github Actions</title>
    <url>/2020/07/17/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BGithub%20Actions/</url>
    <content><![CDATA[<blockquote>
<p>持续集成是指代码提到到仓库后的所有：服务器编译、测试、打包、部署自动执行</p>
</blockquote>
<a id="more"></a>

<p>上次，写了一篇关于Jenkins的搭建流程，也实现了推送后的webhooks钩子响应并编译发布</p>
<p>而本篇介绍的Github Actions则是代替Jenkins手工搭建，并节省服务器资源的一种新方式</p>
<hr>
<!-- https://zhuanlan.zhihu.com/p/93829286
 -->

<h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>熟悉vuex/redux的童鞋一定不陌生这个词</p>
<ul>
<li><p>vuex中表示保存异步修改状态的方法</p>
</li>
<li><p>redux中表示触发store中的数据更新的唯一来源</p>
<p>而这里，每一个操作/脚本可以理解为一个action，叠加起来很多操作就是actions</p>
<p>github有一个<a href="https://github.com/marketplace?type=actions" target="_blank" rel="noopener">官方市场</a>可以让你的项目添加不同的action</p>
</li>
</ul>
<h2 id="创建action工作流"><a href="#创建action工作流" class="headerlink" title="创建action工作流"></a>创建action工作流</h2><p>在仓库的actions选项卡中, set up a workflow yourself</p>
<p>发布到github则需要 GitHub 密钥，在仓库的Settings/Secrets新建一个</p>
<ul>
<li><p>github提供的服务器</p>
<ul>
<li>2核 CPU</li>
<li>7GB RAM</li>
<li>14GB SSD</li>
</ul>
</li>
<li><p>执行结果</p>
<ul>
<li>runner: github 分配的用来执行 CI/CD 的构建服务器 (也可以自建 runner)</li>
<li>workflow: CI/CD 的工作流</li>
<li>job: 任务，比如构建，测试和部署。每个 workflow 由多个 job 组成</li>
<li>step: 每个 job 由多个 step 组成</li>
</ul>
</li>
</ul>
<h2 id="编写action"><a href="#编写action" class="headerlink" title="编写action"></a>编写action</h2><p>配置文件在仓库的.github/workflows目录下，格式为yaml，像hexo就是这种.yml啦</p>
<p>在new时可以直接选择nodejs的action,</p>
<p><a href="https://help.github.com/en/articles/workflow-syntax-for-github-actions" target="_blank" rel="noopener">配置字段</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">demo</span> <span class="comment"># 脚本名</span></span><br><span class="line"><span class="attr">on:</span>        <span class="comment"># 触发条件为推送到master分支</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="attr">jobs:</span>      <span class="comment"># 需要执行的动作</span></span><br><span class="line">  <span class="attr">build:</span>   <span class="comment"># 用ubuntu执行构建，uses是用了什么库</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">build</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xxx</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span></span><br></pre></td></tr></table></figure>

<h2 id="ssh自动登陆服务器打包"><a href="#ssh自动登陆服务器打包" class="headerlink" title="ssh自动登陆服务器打包"></a>ssh自动登陆服务器打包</h2><p>推送后，自动拉取最新代码打包</p>
<p><a href="https://github.com/appleboy/ssh-action" target="_blank" rel="noopener">自动模拟ssh登录</a></p>
<p>进入服务器，进入目录，拉取代码，打包，完成</p>
<hr>
<!-- ## 失败

找了几个示例试了下，github fail了

Workflows:
Run failed for master (xxxx) 失败了呀 -->
]]></content>
      <categories>
        <category>ci/cd</category>
      </categories>
      <tags>
        <tag>ci/cd</tag>
      </tags>
  </entry>
  <entry>
    <title>API接口设计攻略</title>
    <url>/2020/07/15/API%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<blockquote>
<p>前端业务需要怎么样的接口，如何保证交互安全</p>
</blockquote>
<a id="more"></a>

<p>本篇不是RESTful风格的描述，提供思路仅供参考</p>
<hr>
<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>防抓包不用多说</p>
<h2 id="格式规范JSON"><a href="#格式规范JSON" class="headerlink" title="格式规范JSON"></a>格式规范JSON</h2><p>对一个项目来说，统一格式的返回数据，前后端可以进行优雅抽象，简洁处理业务代码<br>对一个团队来说，统一格式，可以封装通用类，作为沉淀</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code:<span class="built_in">Number</span>,</span><br><span class="line">    data:<span class="built_in">Array</span> | <span class="built_in">Object</span>,</span><br><span class="line">    msg:<span class="built_in">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>访问令牌字符串，用于标识客户端的身份</p>
<p>服务端返回appid和key，(这里的客户端是指接口的请求方，服务端是指接口的处理方)，这个key需要保存到客户端，并作安全处理</p>
<p>举例抖音的signature，我还没找到是如何生成的（知道的小伙伴可以下方留言告诉我）</p>
<p>token作为key，关联信息作为value，缓存到redis中，当请求处理时检查token存在及过期时间，否则返回异常</p>
<h3 id="API-token-接口令牌"><a href="#API-token-接口令牌" class="headerlink" title="API token 接口令牌"></a>API token 接口令牌</h3><p>访问不需要登录的数据，比如登录注册，基本数据获取</p>
<p>通过appid、timestamp、sign来换token</p>
<h3 id="USER-toekn-用户令牌"><a href="#USER-toekn-用户令牌" class="headerlink" title="USER toekn 用户令牌"></a>USER toekn 用户令牌</h3><p>访问登录后的数据，用户信息，增删改</p>
<p>通过用户名、密码来换token</p>
<h3 id="时效性"><a href="#时效性" class="headerlink" title="时效性"></a>时效性</h3><ul>
<li>一次性<ul>
<li>调用后销毁</li>
</ul>
</li>
<li>过期时间<ul>
<li>20分钟~2小时</li>
</ul>
</li>
<li>过期后激活并续期<ul>
<li>用旧token请求，返回新token，延长过期时间，下次用新token</li>
</ul>
</li>
</ul>
<h2 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp"></a>timestamp</h2><p>接口调用时的客户端时间戳，缩短Dos攻击时间</p>
<p>服务端判断时间差或者解析sign在几分钟内通过，以外的拦截过滤掉</p>
<p>Dos是指利用网络协议层的缺陷，大量请求服务器资源、占用带宽、填充硬盘空间，导致服务器无法正常工作，直至停止响应崩溃</p>
<ul>
<li>简述Dos方式<ul>
<li>Pingflood Ping包，堵塞网络&amp;主机资源</li>
<li>Synflood SYN包，收到主机ACK不回应，建立维护大量连接队列，消耗主机资源</li>
<li>Smurf ICMP包，伪装客户端为目标主机地址，向子网广播地址发包，使子网主机回应目标主机，形成攻击</li>
<li>Land-based 设置包的源地址和目标地址为主机地址，通过ip欺骗方式发给目标主机，造成与自身建立连接的死循环</li>
<li>Ping of Death 包长度分割片段，总和大于65536字节上限，造成宕机</li>
<li>Teardrop 包分割小片段，使合并前分配大量资源堆栈</li>
</ul>
</li>
</ul>
<h2 id="sign"><a href="#sign" class="headerlink" title="sign"></a>sign</h2><p>参数签名，防止篡改</p>
<p>ascii码升序+token+key+timestamp+随机数，加密</p>
<p>可以放在请求体中，也可以放在header中，即使参数被修改，通过sign解析在接收时验证</p>
<p>（有人说sign是骗自己，没有增加防护效果，这里再提一次，抖音的signature是怎么加密的呢）</p>
<h2 id="重复提交"><a href="#重复提交" class="headerlink" title="重复提交"></a>重复提交</h2><p>前端做请求触发的拦截<br>后端设置超时时间<br>    - 第一次提交时sign保存、超时时间<br>    - 第二次请求时检测是否存在sign<br>      - 存在为重复提交，因为如果sign过期token也会过期</p>
<p>增加装饰器自定义接口防重功能</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul>
<li>客户端申请appid和key</li>
<li>客户端携带appid、timestamp、sign获取服务端api token<ul>
<li>客户端请求普通接口</li>
</ul>
</li>
<li>客户端登录，用户名密码换取user token<ul>
<li>客户端请求权限接口</li>
</ul>
</li>
</ul>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>Thread多线程，单个线程中，方法共享内存，能从上下文取值</p>
<ul>
<li>api接收参数时，拦截器校验token合法</li>
<li>找到token对应的用户信息，存储到Thread中，这样在生命周期中都能获取到</li>
</ul>
<h2 id="文档工具"><a href="#文档工具" class="headerlink" title="文档工具"></a>文档工具</h2><p>Swagger / Yapi / Postman / Online&amp;Offline Website / Excel / PPT / Word</p>
]]></content>
      <categories>
        <category>API</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>网站前端登录原理</title>
    <url>/2020/07/13/%E7%BD%91%E7%AB%99%E5%89%8D%E7%AB%AF%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>登录/扫码，背后用到了什么功能</p>
</blockquote>
<a id="more"></a>

<p>最近也是看到一个需求，网站接入微信扫码登录，并且扫码同时还需要关注公众号，那么就乘此时机回顾下各类登录方式</p>
<hr>
<h2 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie+Session"></a>Cookie+Session</h2><p>经典的登录模式</p>
<p>由于http的无状态特性，服务端是不知道客户端是谁的，也就无法判断每次请求的用户是否相关联，所以不知道用户是否已经是登录态</p>
<p>cookie作用是服务端发送给客户端的字符串，以文本方式保存，再下次请求时携带</p>
<p>session是服务端对接收的信息进行验证，服务端会分配一个内存区域/文件/数据库，用于缓存session对象</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li>首次登录<ul>
<li>用户访问页面，输入密码</li>
<li>验证成功，分配sessionId</li>
<li>响应头写入cookie，告知客户端登录成功</li>
</ul>
</li>
<li>二次登录<ul>
<li>用户发送请求携带cookie给服务端</li>
<li>验证有效，允许访问，表示cookie中解析出来的sessionId一致</li>
<li>验证失效，重新登录</li>
</ul>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>客户端数量上升，服务端需分配更大量的空间存放sessionId，增大服务端压力</li>
<li>分布式/集群，同步登录态需要每一台机器</li>
<li>sessionId存放在cookie中，有CSRF攻击风险<ul>
<li>这里简述跨站脚本攻击，中间人无法拿到/解析cookie，但是能通过真实cookie向服务端发送请求，改变发送的数据，所以攻击的是改POST，而非读GET</li>
<li>如果业务走安全审计流程么，一般会给出具体的解决方案（专业审计，价格老贵了，四大审计真的业务方向啥都审）<ul>
<li>验证 HTTP Referer 字段</li>
<li>在请求地址中添加 token 并验证</li>
<li>在 HTTP 头中自定义属性并验证</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>token优化了传统cookie+session的服务端压力问题，之前我最常用的则是JWT</p>
<h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ul>
<li>首次登录<ul>
<li>用户访问页面，输入密码</li>
<li>验证成功，生成token</li>
<li>返回token，告知客户端登录成功</li>
</ul>
</li>
<li>二次登录<ul>
<li>用户发送请求携带token给服务端</li>
<li>验证有效，允许访问</li>
<li>验证失效，重新登录</li>
</ul>
</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>服务端无需保存，利用客户端天然的分布式优势缓存token，每次请求时校验</li>
<li>不存在cookie中</li>
<li>登录态有效期由服务端决定</li>
</ul>
<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>格式为header.playload.signature字符串</p>
<p>头部指定签名算法，消息体包含数据，签名对前两部base64url+对称加密</p>
<p>当然不一定要强制按格式，能够产生类似功能的字符串与服务端匹配就可以称为JWT</p>
<p>服务端拿到字符串后执行相同对称加密动作，判断签名一致</p>
<ul>
<li>问题点在于对称加密，密钥是暴露的  </li>
<li>但是前端安全的本质是防止中间人通过各种方式篡改/攻击数据库，执行改权限之前是经过其他权限验证的真实用户，不能防止黑客作为真实用户去进行请求  </li>
<li>所以JWT也是有价值的，当然更大的价值在于减轻服务端压力</li>
</ul>
<h2 id="SSO单点登录"><a href="#SSO单点登录" class="headerlink" title="SSO单点登录"></a>SSO单点登录</h2><p>品牌内部的公共认证中心，所有产品一次登录，其他产品无需登录，常见比如腾讯的子域名游戏、综艺等</p>
<h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><ul>
<li>首次登录<ul>
<li>用户访问页面A，跳转到renz认证中心统一登录页B，并url带上redirect地址，发送请求并验证</li>
<li>输入密码，认证中心验证成功，创建全局会话&amp;ticket</li>
<li>带上统一登录的登录态cookie，重定向跳转回页面A，此时url上含有ticket</li>
<li>页面A请求，认证中心验证ticket有效，带上页面A的登录态cookie</li>
<li>登录成功，客户端有2个cookie</li>
</ul>
</li>
<li>二次登录页面A<ul>
<li>验证ticket，cookie已存在，令牌有效，登录成功</li>
</ul>
</li>
<li>二次登录页面B<ul>
<li>通过认证中心统一登录页B，验证认证中心登录态</li>
<li>验证通过，带上ticket重定向回B</li>
</ul>
</li>
<li>退出<ul>
<li>在验证ticket时，请求为退出的api接口即可</li>
<li>清除c的登录态cookie</li>
<li>清除认证中心的cookie，执行退出方法</li>
<li>遍历下发过ticket的产品，执行的退出方法</li>
</ul>
</li>
</ul>
<h2 id="Oauth"><a href="#Oauth" class="headerlink" title="Oauth"></a>Oauth</h2><p>比如微信、qq、微博,授权机制，客户端携带令牌可以访问所有者的资源</p>
<ul>
<li>接入的第三方应用获取appid,appsecret</li>
<li>用户进入时，跳转平台Oauth授权，平台发送请求用户确认</li>
<li>确认后重新进入第三方站点，并带上临时code</li>
<li>第三方应用根据code、id、secret向平台申请token</li>
<li>第三方应用拿到用户信息，保存登录态</li>
</ul>
<h3 id="Oauth2-0"><a href="#Oauth2-0" class="headerlink" title="Oauth2.0"></a>Oauth2.0</h3><p>获取token的过程，4种授权方式，都需要第三方有appid和appsecret，需要分发token和refresh</p>
<ul>
<li>授权码，最复杂，安全高，如微信</li>
<li>隐藏式，客户端直接获取token</li>
<li>密码式，第三方拿用户账密登录平台，危险风险大</li>
<li>凭证式，客户端分配了id,secret标识身份 </li>
</ul>
<p>token放header中</p>
<h3 id="令牌过期处理"><a href="#令牌过期处理" class="headerlink" title="令牌过期处理"></a>令牌过期处理</h3><p>token是有时效的，重新授权的流程体验不好，更优雅得处理过期问题</p>
<p>一个令牌请求API，一个令牌请求refresh_token，当一个失效时，下一次请求更新token，即可优化前端流程</p>
<h2 id="扫码登录及关注"><a href="#扫码登录及关注" class="headerlink" title="扫码登录及关注"></a>扫码登录及关注</h2><p>简述一下思路，扫码后&amp;关注默认为已授权</p>
<ul>
<li>嵌入网页的平台二维码展示，客户端存jwt用于验证</li>
<li>服务端生成微信临时带参二维码，每三分钟更新</li>
<li>客户端每隔3秒请求一次API获取最新状态，5次后每隔5秒，再往后时间间隔变长，优化请求，这里也可以用socket更简洁(简述三点接口性能，有空写一篇关于socket的)<ul>
<li>大量链接的创建和关闭</li>
<li>长时间保持大量连接</li>
<li>大量推送消息</li>
</ul>
</li>
<li>用户扫码后关注/直接进入公众号，服务端根据临时二维码区分渠道，得到授权状态，更新API、token、数据库</li>
<li>客户端切换页面内容A，刷新页面从缓存中取token值，验证成功后直接进入页面A，不再重新扫码</li>
<li>授权/关注流程结束，需求实现</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>轻松处理10种跨域请求</title>
    <url>/2020/07/10/%E8%BD%BB%E6%9D%BE%E5%A4%84%E7%90%8610%E7%A7%8D%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<blockquote>
<p>Leo：跨域啦，跨域啦，求后端小哥开放白名单吧<br>大佬：自己解决<br>Leo：/(ㄒoㄒ)/~~</p>
</blockquote>
<a id="more"></a>

<p>记得以前最频繁的处理跨域需求就是本地调不通测试站点的接口，只好找后端重新部署一次，开放CORS限制</p>
<p>后来有了nginx和cli-proxy就方便多了</p>
<hr>
<h2 id="什么是跨域啦"><a href="#什么是跨域啦" class="headerlink" title="什么是跨域啦"></a>什么是跨域啦</h2><ul>
<li>浏览器侧的同源策略，用来限制请求资源交互，减少服务器被攻击的渠道之一</li>
<li>服务端侧是没有的，所以有些新入门/不了解的服务端同学会疑惑postman上可以正常请求</li>
</ul>
<h2 id="什么是同源啦"><a href="#什么是同源啦" class="headerlink" title="什么是同源啦"></a>什么是同源啦</h2><p>protocol（协议）、domain（域名）、port（端口）三者一致</p>
<p>http即默认80<br>https即默认443</p>
<p>说到domain域名，示例<code>map.baidu.com</code>中  </p>
<ul>
<li><p><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D" target="_blank" rel="noopener">维基百科</a></p>
<ul>
<li>baidu.com叫做二级域名</li>
<li>map.baidu.com叫做三级域名</li>
</ul>
</li>
<li><p>而我更倾向于称呼</p>
<ul>
<li>baidu.com叫做一级域名，【主域名】<ul>
<li>.com是顶级域，baidu是一级名</li>
</ul>
</li>
<li>map.baidu.com叫做二级域名，【子域名】<ul>
<li>map是二级名</li>
</ul>
</li>
<li><strong><em>不接受反驳</em></strong>，你上阿里云/腾讯云买的是后缀域和名，可以自行配置多个子域名</li>
</ul>
</li>
</ul>
<hr>
<h2 id="解决它"><a href="#解决它" class="headerlink" title="解决它"></a>解决它</h2><h2 id="1、CORS控制响应头"><a href="#1、CORS控制响应头" class="headerlink" title="1、CORS控制响应头"></a>1、CORS控制响应头</h2><p><code>Access-Control-Allow-Origin</code>控制哪些域名可以获取资源</p>
<p>通常解决是设置响应头<code>Access-Control-Allow-Origin: *</code></p>
<h3 id="简单-复杂请求"><a href="#简单-复杂请求" class="headerlink" title="简单/复杂请求"></a>简单/复杂请求</h3><p>触发简单：</p>
<ul>
<li>Method<ul>
<li>GET、HEAD、POST</li>
</ul>
</li>
<li>Content-Type<ul>
<li>text/plain、multipart/form-data、application/x-www-form-urlencoded</li>
</ul>
</li>
<li>header<ul>
<li>Accept、Accept-Language、Content-Language、Content-Type、DPR、Downlink、Save-Data、Viewport-Width、Width</li>
</ul>
</li>
<li>XMLHttpRequestUpload没有事件监听</li>
<li>ReadableStream不存在</li>
</ul>
<p>触发预检：Options</p>
<p>就是除了简单条件以外的，比如put和application/json</p>
<p><strong><em>ie9请使用jsonp</em></strong></p>
<h3 id="Origin请求头"><a href="#Origin请求头" class="headerlink" title="Origin请求头"></a>Origin请求头</h3><ul>
<li>存在跨域，浏览器带上Origin</li>
<li>不存在跨域，请求不带Origin</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> xxx(ctx,next)&#123;</span><br><span class="line">  <span class="keyword">const</span> getOrigin = ctx.get(<span class="string">'Origin'</span>);</span><br><span class="line">  <span class="keyword">if</span>(!getOrigin) <span class="keyword">return</span> <span class="keyword">await</span> next();</span><br><span class="line">  <span class="comment">// 解决跨域请求</span></span><br><span class="line">  ctx.set(<span class="string">'Access-Control-Allow-Origin'</span>,getOrigin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Vary缓存处理"><a href="#Vary缓存处理" class="headerlink" title="Vary缓存处理"></a>Vary缓存处理</h3><p>当存在多个域名需要通过CORS时，会存在响应缓存，需要【避免CDN缓存】，可以配置<code>Vary:Origin</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getOrigin = ctx.get(<span class="string">'Origin'</span>);</span><br><span class="line">ctx.set(<span class="string">'Vary'</span>, <span class="string">'Origin'</span>)</span><br><span class="line"><span class="comment">// xxx</span></span><br></pre></td></tr></table></figure>

<h3 id="cookie处理"><a href="#cookie处理" class="headerlink" title="cookie处理"></a>cookie处理</h3><ul>
<li>withCredentials为true</li>
<li>Access-Control-Allow-Origin为非 *</li>
<li>Access-Control-Allow-Credentials 为 true</li>
</ul>
<h2 id="2、正向代理Node-proxy"><a href="#2、正向代理Node-proxy" class="headerlink" title="2、正向代理Node proxy"></a>2、正向代理Node proxy</h2><p>代理的是客户端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地开发时的接口请求域名设为空</span></span><br><span class="line">proxy: &#123;</span><br><span class="line">    <span class="string">"/api"</span>: &#123;</span><br><span class="line">        target: <span class="string">"http://10.130.10.10:1234"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>charles抓包工具拦截处理代理</p>
<p>在 tools/map remote 中设置Map from和Map to</p>
<h2 id="3、反向代理Nginx"><a href="#3、反向代理Nginx" class="headerlink" title="3、反向代理Nginx"></a>3、反向代理Nginx</h2><p>代理的是服务端</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /api &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、JSONP"><a href="#4、JSONP" class="headerlink" title="4、JSONP"></a>4、JSONP</h2><p>script标签，GET方法</p>
<ul>
<li>定义函数jsonpCallback=function(){}</li>
<li>定义请求参数cb=jsonpCallback</li>
<li>动态接口返回结果运行jsonpCallback({xxx:xxx})</li>
</ul>
<h2 id="5、Websocket"><a href="#5、Websocket" class="headerlink" title="5、Websocket"></a>5、Websocket</h2><p>客户端和服务器之间存在非HTTP，持久，全双工连接</p>
<p>因为不用HTTP，所以就没限制了</p>
<h2 id="6、window-postMessage"><a href="#6、window-postMessage" class="headerlink" title="6、window.postMessage"></a>6、window.postMessage</h2><p><strong><em>可以在 http 返回头 添加X-Frame-Options: SAMEORIGIN 防止被别人添加至 iframe</em></strong></p>
<p><code>&lt;iframe id=&quot;frame&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; src=&quot;http://b.test.com/b.html&quot;&gt;&lt;/iframe&gt;</code></p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的 iframe 消息传递</li>
</ul>
<h2 id="7、document-domain-iframe"><a href="#7、document-domain-iframe" class="headerlink" title="7、document.domain + iframe"></a>7、document.domain + iframe</h2><p>相同主域名，页面A可以拿到iframe页面B的内容</p>
<h2 id="8、window-location-hash-iframe"><a href="#8、window-location-hash-iframe" class="headerlink" title="8、window.location.hash + iframe"></a>8、window.location.hash + iframe</h2><p>A：<code>&lt;iframe src=&quot;http://localhost:8080/hash/c.html#name1&quot;&gt;&lt;/iframe&gt;</code></p>
<p>C：<code>const iframe = document.createElement(&quot;iframe&quot;); iframe.src = &quot;http://localhost:8000/hash/b.html#name2&quot;;
document.body.appendChild(iframe);</code></p>
<p>B：<code>window.parent.parent.location.hash = location.hash;</code></p>
<p>页面A的url的hash值 -&gt; C     AC跨域<br>页面C的url接收hash值 -&gt; B   BC跨域<br>页面B结果给页面A的hash值 -&gt; A   AB跨域</p>
<h2 id="9、window-name-iframe"><a href="#9、window-name-iframe" class="headerlink" title="9、window.name + iframe"></a>9、window.name + iframe</h2><p>location 变化，重新加载，name 可以不变</p>
<p>就是先读取一次后换个iframe的src路径重新加载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A：</span></span><br><span class="line"><span class="keyword">let</span> first = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">        iframe.src = <span class="string">"http://localhost:8000/name/b.html"</span>;</span><br><span class="line">        first = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span><br><span class="line">        <span class="built_in">console</span>.log(iframe.contentWindow.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.html</span></span><br><span class="line">&lt;div&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ c.html</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  window.name = "秋风的笔记";</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="10、浏览器配置"><a href="#10、浏览器配置" class="headerlink" title="10、浏览器配置"></a>10、浏览器配置</h2><p>【慎用】</p>
<p>Windows<br>找到你安装的目录<br>.\Google\Chrome\Application\chrome.exe –disable-web-security –user-data-dir=xxxx</p>
<p>Mac<br><del>/Downloads/chrome-data<br>/Applications/Google\ Chrome\ Canary.app/Contents/MacOS/Google\ Chrome\ Canary  –disable-web-security –user-data-dir=</del>/Downloads/chrome-data</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>和我一起搭建Jenkins</title>
    <url>/2020/07/08/%E5%92%8C%E6%88%91%E4%B8%80%E8%B5%B7%E6%90%AD%E5%BB%BAJenkins/</url>
    <content><![CDATA[<blockquote>
<p>自动化部署工具,释放部署流程</p>
</blockquote>
<a id="more"></a>

<p>运维工具？不存在的，作为开发什么都得了解，之前公司手动部署流程可太麻烦了，不同项目不同流程手动处理，小本本都记不下了</p>
<p>本篇是centos搭建Jenkins持续集成环境的教程</p>
<p><a href="https://mp.weixin.qq.com/s/oiznlZ_4L_0Am2SNOonLDw" target="_blank" rel="noopener">图文版参考链接</a></p>
<hr>
<blockquote>
<p>Jenkins能做什么</p>
</blockquote>
<p>当然是部署自动化啦,java底层的持续集成的工具平台，插件包管理</p>
<ul>
<li>本地代码push到GitHub</li>
<li>Webhook自动触发jenkins上的构建动作</li>
<li>完成安装node插件并且打包</li>
<li>通过Publish Over SSH插件，将打包出来的文件，部署到目标服务器上</li>
</ul>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>github、centos、java sdk、nginx、jenkins</p>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$yum install java</span><br><span class="line"></span><br><span class="line">$ wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo</span><br><span class="line"></span><br><span class="line">$ rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key</span><br><span class="line"></span><br><span class="line">$ yum install jenkins //这一步会比较慢</span><br><span class="line"></span><br><span class="line">// 下载成功，但收到警告xxx.rpm公钥未安装，<span class="built_in">cd</span>到包的目录，执行</span><br><span class="line">rpm -ivh xxx.rpm手动安装</span><br><span class="line"></span><br><span class="line">$ service jenkins restart  //启动 jenkins</span><br><span class="line"></span><br><span class="line">$ cat /var/lib/jenkins/secrets/initialAdminPassword 查看初始密码</span><br></pre></td></tr></table></figure>

<h2 id="配置jenkis的端口"><a href="#配置jenkis的端口" class="headerlink" title="配置jenkis的端口"></a>配置jenkis的端口</h2><p>vi /etc/sysconfig/jenkins<br>修改<br>JENKINS_PORT=”8080”</p>
<p>service jenkins start    // 默认8080，记得服务器开端口<br>service jenkins stop<br>service jenkins restart</p>
<p>systemctl daemon-reload  // 重启</p>
<p>// 选择安装推荐的插件<br>// 等待大约20个包安装<br>// 创建管理员账户<br>// 然后再安装推荐的插件 Rebuilder， SafeRestart，Publish over SSH插件</p>
<p>Publish Over SSH插件安装后进入Configure System，最底下有Publish Over SSH配置</p>
<p>需要配置jenkins服务器和centos服务器的密钥认证</p>
<h2 id="构建第一个任务"><a href="#构建第一个任务" class="headerlink" title="构建第一个任务"></a>构建第一个任务</h2><ul>
<li>选择自由风格</li>
<li>源码管理<code>https://github.com/Gitby-Leo/xxx.git</code><ul>
<li>Credentials绑定仓库账号</li>
</ul>
</li>
<li>构建环境 Provide Node &amp; npm bin/ folder to PATH<ul>
<li>选择开发时的Node版本</li>
</ul>
</li>
<li>构建<ul>
<li>执行shell</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">node -v &amp;&amp;</span><br><span class="line">npm i yarn -g &amp;&amp;</span><br><span class="line">yarn config set registry https://registry.npm.taobao.org &amp;&amp;</span><br><span class="line">yarn install &amp;&amp;</span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure>

<h2 id="配置服务器部署"><a href="#配置服务器部署" class="headerlink" title="配置服务器部署"></a>配置服务器部署</h2><ul>
<li>构建后操作  SSH Server</li>
</ul>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">Name     leo_aly</span><br><span class="line">Source files     build/<span class="emphasis">**/*</span>         编译打包后的目标文件/文件夹</span><br><span class="line">Remove prefix     build            删除目录</span><br><span class="line">Remote directory test1_yarn     创建目录</span><br><span class="line">Exec command</span><br></pre></td></tr></table></figure>

<ul>
<li>应用、保存</li>
</ul>
<p>当仓库有内容时，执行构建可以看到构建进度</p>
<blockquote>
<p>注意Nginx非proxy_pass模式的路径配置</p>
</blockquote>
<h2 id="配置自动构建"><a href="#配置自动构建" class="headerlink" title="配置自动构建"></a>配置自动构建</h2><h3 id="jenkins配置"><a href="#jenkins配置" class="headerlink" title="jenkins配置"></a>jenkins配置</h3><ul>
<li>安装Generic Webhook Trigger插件，用来push代码后自动构建jenkins</li>
<li>配置工程中的构建触发器，选择Generic Webhook Trigger，填写token，才能和github仓库关联<ul>
<li>比如设置简单的16位md5加密123456，token=49ba59abbe56e057</li>
</ul>
</li>
</ul>
<h3 id="github配置"><a href="#github配置" class="headerlink" title="github配置"></a>github配置</h3><ul>
<li>进入仓库settings,左侧webhooks，add webhooks</li>
<li>url配置为xxx:8080/generic-webhook-trigger/invoke?token=49ba59abbe56e057</li>
<li>Just the push event在push代码时触发webhook<br>提交</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>修改一个字符，提交到github，可以看到jenkins面版里自动开始构建，并成功更新</p>
<blockquote>
<p>很久不用docker了</p>
</blockquote>
<p>下一篇用docker打包镜像，自动化容器构建</p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>一条SQL查询语句是如何执行的</title>
    <url>/2020/07/07/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<blockquote>
<p>执行sql语句时都进行了哪些操作</p>
</blockquote>
<a id="more"></a>

<p>这个标题就和点击一个url时都做了什么一样，找寻<a href="https://time.geekbang.org/column/intro/139" target="_blank" rel="noopener">背后的原理</a></p>
<hr>
<p><code>mysql&gt; select * from T where Id=10</code></p>
<p>Server层和存储引擎层</p>
<ul>
<li><ol>
<li>客户端操作</li>
</ol>
</li>
<li><ol start="2">
<li>连接器</li>
</ol>
<ul>
<li>管理连接，权限验证</li>
</ul>
</li>
<li><ol start="3">
<li>查询缓存</li>
</ol>
<ul>
<li>命中返回结果</li>
</ul>
</li>
<li><ol start="3">
<li>分析器</li>
</ol>
<ul>
<li>词法分析，语法分析</li>
<li>查询缓存</li>
</ul>
</li>
<li><ol start="4">
<li>优化器</li>
</ol>
<ul>
<li>索引选择</li>
</ul>
</li>
<li><ol start="5">
<li>执行器</li>
</ol>
<ul>
<li>返回结果</li>
</ul>
</li>
<li><ol start="6">
<li>存储引擎</li>
</ol>
<ul>
<li>读写接口，存储</li>
</ul>
</li>
</ul>
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器，内置函数，存储过程、触发器、视图</p>
<p>存储引擎层负责数据的存储和提取，支持InnoDB、MyISAM、Memory等多个存储引擎，MySQL 5.5.5默认InnoDB</p>
<p>在create table语句中使用engine=memory, 来指定使用内存引擎创建表<br>不同的存储引擎共用一个Server层</p>
<h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>mysql -h$ip -P$port -u$user -p</p>
<p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码</p>
<ul>
<li>用户名或密码不对<ul>
<li>报错，客户端程序结束</li>
</ul>
</li>
<li>用户名密码认证通过<ul>
<li>到权限表里面查出你拥有的权限</li>
<li>权限修改后要重新连接才会刷新</li>
</ul>
</li>
</ul>
<p>show processlist查看状态，空闲状态默认值是8小时</p>
<p>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接<br>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</p>
<p>MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放，<br>长连接占用内存涨得快，内存占用太大会导致MySQL异常重启</p>
<p>定期断开长连接，程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连<br>5.7+用mysql_reset_connection重新初始化，跳过重连和权限验证</p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>MySQL 8.0删除了这个功能</p>
<p>到查询缓存看看，之前是不是执行过这条语句，结果可能会以key-value对的形式，被直接缓存在内存中</p>
<p>不要使用查询缓存，查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空<br>一张静态表，很长时间才会更新一次才适合使用查询缓存</p>
<p>按需使用<br>query_cache_type设置成DEMAND，不使用查询缓存<br>select SQL_CACHE * from T where ID=10使用查询缓存的语句</p>
<h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>执行语句，对SQL语句做解析</p>
<p>词法分析，识别关键字如select查询,T是表名，id是列名</p>
<p>语法分析，根据语法规则判断语句合法</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>在开始执行之前，还要先经过优化器的处理</p>
<p>有多个索引的时候，决定使用哪个索引</p>
<p>有多表关联（join）的时候，决定各个表的连接顺序</p>
<p>mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;</p>
<ul>
<li>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li>
<li>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li>
</ul>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>执行语句</p>
<p>有没有执行查询的权限</p>
<p>根据表的引擎定义，使用这个引擎提供的接口</p>
<ul>
<li>没有索引<ul>
<li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ul>
</li>
<li>有索引<ul>
<li>第一次调用的是“取满足条件的第一行”这个接口</li>
<li>之后循环取“满足条件的下一行”这个接口</li>
</ul>
</li>
</ul>
<p>在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的</p>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>git版本管理工具命令概述</title>
    <url>/2020/07/06/git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>git的命令行语法噢</p>
</blockquote>
<a id="more"></a>

<p>接触git进行版本管理源代码，常用一些基础的推拉命令/sourceTree<br>今天看着旁边大佬一顿操作命令行，执行速度杠杠的，sourceTree在这方面完全不能比</p>
<hr>
<!-- https://copyfuture.com/blogs-details/20200601122538850lylhabd6xw46urm -->
<h2 id="三大区域"><a href="#三大区域" class="headerlink" title="三大区域"></a>三大区域</h2><p>工作区、暂存区和Git仓库(本地/远端)</p>
<p><code>git add, git commit, git push, git merge, git pull, git log</code></p>
<p><code>git add</code><br>会将工作区的文件标记为已暂存，保存在暂存区</p>
<p><code>git commit</code><br>会将标记为已暂存的文件保存都本地Git仓库，并生成一个快照</p>
<p><code>git diff</code><br>查看修改，谢谢您了这个请用可视化吧</p>
<h2 id="未暂存前，撤销修改"><a href="#未暂存前，撤销修改" class="headerlink" title="未暂存前，撤销修改"></a>未暂存前，撤销修改</h2><p><code>git checkout -- .</code><br>撤销所有本地修改</p>
<p><code>git checkout -- [filename]</code><br>撤销指定文件修改</p>
<h2 id="暂存后-撤销修改"><a href="#暂存后-撤销修改" class="headerlink" title="暂存后,撤销修改"></a>暂存后,撤销修改</h2><p><code>git reset .</code><br>撤销暂存区的全部修改</p>
<h2 id="提交到本地仓库后-撤销提交"><a href="#提交到本地仓库后-撤销提交" class="headerlink" title="提交到本地仓库后,撤销提交"></a>提交到本地仓库后,撤销提交</h2><p><code>git commit -m &quot;modify some files&quot;</code><br>提交历史里面会有一条记录</p>
<p><code>git checkout a18c6fa</code><br><code>git log</code><br>回到上一次提交记录，执行log</p>
<p><code>git reset --hard HEAD~1</code><br>或者重置</p>
<p><code>git reflog</code><br><code>git reset --hard f8651ff</code><br>又反悔了，那就再找到f8651ff</p>
<h2 id="修改提交"><a href="#修改提交" class="headerlink" title="修改提交"></a>修改提交</h2><p>提交了一个文件,又想提交一个，但不想2条记录<br><code>git add xx</code><br><code>git commit -m &quot;add test block&quot;</code><br><code>git log</code><br><code>git add src/app/app.component.css</code><br><code>git commit --amend</code>  </p>
<p>修改一个词，会改变之前的id<br><code>git commit --amend -m &quot;add test container&quot;</code></p>
<h2 id="撤销提交历史中的某一次提交"><a href="#撤销提交历史中的某一次提交" class="headerlink" title="撤销提交历史中的某一次提交"></a>撤销提交历史中的某一次提交</h2><p><code>git revert 711bb0b</code></p>
<h2 id="合并出现冲突时撤销合并"><a href="#合并出现冲突时撤销合并" class="headerlink" title="合并出现冲突时撤销合并"></a>合并出现冲突时撤销合并</h2><p><code>git merge --abort</code><br>撤销这个合并,恢复合并之前的状态</p>
<h2 id="移除暂存区的文件"><a href="#移除暂存区的文件" class="headerlink" title="移除暂存区的文件"></a>移除暂存区的文件</h2><p><code>git rm --cached src/test.pptx</code></p>
<h2 id="分支重命名"><a href="#分支重命名" class="headerlink" title="分支重命名"></a>分支重命名</h2><p><code>git br -m [old_br] [new_br]</code></p>
<h2 id="撤销变基操作"><a href="#撤销变基操作" class="headerlink" title="撤销变基操作"></a>撤销变基操作</h2><p><code>git co rebase_test</code><br><code>git rebase master</code></p>
<p>1.使用 git reflog 命令找到变基前的提交 09b0adc<br>2.使用 git reset –hard 09b0adc 重置到该提交</p>
<h2 id="删除远端仓库记录"><a href="#删除远端仓库记录" class="headerlink" title="删除远端仓库记录"></a>删除远端仓库记录</h2><p>密码文件可以通过git快照恢复</p>
<p>git filter-branch –tree-filter ‘rm -f passwords.txt’ HEAD</p>
<h2 id="交互式变基"><a href="#交互式变基" class="headerlink" title="交互式变基"></a>交互式变基</h2><p><code>git rebase -i</code><br>对本地分支进行合并操作，让提交变成一条直线，不适合远程分支操作</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>v-if之用key管理可复用元素</title>
    <url>/2020/07/03/v-if%E4%B9%8B%E7%94%A8key%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<blockquote>
<p>vue key解决了引入相同组件切换时数据互不影响</p>
</blockquote>
<a id="more"></a>

<p>文档细节遗忘导致的问题（面试官：这是基础）</p>
<hr>
<p>日常开发中，遇到一个问题，相同组件引入后，切换发现组件内的数据没有更新/重置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父</span></span><br><span class="line">&lt;code-same v-<span class="keyword">if</span>=<span class="string">"code==1"</span>/&gt;</span><br><span class="line">&lt;code-same v-<span class="keyword">if</span>=<span class="string">"code==2"</span>/&gt;</span><br><span class="line"><span class="keyword">import</span> codeSame <span class="keyword">from</span> <span class="string">"./components/code.vue"</span>;</span><br><span class="line"><span class="comment">// 子</span></span><br><span class="line">&lt;input type=<span class="string">"text"</span> /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="思考1"><a href="#思考1" class="headerlink" title="思考1"></a>思考1</h2><p>是不是受到了keep-alive影响缓存，然而场景下并没有用动态组件，而是v-if</p>
<h2 id="尝试了4种情况"><a href="#尝试了4种情况" class="headerlink" title="尝试了4种情况"></a>尝试了4种情况</h2><p>components引入不同实例组件时正常，而只实例化一次的组件就会缓存</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;!-- 正常 --&gt;</span><br><span class="line">    &lt;code1 v-<span class="keyword">if</span>=<span class="string">"code==1"</span>/&gt;</span><br><span class="line">    &lt;code2 v-<span class="keyword">if</span>=<span class="string">"code==2"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 缓存 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;code-same v-if="code==1" :key="c1"/</span>&gt;</span><br><span class="line">    &lt;code-same v-<span class="keyword">if</span>=<span class="string">"code==2"</span> :key=<span class="string">"c2"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 缓存 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;code-same  v-if="code==`$&#123;code&#125;`" :key="xxx"/</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 正常 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;code-same v-if="code==1" ref="c1" /</span>&gt;</span><br><span class="line">    &lt;code-same2 v-<span class="keyword">if</span>=<span class="string">"code==2"</span> ref=<span class="string">"c2"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">import code1 from "./</span>components/code1.vue<span class="string">";</span></span><br><span class="line"><span class="string">import code2 from "</span>./components/code2.vue<span class="string">";</span></span><br><span class="line"><span class="string">import codeSame from "</span>./components/code.vue<span class="string">";</span></span><br><span class="line"><span class="string">import codeSame2 from "</span>./components/code.vue<span class="string">";</span></span><br></pre></td></tr></table></figure>

<h2 id="思考2"><a href="#思考2" class="headerlink" title="思考2"></a>思考2</h2><p>即时父组件上用了key也不生效<br>等等<br>既然试了父组件的key，也试试子组件的key呗</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input :key=<span class="string">"`c$&#123;dnumber&#125;`"</span> type=<span class="string">"text"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>这次成功了，上面2种缓存的情况回复了正常，切换时输入框不再有值</p>
<p><code>v-if + components</code>时为什么需要加key呢，那就前往官方文档看看~<br><a href="https://cn.vuejs.org/v2/guide/conditional.html" target="_blank" rel="noopener">用key管理可复用的元素</a></p>
<p><code>(Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key attribute 即可)</code></p>
<p>（震惊了，我感觉我没看过文档，尤小右牛皮!）</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>是时候掌握Proxy了</title>
    <url>/2020/07/02/%E6%98%AF%E6%97%B6%E5%80%99%E6%8E%8C%E6%8F%A1Proxy%E4%BA%86/</url>
    <content><![CDATA[<blockquote>
<p>为其他对象提供一种代理以控制对这个对象的访问</p>
</blockquote>
<a id="more"></a>

<h2 id="回顾Object-defineProperty"><a href="#回顾Object-defineProperty" class="headerlink" title="回顾Object.defineProperty"></a>回顾Object.defineProperty</h2><p>只要准备过面试，相信你一定熟知ES5的Object.defineProperty，遍历属性、get/set劫持监听、双向绑定、重写数组原型支持响应式、balabala<br>当然Object.defineProperty还有4大属性，configurable、enumerable、writable、value<br>良好的兼容性</p>
<h3 id="不能一次监听所有属性"><a href="#不能一次监听所有属性" class="headerlink" title="不能一次监听所有属性"></a>不能一次监听所有属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">       <span class="keyword">set</span>() &#123;&#125;,</span><br><span class="line">       <span class="keyword">get</span>() &#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 什么叫简洁啊（战术后仰</span></span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">set</span>() &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="无法监听新增加的属性"><a href="#无法监听新增加的属性" class="headerlink" title="无法监听新增加的属性"></a>无法监听新增加的属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用框架语法</span></span><br><span class="line">Vue.set(obj, <span class="string">"a"</span>, <span class="string">"1"</span>);</span><br><span class="line"><span class="comment">// Proxy直接监听</span></span><br><span class="line">obj.a = <span class="string">"1"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="无法响应数组操作"><a href="#无法响应数组操作" class="headerlink" title="无法响应数组操作"></a>无法响应数组操作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这也是诟病最多的问题了</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">// 改变已存在的项，都生效</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">10</span>; <span class="comment">// 改变长度，添加新的项，只有 Proxy 生效</span></span><br><span class="line">arr.push(<span class="number">10</span>); <span class="comment">// push方法，只有 Proxy 生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 据说Mobx的默认数组长度是1000，比如下面这样写，离谱的hock，但还是比redux香</span></span><br><span class="line">[...Array(<span class="number">1000</span>)].forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">Object</span>.defineProperty(arr, <span class="string">`<span class="subst">$&#123;index&#125;</span>`</span>, &#123;</span><br><span class="line">     <span class="keyword">set</span>() &#123;&#125;,</span><br><span class="line">     <span class="keyword">get</span>() &#123;&#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">arr[<span class="number">30</span>] = <span class="number">10</span>; <span class="comment">// 生效</span></span><br><span class="line">arr[<span class="number">40</span>] = <span class="number">10</span>; <span class="comment">// 生效</span></span><br></pre></td></tr></table></figure>

<h3 id="必考题如何重写数组原型用以支持监听"><a href="#必考题如何重写数组原型用以支持监听" class="headerlink" title="必考题如何重写数组原型用以支持监听"></a>必考题如何重写数组原型用以支持监听</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在定义变量的时候，判断其是否为数组，如果是数组，那么就修改它的 __proto__，将其指向 subArrProto，从而实现重写原型链</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"> <span class="keyword">const</span> subArrProto = <span class="built_in">Object</span>.create(arrayProto);</span><br><span class="line"> <span class="keyword">const</span> methods = [<span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'sort'</span>, <span class="string">'reverse'</span>, <span class="string">'splice'</span>, <span class="string">'push'</span>];</span><br><span class="line"> methods.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 重写原型方法</span></span><br><span class="line">   subArrProto[method] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     arrayProto[method].call(<span class="keyword">this</span>, ...arguments);</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">// 监听新方法</span></span><br><span class="line">   <span class="built_in">Object</span>.defineProperty(subArrProto, method, &#123;</span><br><span class="line">     <span class="keyword">set</span>() &#123;&#125;,</span><br><span class="line">     <span class="keyword">get</span>() &#123;&#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="看看Proxy"><a href="#看看Proxy" class="headerlink" title="看看Proxy"></a>看看Proxy</h2><p>Proxy 构造函数接收两个参数，第一个参数是需要拦截的目标对象，这个对象只可以是对象、数组或者函数<br>第二个参数则是一个配置对象，提供了拦截方法，即使这个配置对象为空对象，返回的 Proxy 新实例也不是原来的目标对象（用Reflect获取原目标对象哦）</p>
<h3 id="令人惊叹的13种拦截操作"><a href="#令人惊叹的13种拦截操作" class="headerlink" title="令人惊叹的13种拦截操作"></a>令人惊叹的13种拦截操作</h3><p>当然有很多和ts的新语法糖一样令人摸不着头脑能用在何处</p>
<!-- https://mp.weixin.qq.com/s/wmMAeZwGV_MK8k7HlkB_7g -->
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>拦截对目标对象属性的读取 get(目标对象,属性名,Proxy 实例)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置私有属性,实现禁止访问</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prop[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;prop&#125;</span> is private attribute`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target[prop]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy._aaa;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给对象中未定义的属性设置默认值</span></span><br><span class="line"><span class="keyword">const</span> defaults = <span class="function">(<span class="params">obj, initial</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">                <span class="keyword">return</span> target[prop]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> initial</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">person = defaults(person, <span class="number">0</span>);</span><br><span class="line">persion.aaa;<span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>拦截对属性的赋值操作 set(目标对象,属性名,属性值,Proxy 实例)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值时打印当前状态</span></span><br><span class="line"><span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> has been set to <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">Reflect</span>.set(target, key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// self属性指向本身</span></span><br><span class="line"><span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'self'</span>) &#123;</span><br><span class="line">        <span class="built_in">Reflect</span>.set(target, key, receiver);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Reflect</span>.set(target, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置不可写时依旧执行set函数，但不会生效</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校验规则扩展</span></span><br><span class="line"><span class="keyword">const</span> validators = &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        validate(value) &#123; <span class="keyword">return</span> value.length &gt; <span class="number">6</span>; &#125;,</span><br><span class="line">        message: <span class="string">'用户名长度不能小于6'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    password: &#123;</span><br><span class="line">        validate(value) &#123; <span class="keyword">return</span> value.length &gt; <span class="number">10</span>; &#125;,</span><br><span class="line">        message: <span class="string">'密码长度不能小于10'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    moblie: &#123;</span><br><span class="line">        validate(value) &#123; <span class="keyword">return</span> <span class="regexp">/^1(3|5|7|8|9)[0-9]&#123;9&#125;$/</span>.test(value); &#125;,</span><br><span class="line">        message: <span class="string">'手机号格式错误'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validator</span>(<span class="params">obj, validators</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="comment">// 属性拦截</span></span><br><span class="line">        <span class="comment">// target =&gt; obj</span></span><br><span class="line">        <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">            <span class="keyword">const</span> validator = validators[key]</span><br><span class="line">            <span class="keyword">if</span> (!validator) &#123;</span><br><span class="line">                target[key] = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (validator.validate(value)) &#123;</span><br><span class="line">                target[key] = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(validator.message || <span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> form = &#123;&#125;;</span><br><span class="line">form = validator(form, validators);</span><br><span class="line">form.name = <span class="string">'666'</span>; <span class="comment">// 提示</span></span><br></pre></td></tr></table></figure>

<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>拦截函数的调用 apply(目标对象,this,参数数组)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取函数调用次数，执行耗时</span></span><br><span class="line"><span class="keyword">const</span> func = <span class="keyword">new</span> <span class="built_in">Proxy</span>(test, &#123;</span><br><span class="line">    _count: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// target =&gt; test</span></span><br><span class="line">    apply(target, context, args) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello, world'</span>);</span><br><span class="line">        target.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">func(); <span class="comment">//执行函数也会执行test()</span></span><br></pre></td></tr></table></figure>

<h3 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h3><p>拦截 new 操作符 construct(目标对象,构造函数的参数列表,Proxy 对象)<br>返回一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> P = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Person, &#123;</span><br><span class="line">    <span class="comment">// target =&gt; Person</span></span><br><span class="line">    construct(target, args, newTarget) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'construct'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> target(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者返回一个新对象</span></span><br><span class="line">    construct(target, args, newTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: args[<span class="number">0</span>],</span><br><span class="line">            age: args[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> P(<span class="string">'tom'</span>, <span class="number">21</span>); <span class="comment">// 'construct'</span></span><br></pre></td></tr></table></figure>

<p><code>构造函数没有返回值或者返回原始类型的值，那么默认返回this，
如果返回引用类型的值，那么最终 new 出来的就是这个值</code></p>
<h2 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h2><h3 id="用于代理类"><a href="#用于代理类" class="headerlink" title="用于代理类"></a>用于代理类</h3><p>对属性设置 get 拦截，对原型函数设置 apply 拦截</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, and my age is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxyTrack = <span class="function">(<span class="params">targetClass</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> prototype = targetClass.prototype;</span><br><span class="line">  <span class="comment">// 获取原型 prototype 上所有的属性名,forEach 遍历并使用 apply 拦截</span></span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyNames(prototype).forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      targetClass.prototype[name] = <span class="keyword">new</span> <span class="built_in">Proxy</span>(prototype[name], &#123;</span><br><span class="line">          apply(target, context, args) &#123;</span><br><span class="line">              <span class="built_in">console</span>.time();</span><br><span class="line">              target.apply(context, args);</span><br><span class="line">              <span class="built_in">console</span>.timeEnd();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetClass, &#123;</span><br><span class="line">    <span class="comment">// 拦截 construct 方法</span></span><br><span class="line">    construct(target, args) &#123;</span><br><span class="line">        <span class="keyword">const</span> obj = <span class="keyword">new</span> target(...args);</span><br><span class="line">        <span class="comment">// 返回一个代理过的对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">            <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;target.name&#125;</span>.<span class="subst">$&#123;prop&#125;</span> is being getting`</span>);</span><br><span class="line">                <span class="keyword">return</span> target[prop]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> MyClass = proxyTrack(Person); <span class="comment">// 先代理</span></span><br><span class="line"><span class="keyword">const</span> myClass = <span class="keyword">new</span> MyClass(<span class="string">'tom'</span>, <span class="number">21</span>);<span class="comment">// 实例化代理类</span></span><br><span class="line">myClass.say(); <span class="comment">// 查看计算时间</span></span><br><span class="line">myClass.name;</span><br></pre></td></tr></table></figure>

<h3 id="对象链取值"><a href="#对象链取值" class="headerlink" title="对象链取值"></a>对象链取值</h3><p>多层属性可选链 a?.b</p>
<p>普通方式:<br>`country.province &amp;&amp; country.province.city &amp;&amp; country.province.city.name;</p>
<p>lodash方式:<br><code>_.get(country, &#39;province.city.name&#39;)</code>;</p>
<p>可选链:<br><code>country?.province?.city?.name</code></p>
<p>Proxy:<br><code>get(country).province.city.name()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">  person:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> isFirst = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyVoid = <span class="keyword">get</span>(undefined);</span><br><span class="line">function <span class="keyword">get</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isFirst) &#123;</span><br><span class="line">            <span class="keyword">return</span> proxyVoid;</span><br><span class="line">        &#125;</span><br><span class="line">        isFirst = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(noop, &#123;</span><br><span class="line">        <span class="comment">// 拦截传入的对象</span></span><br><span class="line">        <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">            <span class="comment">// return target[prop];</span></span><br><span class="line">            <span class="comment">// 不直接返回对象，而是返回代理对象</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                obj !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">                obj !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                obj.hasOwnProperty(prop)</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">get</span>(obj[prop]);</span><br><span class="line">            &#125;</span><br><span class="line">            return proxyVoid;</span><br><span class="line">        &#125;</span><br><span class="line">        // 代理noop，支持返回执行的时候传入的参数</span><br><span class="line">        apply(target, context, [arg]) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj === <span class="literal">undefined</span> ? arg : obj;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">get</span>(obj)() === obj;</span><br><span class="line"><span class="keyword">get</span>(obj).person(); // &#123;&#125;</span><br><span class="line"><span class="keyword">get</span>(obj).person.name(); // undefined</span><br><span class="line"><span class="keyword">get</span>(obj).person.name.xxx.yyy.zzz(); // undefined</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ngrok内网穿透工具</title>
    <url>/2020/07/01/ngrok%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<blockquote>
<p>没有云服务器不要紧，分分钟让局域网资源公网可访问</p>
</blockquote>
<a id="more"></a>

<p>太多教程标题党1分钟、10分钟完成一个ngrok的搭建，这里我只想说，funny mud pee，经过一堆配置报错异常处理后，本篇才是真正的10分钟</p>
<hr>
<p>内网穿透 即 NAT穿透</p>
<p><a href="http://ngrok.cn/docs.html#expose" target="_blank" rel="noopener">详细的中文文档说明</a></p>
<ul>
<li>通过ngrok反向代理服务实现本机在无公网ip时被外部访问</li>
<li>ngrok建立一个安全隧道,主机A的http请求传递给主机B</li>
<li>本地端口所监听的进程转发到远端服务器上，实现穿透</li>
</ul>
<blockquote>
<p>简单的国外官方服务器版 -v2.x - free版不支持自定义域名</p>
</blockquote>
<p>注册并获取授权码<br>如通过github绑定注册的</p>
<ol>
<li>下载<a href="https://ngrok.com/download" target="_blank" rel="noopener">客户端</a><ul>
<li>window版是.exe文件</li>
</ul>
</li>
<li>配置授权码<ul>
<li>Authentication里获取</li>
<li>执行.exe,输入<code>ngrok authtoken xxxxx</code></li>
<li>保存在<code>C:\Users\xxx\.ngrok2\</code>中</li>
</ul>
</li>
<li>本地启动服务器，端口8080<ul>
<li>推荐node下的anywhere，so easy</li>
</ul>
</li>
<li>启动ngrok<ul>
<li>在ngrok.exe进程的shell里</li>
<li>执行ngrok http 8080,</li>
</ul>
</li>
<li>访问<code>http://xxx.ngrok.io</code>等于本地<code>localhost:8080</code><ul>
<li>需等待官方同步</li>
</ul>
</li>
</ol>
<blockquote>
<p>自建服务centos    -v1.7    -自己的域名 （云服务器还是香）</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/53c72ae1446c" target="_blank" rel="noopener">采用了文中的go+docker方案</a></p>
<ul>
<li>公网ip服务器</li>
<li>域名及备案</li>
<li>配置两条二级域名*.ngrok和ngrok</li>
<li>安全组端口开通80、4443是服务通信、4444是tcp端口转发、8000是http请求转发</li>
<li>安全组添加端口白名单和域名</li>
<li>ngrok.sh传到服务器上,执行</li>
</ul>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h3><p><code>docker build -t ngrok .</code></p>
<p>一共10个Step<br>go install -tags ‘release’ ngrok/main/ngrokd会比较慢，等待install8次才成功</p>
<h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><p><code>docker run -it -p 8081:8081 -p 4443:4443 -p 4444:4444 -p 4445:4445 -d ngrok /ngrok/bin/ngrokd -domain=&quot;ngrok.xxx.com&quot; -httpAddr=&quot;:8081&quot;</code></p>
<h3 id="查看镜像列表"><a href="#查看镜像列表" class="headerlink" title="查看镜像列表"></a>查看镜像列表</h3><p><code>docker images</code>，拿到镜像ID，image id</p>
<h3 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h3><p><code>docker ps</code>，拿到容器ID，container id</p>
<h3 id="查看镜像-容器信息"><a href="#查看镜像-容器信息" class="headerlink" title="查看镜像/容器信息"></a>查看镜像/容器信息</h3><p><code>docker inspect id</code></p>
<p>找到挂载目录Mounts.Source</p>
<p>进入这个目录，找到bin/里面选择客户端版本ngrok.exe，下载</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>新建配置文件config.yml，放在刚刚下载的同一层</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server_addr:</span> <span class="string">"ngrok.xxx.com:4443"</span></span><br><span class="line"><span class="attr">trust_host_root_certs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">tunnels:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">proto:</span> <span class="comment"># 本地端口</span></span><br><span class="line">      <span class="attr">http:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">subdomain:</span> <span class="string">test</span> <span class="comment"># 二级域名，没有则自动生成</span></span><br><span class="line">  <span class="attr">tcp12345:</span></span><br><span class="line">    <span class="attr">remote_port:</span> <span class="number">4444</span>  <span class="comment"># tcp隧道中远程服务器端口</span></span><br><span class="line">    <span class="attr">proto:</span></span><br><span class="line">      <span class="attr">tcp:</span> <span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>如果是window客户端，用cmd进入目录后执行<br><code>ngrok -config=config.yml start-all</code></p>
<p>棒不棒！(๑•̀ㅂ•́)و✧，可以通过域名访问本地内容了</p>
<p>如果切换盘符失败可以用<code>cd /d xxx</code></p>
<p>8080是本地启动服务的端口<br>访问时加载速度取决于服务端的带宽</p>
<p><code>http://localhost:4040</code>可以查看本地请求的资源信息</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Quasar基于vue的前端框架-组件</title>
    <url>/2020/06/29/Quasar%E5%9F%BA%E4%BA%8Evue%E7%9A%84%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>上一篇介绍了基于quasar的配置能做些什么<br>本篇了解一下quasar的基于vue的组件</p>
</blockquote>
<a id="more"></a>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>通过v-xxx使用，并且在quasar.config配置文件中提前声明用到的指令<br>framework: {<br>    directives: [‘Ripple’]<br>}<br><code>&lt;div v-touch-pan=&quot;handler&quot;&gt;...&lt;/div&gt;</code></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件名用Q开头QBtn和QElementResizeObservable，同样需要在配置文件中提前声明<br>framework: {<br>  components: [‘QBtn’, ‘QIcon’]<br>}<br><code>&lt;q-icon name=&quot;alarm&quot; /&gt;</code></p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>使用Notify，ActionSheet时，需要在配置文件中提前声明<br>framework: {<br>  plugins: [‘Notify’, ‘ActionSheet’]<br>}</p>
<p>this.$q.notify(‘Some other message’)<br>和<br>import { Notify } from ‘quasar’<br>Notify.create(‘My message’)</p>
<p>framework:’all’导入所有组件用于测试</p>
<h2 id="平台判断"><a href="#平台判断" class="headerlink" title="平台判断"></a>平台判断</h2><p>this.$q.platform.is<br>this.$q.platform.has<br>this.$q.platform.within.iframe</p>
<h2 id="注入原型"><a href="#注入原型" class="headerlink" title="注入原型"></a>注入原型</h2><p>$q.version<br>$q.themem<br>$q.platform<br>$q.i18n<br>$q.cordova<br>$q.electron</p>
<h1 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h1><p>css 类似于bootstrap,通过配置约定的class名称，只需写少量class</p>
<!-- 产品的配置化风格 -->

<h2 id="颜色列表"><a href="#颜色列表" class="headerlink" title="颜色列表"></a>颜色列表</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">// class类</span><br><span class="line">class="text-primary"</span><br><span class="line">class="bg-positive"</span><br><span class="line"></span><br><span class="line">// Stylus变量</span><br><span class="line">color $red-1</span><br><span class="line">backgroung-color grey-5</span><br><span class="line"></span><br><span class="line">// 自定义颜色</span><br><span class="line">.text-brand&#123;</span><br><span class="line"><span class="code">    color:#afsfd</span></span><br><span class="line">&#125;</span><br><span class="line">// 使用自定义颜色</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">q-input</span> <span class="attr">color</span>=<span class="string">"brand"</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>import {colors} from ‘quasar’</p>
<p>设置自定义颜色，相当于setProperty()<br>colors.setBrand(‘light’,’#ddd’,’element’)<br>获取自定义颜色，相当于getPropertyValue()<br>colors.getBrand(‘primary’)<br>getComputedStyle(document.documentElement).getPropertyValue(‘–q-color-primary’)</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>h1</td>
<td>q-display-4</td>
</tr>
<tr>
<td>h2</td>
<td>q-display-3</td>
</tr>
<tr>
<td>h3</td>
<td>q-display-2</td>
</tr>
<tr>
<td>h4</td>
<td>q-display-1</td>
</tr>
<tr>
<td>h5</td>
<td>q-headline</td>
</tr>
<tr>
<td>h6</td>
<td>q-title</td>
</tr>
<tr>
<td>div</td>
<td>q-display-4subheading</td>
</tr>
<tr>
<td>div</td>
<td>q-body2</td>
</tr>
<tr>
<td>div</td>
<td>q-body1</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="粗细"><a href="#粗细" class="headerlink" title="粗细"></a>粗细</h2><p>text-weight-thin<br>text-weight-light<br>text-weight-regular<br>text-weight-medium<br>text-weight-bold<br>text-weight-bolder</p>
<h2 id="文本类型"><a href="#文本类型" class="headerlink" title="文本类型"></a>文本类型</h2><table>
<thead>
<tr>
<th><code>&lt;xxx /&gt;</code></th>
<th>标签</th>
</tr>
</thead>
<tbody><tr>
<td>samll</td>
<td>小文字</td>
</tr>
<tr>
<td>big</td>
<td>大文字</td>
</tr>
<tr>
<td>text-bold</td>
<td>strong粗体</td>
</tr>
<tr>
<td>text-italic</td>
<td>em斜体</td>
</tr>
<tr>
<td>text-right</td>
<td>右侧对齐</td>
</tr>
<tr>
<td>no-margin</td>
<td>设置0</td>
</tr>
<tr>
<td>no-outline</td>
<td>设置0</td>
</tr>
<tr>
<td>block</td>
<td>display设置0</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="间距"><a href="#间距" class="headerlink" title="间距"></a>间距</h2><p>格式：q-[p|m][t|r|b|l|a|x|y]-[none|xs|sm|md|lg|xl]</p>
<p>p-padding<br>m-margin</p>
<p>top、right、bootom、left、all、both left &amp; rigt、both top &amp; bottom</p>
<p>比如：<br>class=”q-pa-sm” // 方向小padding<br>class=”q-mt-md q-mr-sm” // 顶部中margin右边小margin</p>
<h2 id="flex系统"><a href="#flex系统" class="headerlink" title="flex系统"></a>flex系统</h2>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Quasar基于vue的前端框架</title>
    <url>/2020/06/28/Quasar%E5%9F%BA%E4%BA%8Evue%E7%9A%84%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<blockquote>
<p>一次编写，多端应用（非小程序）<br>开箱即用，基于webpack &amp; Vue</p>
</blockquote>
<a id="more"></a>

<h2 id="指南"><a href="#指南" class="headerlink" title="指南"></a>指南</h2><h3 id="官方文档-v1-12-8-版本，国内文档久未更新，本文参考国内站点"><a href="#官方文档-v1-12-8-版本，国内文档久未更新，本文参考国内站点" class="headerlink" title="官方文档 v1.12.8 版本，国内文档久未更新，本文参考国内站点"></a>官方文档 v1.12.8 版本，国内文档久未更新，本文参考国内站点</h3><p>蛮多人推荐 Quasar 的，github 星标也蛮多</p>
<p>而且目前的二级域名也很有意思<a href="http://v0-16.quasarchs.com/guide/quasar-roadmap.html" target="_blank" rel="noopener">v0-16</a></p>
<hr>
<h3 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h3><ul>
<li>响应式 Web</li>
<li>PWA/移动 app</li>
<li>桌面应用</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>开箱即用，默认配置集成（代码压缩、缓存清除、tree shaking、sourcemapping、热重载、代码分割和延迟加载、ES6 转译、i18n、代码检查、可访问性功能 and so on）</li>
<li>一次编写，多端部署</li>
<li>体积小</li>
<li>底层为 webpack</li>
<li>原生 ui 外观</li>
<li>文档简洁(真的吗，我不信。。。果然很全面，内置大量组件及布局，文档很长)</li>
<li>ie11+</li>
<li>组件丰富</li>
</ul>
<p>[Stylus 语法]</p>
<h3 id="简单的官网示例"><a href="#简单的官网示例" class="headerlink" title="简单的官网示例"></a>简单的官网示例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"q-app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"q-ma-md"</span>&gt;</span></span><br><span class="line">    abcdefg</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">q-btn</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"q-ma-md"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">color</span>=<span class="string">"primary"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">icon</span>=<span class="string">"warning"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">label</span>=<span class="string">"notify"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">click</span>=<span class="string">"notify"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"q-ma-md"</span>&gt;</span></span><br><span class="line">      show version is &#123;&#123;version&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">q-btn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#q-app'</span>,</span><br><span class="line">    data:()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            version:Quasar.version</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        notify:()&#123;</span><br><span class="line">            <span class="keyword">this</span>.$q.notify(<span class="string">'[show] version is'</span>+<span class="keyword">this</span>.$q.version);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>虽然你现在还没有了解过 Quasar 语法，但是可以猜测到<br>Quasar 可以结合 Vue 一起使用，Vue 中默认挂载了$q 代表 Quasar</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>三种方式，功能覆盖均不一致</p>
<ul>
<li>UMD(CDN)</li>
<li>Quasar Cli</li>
<li>Vue cli</li>
</ul>
<p>官方推荐用自带的 Cli</p>
<h3 id="入门套件安装"><a href="#入门套件安装" class="headerlink" title="入门套件安装"></a>入门套件安装</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node &gt; <span class="number">8</span></span><br><span class="line">npm install -g vue-cli</span><br><span class="line">npm install -g quasar-cli</span><br><span class="line">quasar init &lt;project&gt;</span><br><span class="line">quasar dev</span><br><span class="line">quasar build</span><br></pre></td></tr></table></figure>

<h3 id="quasar-conf-js-配置文件"><a href="#quasar-conf-js-配置文件" class="headerlink" title="quasar.conf.js 配置文件"></a>quasar.conf.js 配置文件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是对象，dev/build时创建，动态更改配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        <span class="comment">// 开发服务器8000,pwa9000,其他9090</span></span><br><span class="line">        prot:ctx.mode.spa ? <span class="number">8000</span></span><br><span class="line">            :(ctx.mode.pwa?<span class="number">9000</span>:<span class="number">9090</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    extras:[</span><br><span class="line">        <span class="comment">// ctx.theme.mat // 主题选择</span></span><br><span class="line">    ]</span><br><span class="line">    css:[</span><br><span class="line">        ctx.mode.spa?<span class="string">'app-spa.styl'</span>:<span class="literal">null</span>, <span class="comment">// 指向css/app-spa.sty</span></span><br><span class="line">        ctx.mode.cordova?<span class="string">'app-cordova.styl'</span>:<span class="literal">null</span> <span class="comment">// 指向css/app-cordova.styl</span></span><br><span class="line">    ]</span><br><span class="line">    build:&#123;</span><br><span class="line">        extendWebpack(cfg)&#123;</span><br><span class="line">            <span class="comment">// 扩展webpack功能加载器</span></span><br><span class="line">            cfg.module.rules.push(&#123;</span><br><span class="line">              test: <span class="regexp">/\.json$/</span>,</span><br><span class="line">              loader: <span class="string">'json-loader'</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 别名</span></span><br><span class="line">            cfg.resolve.alias = &#123;</span><br><span class="line">                 ...cfg.resolve.alias, <span class="comment">// 添加现有的别名，</span></span><br><span class="line">                <span class="comment">// 添加你自己的别名</span></span><br><span class="line">                myalias: path.resolve(__dirname, <span class="string">'./src/somefolder'</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方法二实现extendWebpack功能</span></span><br><span class="line">        chainWebpack (chain) &#123;</span><br><span class="line">            chain.module.rule(<span class="string">'json'</span>)</span><br><span class="line">              .test(<span class="regexp">/\.json$/</span>)</span><br><span class="line">              .use(<span class="string">'json-loader'</span>)</span><br><span class="line">                .loader(<span class="string">'json-loader'</span>)</span><br><span class="line">            chain.resolve.alias</span><br><span class="line">                .set(<span class="string">'myalias'</span>, path.resolve(__dirname, <span class="string">'./src/somefolder'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// supportIE,framework,animatins,sourceFiles等等配置类似webpack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由-按需路由-资源处理-接口代理和-vue-一致"><a href="#路由-按需路由-资源处理-接口代理和-vue-一致" class="headerlink" title="路由/按需路由/资源处理/接口代理和 vue 一致"></a>路由/按需路由/资源处理/接口代理和 vue 一致</h3><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>根据 quasar 规则解剖插件，以配合 quasar 运行</p>
<p>vue 根组件被实例化之前运行，当启动应用程序时，Quasar 将调用导出的函数，并将具有以下属性的一个对象传递给该函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; app, router, store, Vue &#125;) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 根实例，路由，状态库，vue</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>插件用途比如：<br>挂载实例 this.$xx、安装插件 Vue.use()、路由 router.beforeEach、状态存储库 vuex-router-sync、请求库 vuex-router-sync</p>
<p>插件使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用Quasar CLI在/plugins/下生成一个新的插件</span></span><br><span class="line">quasar <span class="keyword">new</span> plugin &lt;name&gt;</span><br><span class="line"><span class="comment">// 配置文件写用到的插件</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="string">'&lt;name&gt;'</span> <span class="comment">// 指向/src/plugins/&lt;name&gt;.js</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Quasar-生命周期"><a href="#Quasar-生命周期" class="headerlink" title="Quasar 生命周期"></a>Quasar 生命周期</h3><p>1、Quasar 初始化（组件、插件、指令、图标等）<br>2、Quasar Extras 导入（字体、动画、图标等）<br>3、Quasar css 和 css 导入<br>4、App.vue 加载<br>5、Store 导入（如果使用了 Store）<br>6、Quasar 插件导入完成</p>
<ul>
<li>7、在 Electron 模式下）Electron 被导入并注入 Vue 原型<ul>
<li>在 Cordova 模式下）收听“deviceready”事件</li>
<li>存在 Boot 插件，执行应用程序 Boot 插件</li>
<li>不存在 Boot 插件，使用根组件实例化 Vue 并附加到 DOM</li>
</ul>
</li>
</ul>
<p>所以 boot 插件最终是用来 new Vue(app)的</p>
<h3 id="vuex-模块"><a href="#vuex-模块" class="headerlink" title="vuex 模块"></a>vuex 模块</h3><p>和 vue 一致，quasar 提供了命令行模板简化初始化操作<br><code>quasar new store &lt;name&gt;</code>创建 module 模板，然后可以在主 store 里引用这个 modules</p>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>要不怎么说是 UI 框架呢，最大的特点还是它的主题风格<br>/css/themes<br>基于 Stylus 的 Material 和 iOS</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;style lang=<span class="string">"stylus"</span>&gt;</span><br><span class="line">  <span class="comment">// Quasar CLI提供提供的Webpack别名，解析Stylus的变量 @import '~variables'</span></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>9 个平台</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>mat</td>
<td>默认样式 Material 设计主题;Android 平台</td>
</tr>
<tr>
<td>ios</td>
<td>Apple 平台; iOS 主题</td>
</tr>
<tr>
<td>desktop</td>
<td>应用运行在一个桌面浏览器上</td>
</tr>
<tr>
<td>mobile</td>
<td>应用运行在一个手机浏览器上</td>
</tr>
<tr>
<td>cordova</td>
<td>Apache Cordova 包装的独立手机 App</td>
</tr>
<tr>
<td>electron</td>
<td>应用运行在 Electron 下</td>
</tr>
<tr>
<td>touch</td>
<td>触摸感知能力的平台</td>
</tr>
<tr>
<td>no-touch</td>
<td>没有触摸感知能力的平台</td>
</tr>
<tr>
<td>within-iframe</td>
<td>当整个网站都是在一个 IFRAME 标签下的时候</td>
</tr>
</tbody></table>
<h2 id="多端"><a href="#多端" class="headerlink" title="多端"></a>多端</h2><p>文档中有多端打包的配置描述，这里也简述下</p>
<h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><p>需要以下包含以下几点</p>
<p>渐进式-不强制用框架标准开发，生态按需使用<br>响应式-布局适配各端<br>离线访问-service workers 离线并更新保持新状态<br>app 风格-app 式的导航与交互<br>https 安全<br>可发现，mainifests 和 service worker 注册允许被搜索为应用程序<br>推送通知<br>桌面安装-桌面图标<br>可链接</p>
<p>Manifest 文件包含名称，图标和启动页<br>Service Worker 文件用来缓存资源，js 文件、请求数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加pwa模式</span></span><br><span class="line">quasar mode -a pwa</span><br><span class="line"><span class="comment">// 开发模式</span></span><br><span class="line">quasar dev -m pwa</span><br></pre></td></tr></table></figure>

<h3 id="mobile-APP"><a href="#mobile-APP" class="headerlink" title="mobile APP"></a>mobile APP</h3><p>Cordova 移动开发框架<br>既不是真正的原生移动 APP（因为所有的布局渲染都是通过 Web 视图而不是平台的本地 UI 框架完成的），<br>也不是纯粹的基于 Web 的 APP（它们不仅仅是 Web APP，因为可以包装成可分发的 APP, 并可访问本机设备 API）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装cli</span></span><br><span class="line">npm install -g cordova</span><br><span class="line"><span class="comment">// pc安装Android sdk 略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加Cordova模式，生成一个文件夹</span></span><br><span class="line">quasar mode -a cordova</span><br><span class="line"><span class="comment">// 开发模式</span></span><br><span class="line">quasar dev -m cordova -T [android|ios]</span><br></pre></td></tr></table></figure>

<p>Cordova 支持插件，配置获取原生设备信息<br>电池状态、相机、联系人、设备、设备运动、地理位置、媒体、媒体捕捉、网络信息、飞溅屏幕、振动、状态栏</p>
<p>插件执行依赖 Quasar 监听事件 deviceready 完成，然后挂载根 Vue 组件</p>
<h3 id="pc-Electron"><a href="#pc-Electron" class="headerlink" title="pc Electron"></a>pc Electron</h3><p>桌面 GUI 应用程序，后端 NodeJs，前端 Chromium<br>每个 Electron 应用有 2 个线程，主线程处理窗口和启动初始化，渲染线程处理 UI</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加模式</span></span><br><span class="line">quasar mode -a electron</span><br><span class="line"><span class="comment">// 开发模式</span></span><br><span class="line">quasar dev -m electron -t [mat|ios]</span><br></pre></td></tr></table></figure>

<!-- - vue cli
  - vue --version 3.x
  - vue add quasar
  - 配置vue.config.js -->]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解js的面向对象</title>
    <url>/2020/06/26/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3js%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<blockquote>
<p>关键字：封装、继承、多态</p>
</blockquote>
<a id="more"></a>

<p>对象 &gt;&gt;&gt; object</p>
<blockquote>
<p>面向对象三大特性可以</p>
</blockquote>
<p>更轻松的编写代码，用更轻松的方式将代码组织起来<br>在不了解他人代码的情况下配合开发<br>不需要知道程序的每一步细节</p>
<p>对于框架来说，组件背后封装了大量逻辑，比如如何渲染，检测props变化后组件渲染，由于框架已经实现，我们只要去继承使用</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>不用知道内部工作原理，拿来即用</p>
<ul>
<li>汽车，手机</li>
<li>jq 库和 npm 包</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>重用已有的类，不用从零开始，提高维护性</p>
<ul>
<li>基类是车，不同的内饰，外观，功能衍生出各种型号的车</li>
<li>基类是角色，玩家和敌人都有生命值，控制行走，技能</li>
<li>基类是武器，攻击值，攻击距离和攻击效果</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>建立在继承上，才有多态</p>
<ul>
<li>通过调用 type，程序自动选择合适的操作</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>块级作用域和变量提升</title>
    <url>/2020/06/25/%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<a id="more"></a>

<p>上一篇(js 中 var-let-const 的区别)通过变量声明的不同方式简单描述了区别<br>这一篇继续看看变量提升和函数提升</p>
<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">在群里看到一道题: <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    a = <span class="number">21</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a1"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a2"</span>, a);</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>var 声明的变量会提升至最顶层</p>
<p>let,const 的特殊声明也会提前，并标记为不可再声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 正常打印</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 已声明未初始化</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是【 定义函数名变量, 指针指向 函数内存块】</p>
<p>函数存在块级作用域</p>
<p>将函数声明提到函数级作用域最前面，然后将函数定义提升到块级作用域最前面</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="comment">// 函数 a 的声明提前</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>; <span class="comment">// 赋值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 函数定义 a 声明提升到块级最前面</span></span><br><span class="line">    a = <span class="number">1</span>; <span class="comment">// 块级作用域最前面的函数 a 重置为 1</span></span><br><span class="line">    a = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<br>a1 = ‘21’<br>a2 = ‘1’</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js异常捕获</title>
    <url>/2020/06/23/js%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</url>
    <content><![CDATA[<blockquote>
<p>try catch/Promise 如何捕获运行时异常</p>
</blockquote>
<a id="more"></a>

<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h2><p>能捕捉到的异常必须是线程执行已经进入 try catch, 但 try catch 未执行完时抛出的异常</p>
<h3 id="try-catch的执行周期"><a href="#try-catch的执行周期" class="headerlink" title="try catch的执行周期"></a>try catch的执行周期</h3><blockquote>
<p>执行前 不能捕捉异常</p>
</blockquote>
<p>语法异常（syntaxError）在语法检查阶段报错，未进入 try catch </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    a.</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error"</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行中 能捕捉到异常</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    a.b</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error"</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行后 不能捕捉异常</p>
</blockquote>
<p>线程已经执行完</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;a.b&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error"</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote>
<p>catch</p>
</blockquote>
<p>try catch 无法捕捉 Promise  的异常，用Promise.prototype.catch<br>同步和异步的 Promise 异常都是由 reject 和 Promise.prototype.catch 来捕获</p>
<p>因为 Promise 在执行回调中都用 try catch 包裹起来了，所有的异常都被内部捕获到了，并未往上抛异常，因此在外层的 try catch 看来没有异常</p>
<blockquote>
<p>unhandledrejection</p>
</blockquote>
<p>通过监听unhandledrejection事件，可以捕获未处理的Promise错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unhandledrejection'</span>, event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.reason);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'gg'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>rejectionhandled</p>
</blockquote>
<p>当一个Promise错误最初未被处理，但是稍后又得到了处理，则会触发rejectionhandled事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'rejectionhandled'</span>, event =&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejection handled'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'gg'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = foo();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    f.catch(<span class="function"><span class="params">e</span> =&gt;</span>&#123;&#125;);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode插件夸夸神器Rainbow-Fart</title>
    <url>/2020/06/19/vscode%E6%8F%92%E4%BB%B6%E5%A4%B8%E5%A4%B8%E7%A5%9E%E5%99%A8Rainbow-Fart/</url>
    <content><![CDATA[<blockquote>
<p>Rainbow Fart语音包<br>vscode/git版本升级</p>
</blockquote>
<a id="more"></a>

<h2 id="这是什么"><a href="#这是什么" class="headerlink" title="这是什么"></a>这是什么</h2><p><a href="https://github.com/SaekiRaku/vscode-rainbow-fart/blob/master/README.zh.md" target="_blank" rel="noopener">VSCode Rainbow Fart</a> 是一个在你编程时持续夸你写的牛逼的扩展，可以根据代码关键字播放贴近代码意义的真人语音</p>
<p>扩展仓库搜索<code>Rainbow Fart</code>（五星那个就是了</p>
<p>通过打开命令面板，执行Rainbow Fart，点击open按钮，会启动一个7777端口的server需要授权即可<br><a href="http://127.0.0.1:7777/" target="_blank" rel="noopener">http://127.0.0.1:7777/</a></p>
<p>当你敲代码时候就会出提示音啦（建议带上耳机</p>
<h2 id="vscode升级版本"><a href="#vscode升级版本" class="headerlink" title="vscode升级版本"></a>vscode升级版本</h2><p>有vscode版本限制，我把v1.24升级到了v1.46即可正常从商店安装</p>
<p>升级版本后不用每次提交到仓库都敲一遍账号密码了，vscode简化了这步操作，赞</p>
<h2 id="git升级版本"><a href="#git升级版本" class="headerlink" title="git升级版本"></a>git升级版本</h2><p>升级vscode v1.46之后遇到了暂存文件时git <code>&lt;file&gt; is outside directory</code>的问题，通过github上的<a href="https://github.com/microsoft/vscode/issues/99881#issuecomment-643056608" target="_blank" rel="noopener">issue</a>可以升级git版本解决</p>
<p>git –version<br>当前版本是2.7.2，不支持git update,只有<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">手动安装</a>到原目录</p>
<p>2.14+版本可以使用<code>git update</code><br>2.17.1+版本可以使用<code>git update-git-for-windows</code></p>
]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>必知必会的bind-call-apply</title>
    <url>/2020/06/18/%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84bind-call-apply/</url>
    <content><![CDATA[<blockquote>
<p>this是运行时才确定，用来改变this的指向<br>执行函数并绑定参数 </p>
</blockquote>
<a id="more"></a>

<p>之前一篇文章<a href="../../../../2020/06/14/通过数组边遍历边删除来回顾迭代器/">通过数组边遍历边删除来回顾迭代器</a>附录中描述了一遍this与箭头函数的几种情况</p>
<p><code>当this是null、undefined时，默认指向window</code><br><code>箭头函数无arguments 对象，用 Rest 参数代替</code></p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>call(‘绑定this’,’参数’,’列表’)      立即调用<br>apply(‘绑定this’,[‘参数’,’数组’])   立即调用<br>bind(‘绑定this’,’参数’,’列表’)      返回函数需要再次调用</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用其他函数并传入参数</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    message: <span class="string">'hello: '</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.message + str1 + <span class="string">' '</span> + str2)</span><br><span class="line">&#125;</span><br><span class="line">getName.call(obj, <span class="string">'a'</span>, <span class="string">'b'</span>) <span class="comment">// this指向了obj</span></span><br><span class="line">getName.apply(obj, [<span class="string">'a'</span>, <span class="string">'b'</span>]) <span class="comment">// hello : a b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">89</span>, <span class="number">46</span>]</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.call(<span class="literal">null</span>,arr[<span class="number">0</span>],arr[<span class="number">1</span>],arr[<span class="number">2</span>])<span class="comment">// 89</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr)<span class="comment">//89 合理使用apply处理</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将类数组转化为数组</span></span><br><span class="line"><span class="keyword">var</span> trueArr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br><span class="line"><span class="comment">// 数组arr1更新合并</span></span><br><span class="line"><span class="keyword">var</span> total = [].push.apply(arr1, arr2);</span><br><span class="line"><span class="comment">// 类型判断</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj)</span><br><span class="line"><span class="comment">// 代理 console.log</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> log = <span class="built_in">console</span>.log()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">var</span> Person1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Dot'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Person2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.getname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用Person1对象代替this，使Person2中继承Person1的属性和方法</span></span><br><span class="line">    Person1.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Person3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Person1.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)<span class="comment">//将父元素所有方法在这里执行一遍就继承了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person2();</span><br><span class="line">person.getname();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数珂里化</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>); <span class="comment">// 保存x=1</span></span><br><span class="line"><span class="keyword">var</span> addTen = add(<span class="number">10</span>); <span class="comment">// 保存x=10</span></span><br><span class="line">increment(<span class="number">2</span>);<span class="comment">// 3   1+2</span></span><br><span class="line">addTen(<span class="number">2</span>);<span class="comment">// 12     10+2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现bind</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>,                        <span class="comment">// 保存原函数</span></span><br><span class="line">            context = [].shift.call(<span class="built_in">arguments</span>), <span class="comment">// 保存需要绑定的this上下文</span></span><br><span class="line">            args = [].slice.call(<span class="built_in">arguments</span>);    <span class="comment">// 剩余的参数转为数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                    <span class="comment">// 返回一个新函数</span></span><br><span class="line">            self.apply(context, [].concat.call(args, [].slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>文章题目也不好取啊- -想起之前有本工具手册《MySQL必知必会》，那就用你好了</p>
<hr>
<h1 id="附录1-this"><a href="#附录1-this" class="headerlink" title="附录1 this"></a>附录1 this</h1><p>我们再来看看this的更多例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a1:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// obj</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a3:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a1() <span class="comment">// =&gt; obj.a1.call(undefined) 默认绑定window</span></span><br><span class="line">obj.a2() <span class="comment">// =&gt; obj.a2.call(obj)</span></span><br><span class="line"><span class="keyword">var</span> obja3 = obj.a3;</span><br><span class="line">obja3()  <span class="comment">// =&gt; obj 绑定为window了</span></span><br><span class="line"></span><br><span class="line">id.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// 指向绑定的id元素</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里说一下setTimeout异步函数</span></span><br><span class="line"><span class="comment">// 当callback是普通函数时this是window，丢失this</span></span><br><span class="line"><span class="comment">// 当callback是箭头函数时this是绑定了当前所在作用域的this</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 这里的this都指向实例</span></span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="comment">// 箭头函数也一样</span></span><br><span class="line">    <span class="keyword">this</span>.getAge = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'P'</span>,<span class="number">2</span>)</span><br><span class="line">p.getAge()<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="附录2-函数执行时说明"><a href="#附录2-函数执行时说明" class="headerlink" title="附录2 函数执行时说明"></a>附录2 函数执行时说明</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj1.fn() </span><br><span class="line">obj1.fn.call(obj1);</span><br><span class="line"></span><br><span class="line">fn1()</span><br><span class="line">fn1.call(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">f1(f2)</span><br><span class="line">f1.call(<span class="literal">null</span>,f2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj1.fn() </span><br><span class="line">obj1.fn.apply(obj1);</span><br><span class="line"></span><br><span class="line">fn1()</span><br><span class="line">fn1.apply(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">f1(f2)</span><br><span class="line">f1.apply(<span class="literal">null</span>,f2)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>四类浏览器资源缓存</title>
    <url>/2020/06/17/%E5%9B%9B%E7%B1%BB%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<blockquote>
<p>优先级顺序依次为<code>Memory Cache</code>、<code>Service Worker Cache</code>、<code>HTTP Cache</code>、<code>Push Cache</code></p>
</blockquote>
<a id="more"></a>

<p>面试时经常被问到对缓存有什么理解</p>
<p>好吧每次都是回答的cookie/localstorage/sessionstorage三个本地存储的区别,而忽略了前端最常见的cache，有时候资源更新了页面资源没引用新的文件，就是cache在搞事情</p>
<p>一般资源会经过<code>浏览器发起请求</code>，<code>服务端处理请求</code>，<code>浏览器响应加载</code>三个阶段<br>缓存的作用是性能优化，减少网络请求，减少延迟，重复利用</p>
<hr>
<h2 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h2><p>资源(js,font,img)从内存缓存中获取<br>不会向服务器请求<br>关闭页面会释放内存<br>这个词常在network面板的资源状态中看到from memory cache  </p>
<p>还会看见from disk cache<br>这个是指资源(css)存在硬盘上，关闭页面不会删除资源</p>
<p><code>&lt;link rel=&quot;prefetch&quot;&gt;</code>异步加载优化</p>
<h2 id="Service-Worker-Cache"><a href="#Service-Worker-Cache" class="headerlink" title="Service Worker Cache"></a>Service Worker Cache</h2><p>浏览器离线缓存<br>Service Worker可以拦截修改访问的资源请求，不能访问dom，异步执行，必须https</p>
<p>cache.addAll()缓存文件<br>caches.match(event.request)缓存请求内容</p>
<h2 id="HTTP-Cache"><a href="#HTTP-Cache" class="headerlink" title="HTTP Cache"></a>HTTP Cache</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>200 不请求服务器，使用缓存</p>
<ul>
<li>expires过期时间内不请求  </li>
<li>cache-control控制资源有效时间<ul>
<li>max-age设置有效时间</li>
<li>s-maxage更高优先级，代理服务器中只认这个字段作为有效时间</li>
<li></li>
<li>public客户端和代理服务器可缓存</li>
<li>private只有客户端可缓存</li>
<li></li>
<li>no-cache进行协商缓存方案</li>
<li>no-store直接请求新资源</li>
</ul>
</li>
</ul>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>304 服务器告知资源未更新，使用缓存</p>
<ul>
<li>last-modified资源最后修改时间 &gt; If-modified-since</li>
<li>etag唯一编码 &gt; If-None-Match</li>
</ul>
<h3 id="访问-刷新缓存"><a href="#访问-刷新缓存" class="headerlink" title="访问/刷新缓存"></a>访问/刷新缓存</h3><ul>
<li>标签进入、输入url回车进入<ul>
<li>step1 判断no-cache/no-store<ul>
<li>强缓存    判断expires是否过期</li>
</ul>
</li>
<li>step2 协商缓存</li>
<li>step3 返回新资源200</li>
</ul>
</li>
<li>按刷新按钮、F5 刷新、网页右键“重新加载”<ul>
<li>step1 相当于cache-control 的 max-age = 0</li>
<li>step2 协商缓存</li>
</ul>
</li>
<li>ctrl + F5 强制刷新<ul>
<li>step1 强制设置cache-control: no-cache</li>
</ul>
</li>
</ul>
<h2 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h2><p>推送缓存<br>属于http/2，当以上缓存都未命中时触发<br>会话结束释放缓存</p>
<h2 id="合理使用缓存"><a href="#合理使用缓存" class="headerlink" title="合理使用缓存"></a>合理使用缓存</h2><ul>
<li><p>频繁变动的资源</p>
<ul>
<li>Cache-Control: no-cache，减少响应数据大小</li>
</ul>
</li>
<li><p>不变化的资源</p>
<ul>
<li>Cache-Control: max-age=31536000强制缓存</li>
<li>加版本号更新</li>
</ul>
</li>
</ul>
<hr>
<p>推荐浪里行舟的这篇文章<a href="https://www.jianshu.com/p/54cc04190252" target="_blank" rel="noopener">深入理解浏览器的缓存机制</a>，有使用缓存的流程图</p>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器Iterator与生成器Generator</title>
    <url>/2020/06/16/%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8Generator/</url>
    <content><![CDATA[<blockquote>
<p>迭代器是对象<br>生成器是返回迭代器的函数<br>够直接吧</p>
</blockquote>
<a id="more"></a>

<h1 id="迭代器是什么"><a href="#迭代器是什么" class="headerlink" title="迭代器是什么"></a>迭代器是什么</h1><p>迭代器是包含next方法的<code>对象</code></p>
<p>iterable（可迭代对象）:被外界访问的内部元素的数据结构,实现了 Symbol.iterator 方法<br>iterator（迭代器）:遍历数据结构元素的指针</p>
<h2 id="实现一个迭代器"><a href="#实现一个迭代器" class="headerlink" title="实现一个迭代器"></a>实现一个迭代器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义迭代,数组倒序</span></span><br><span class="line"><span class="keyword">const</span> myArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">myArr[<span class="built_in">Symbol</span>.iterator]= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="keyword">this</span>.length;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="keyword">this</span>[index],<span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">true</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [...myArr]; // [3, 2, 1]</span></span><br><span class="line"><span class="comment">// Array.from(myArr); // [3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<p>myArr有符合标准的 <code>Symbol.iterator 接口</code>，那就是 可迭代的(Iterator) ，调用这个<code>接口</code>返回的对象就是一个 迭代器</p>
<h2 id="关闭迭代器"><a href="#关闭迭代器" class="headerlink" title="关闭迭代器"></a>关闭迭代器</h2><p>1、当next()方法返回done:true时，正常执行结束关闭<br>2、调用符合规范的return()方法关闭</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIterable</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> iterable =&#123;</span><br><span class="line">        [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        next()&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">false</span>,<span class="attr">value</span>:<span class="string">'- -'</span>&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">return</span>()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'~~'</span>);</span><br><span class="line">            <span class="keyword">return</span>&#123;<span class="attr">done</span>:<span class="literal">false</span>,<span class="attr">value</span>:<span class="literal">undefined</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iterable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> myIterable()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生成器Generator"><a href="#生成器Generator" class="headerlink" title="生成器Generator"></a>生成器Generator</h1><p>生成器是返回迭代器的函数<br>Generator既是迭代器也是可迭代对象， 有next()和<a href="">Symbol.iterator</a></p>
<h2 id="使用生成器"><a href="#使用生成器" class="headerlink" title="使用生成器"></a>使用生成器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getIterator = <span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第1次"</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"A"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第2次"</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"B"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第3次"</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"C"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = getIterator();</span><br><span class="line"><span class="comment">// 每次调用next会在yield处返回结果并暂停</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); </span><br><span class="line"><span class="comment">// 传参会替换上一次yield的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">1</span>)); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getIterator2 = <span class="function"><span class="keyword">function</span> *(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ；i &lt; array.length; i++)&#123;</span><br><span class="line">       <span class="keyword">yield</span> array[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目 - 3个苹果，2个香蕉，发完了苹果才能发香蕉</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成器委托</span><br><span class="line">getAppleIterator &#x3D;  function*() &#123;</span><br><span class="line">    yield &quot;a1&quot;</span><br><span class="line">    yield &quot;a2&quot;</span><br><span class="line">    yield &quot;a3&quot;</span><br><span class="line">&#125;</span><br><span class="line">getBananaIterator &#x3D; function*()&#123;</span><br><span class="line">    yield &quot;b1&quot;</span><br><span class="line">    yield &quot;b2&quot;</span><br><span class="line">&#125;</span><br><span class="line">getFruitIterator &#x3D;  function*()&#123;</span><br><span class="line">    yield *getAppleIterator();</span><br><span class="line">    yield *getBananaIterator();</span><br><span class="line">&#125;</span><br><span class="line">fruit &#x3D; getFruitIterator();</span><br><span class="line">console.log(fruit.next());</span><br></pre></td></tr></table></figure>

<p>写到这里，想起以前看《你不知道的js》中有generator的概念，遂又去翻了翻</p>
<p>生成器里写业务，任务工具执行，不关心next()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行callback的里所有内容直到done:true</span></span><br><span class="line"><span class="keyword">let</span> run = <span class="function"><span class="keyword">function</span>(<span class="params">requestIteratorCreator</span>)</span>&#123;</span><br><span class="line">    task = requestIteratorCreator();</span><br><span class="line">	<span class="keyword">let</span> result = task.next(); <span class="comment">// 先执行</span></span><br><span class="line">	doTask = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!result.done)&#123;</span><br><span class="line">            result = task.next(result.value);</span><br><span class="line">            doTask()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	doTask() <span class="comment">// 看看是否继续执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> requestIteratorCreator = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">const</span> result = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">yield</span> result</span><br><span class="line">&#125;</span><br><span class="line">run(requestIteratorCreator)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>一些示例</title>
    <url>/2020/06/15/%E4%B8%80%E4%BA%9B%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<a id="more"></a>
<p>面试时遇到了那些你处理哪些业务场景使用xxx就一脸懵，想不起来啊<br>不知道大家有没有这种感觉，背古诗上半句能接下半句，但是下半句去接上半句就有点难了<br>更何况有些是特性，而非业务<br>anyway,开个目录记录下来，之后一点点在这里补充吧</p>
<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将变量保存进函数，待执行</span><br><span class="line">function makeSizer(size) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    console.log(size)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var size1 &#x3D; makeSizer(10);</span><br><span class="line">size1();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 私有化变量</span><br><span class="line">var Counter &#x3D; function() &#123;</span><br><span class="line">    var privateCounter &#x3D; 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        value: function() &#123;</span><br><span class="line">            return privateCounter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var counter1 &#x3D; Counter();</span><br><span class="line">counter1.value()</span><br></pre></td></tr></table></figure>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工具函数,工具类</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">checkList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">    checkCodeNum(codeNum, maxLen = <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (codeNum == <span class="string">''</span> || codeNum.length != maxLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取字符串并替换节点内容</span></span><br><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"workType"</span> v-getBaTitle=<span class="string">"item.position"</span>&gt;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">directives: &#123;</span></span><br><span class="line"><span class="regexp">    getBaTitle: &#123;</span></span><br><span class="line"><span class="regexp">        bind: function(el, binding) &#123;</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 通过binding.value获取绑定的值，并写入节点内</span></span><br><span class="line"><span class="regexp">            el.innerHTML = binding.value.split("-")[1] || "xxx";</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="遍历时删除，置顶合并数组"><a href="#遍历时删除，置顶合并数组" class="headerlink" title="遍历时删除，置顶合并数组"></a>遍历时删除，置顶合并数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 置顶数组中的指定对象</span></span><br><span class="line">baList(state) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state.list.length == <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> needTopItemArr = [];<span class="comment">// 保存取出来的对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; state.list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state.list[i].serviceStar) &#123;</span><br><span class="line">            needTopItemArr.push(state.list[i]);</span><br><span class="line">            state.list.splice(i, <span class="number">1</span>);</span><br><span class="line">            i--;<span class="comment">// for边循环边删除需要修改i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> needTopItemArr.concat(state.list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p>当有需求改动ui框架样式是，scoped 中的样式不生效，用 /deep/ 解决<br>但是 ios 移动端还不支持，只能这部分重写的内容不要放在 scoped 中</p>
]]></content>
  </entry>
  <entry>
    <title>通过数组边遍历边删除来回顾迭代器</title>
    <url>/2020/06/14/%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E8%BE%B9%E9%81%8D%E5%8E%86%E8%BE%B9%E5%88%A0%E9%99%A4%E6%9D%A5%E5%9B%9E%E9%A1%BE%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>遍历时删除会出现什么问题<br>迭代器是什么,for,forEach,for in,for of都是什么</p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="遍历时删除会出现什么问题"><a href="#遍历时删除会出现什么问题" class="headerlink" title="遍历时删除会出现什么问题"></a>遍历时删除会出现什么问题</h1><p>先看这个例子，遍历数组时删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    arr.splice(i,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(i,arr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">arr.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    arr.splice(index,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 0,[2,3]</span></span><br><span class="line"><span class="comment">// 1,[2]</span></span><br></pre></td></tr></table></figure>
<p>发现结果和期望不一样，应该是个空数组<br>因为当修改原数组时，下一轮用的是这个新的数组，所以第二轮实际上是[2,3]的arr[1]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正序删除，需要更新下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    arr.splice(i,<span class="number">1</span>);</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反序删除</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = arr.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    arr.splice(i,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，java中有iterator.remove()方法进行删除</p>
<hr>
<h1 id="for-forEach-for-in-for-of差异"><a href="#for-forEach-for-in-for-of差异" class="headerlink" title="for,forEach,for in,for of差异"></a><code>for</code>,<code>forEach</code>,<code>for in</code>,<code>for of</code>差异</h1><p>通过MDN来<code>简单</code>回顾一下它们</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a><code>for</code></h2><p>常见的处理<code>数组</code>的循环嘛<br>for (let i = 0; i &lt; 9; i++) {}</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>提前结束<ul>
<li>break退出循环</li>
<li>continue提前结束本次循环，开始下一轮</li>
</ul>
</li>
<li>是所有循环语法糖的基础 </li>
<li>作用域<ul>
<li>使用 var 声明的变量与 for 循环处在同样的作用域中。用 let 声明的变量是语句的局部变量。</li>
</ul>
</li>
</ul>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><code>forEach</code></h2><p>依旧是处理<code>数组</code>的循环，对每个元素依次执行一次指定函数  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.forEach(<span class="function">(<span class="params">item,index,_arr</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// _arr是数组对象本身，不会改变原数组</span></span><br><span class="line">    <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>)</span><br><span class="line">&#125;,<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
<p>那些已删除或者未初始化的项将被跳过（例如稀疏数组[1,,3,,5]）<br>(callback,thisArg) 还接收第二参数this，用法参照函数的this规则，默认指向window，见文末1</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>提前结束<ul>
<li>throw抛出异常</li>
</ul>
</li>
<li>实现浅拷贝，和循环类似<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> copy = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj)) <span class="comment">// 返回指定对象的原型</span></span><br><span class="line">    <span class="keyword">const</span> propNames = <span class="built_in">Object</span>.getOwnPropertyNames(obj); <span class="comment">// 返回属性的属性名</span></span><br><span class="line">    propNames.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, name); <span class="comment">// 返回属性名对应的四大属性描述符configurable,enumerable,value,writable</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(copy, name, desc); <span class="comment">// 更新对象的现有属性</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在遍历时删除会遇到同样的问题，因为每次都是以当前arr执行</li>
<li>扁平化数组,建议使用flat()<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(i))</span><br><span class="line">            result.push(...flatten(i));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result.push(i);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> problem = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>], <span class="number">8</span>, <span class="number">9</span>]];</span><br><span class="line">flatten(problem); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h2><p>和forEach一样都是遍历数组的每一项<br>map()返回新数组，forEach()返回undefined<br>map不会改变原数组，forEach会改变原数组</p>
<h2 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a><code>for in</code></h2><p>以<code>任意顺序</code>遍历一个<code>对象</code>的除Symbol以外的<code>可枚举属性enumerable</code>（包括它的原型链上的可枚举属性）</p>
<p>用于调试，可以更方便的去检查对象属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(prop))&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>迭代过程中不要进行该<code>对象</code>的增删改<ul>
<li>不保证新属性会被访问到</li>
</ul>
</li>
<li>不建议用于<code>数组</code><ul>
<li>因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素</li>
</ul>
</li>
<li>只迭代对象自身的属性<ul>
<li>getOwnPropertyNames() 或 hasOwnProperty() 或 propertyIsEnumerable 确定某属性是否是对象本身的属性</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个例子可以看到由于存在原型链继承规则</span></span><br><span class="line"><span class="comment">// 所以iterable要过滤，否则需要遍历很多不相关元素</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">iterable.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// logs 0, 1, 2, "foo", "arrCustom", "objCustom"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iterable.hasOwnProperty(i)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// logs 0, 1, 2, "foo"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a><code>for of</code></h2><p>在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul>
<li>弥补 forEach 和 for…in 的缺点</li>
<li>提前结束<ul>
<li>break, continue, throw</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String </span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="string">"boo"</span>;</span><br><span class="line"><span class="comment">// 'a' 'b' 'c'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypedArray </span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0x00</span>, <span class="number">0xff</span>]);</span><br><span class="line"><span class="comment">// 0 255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"a"</span>, <span class="number">1</span>], [<span class="string">"b"</span>, <span class="number">2</span>], [<span class="string">"c"</span>, <span class="number">3</span>]]);</span><br><span class="line"><span class="comment">// ["a", 1] ["b", 2] ["c", 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments 对象</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> argument <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(argument);<span class="comment">// 1 2 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> articleParagraphs = <span class="built_in">document</span>.querySelectorAll(<span class="string">"article &gt; p"</span>);</span><br><span class="line"><span class="comment">// item.classList.add("read");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>) </span>&#123;<span class="keyword">yield</span> curr;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> fibonacci()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for-in-of区别"><a href="#for-in-of区别" class="headerlink" title="for in/of区别"></a>for in/of区别</h2><p>迭代方式</p>
<p>for…in 语句以任意顺序迭代对象的<code>可枚举属性</code>。<br>for…of 语句遍历<code>可迭代对象</code>定义要迭代的数据。</p>
<h1 id="迭代器是什么"><a href="#迭代器是什么" class="headerlink" title="迭代器是什么"></a>迭代器是什么</h1><h2 id="迭代器是包含next方法的对象"><a href="#迭代器是包含next方法的对象" class="headerlink" title="迭代器是包含next方法的对象"></a>迭代器是包含next方法的<code>对象</code></h2><p>{done:是否结束，产生下一个值,value:返回值}<br>本质上，迭代器会不断调用其 next() 方法直到返回 done: true  </p>
<p>Array 或 Map 等内置<code>可迭代对象</code>有默认的迭代行为<br>Object 则<code>没有</code>所以不能直接用for…of ，可以用Object.keys(obj)，Object.entries(obj)</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">for..of</span><br><span class="line">扩展运算符</span><br><span class="line">yield*</span><br><span class="line">解构赋值</span><br><span class="line">内置API在接收数组参数时会调用数组的迭代行为</span><br><span class="line"><span class="code">    Array.from()</span></span><br><span class="line"><span class="code">    Map(),Set(),WeakMap(),WeakSet()</span></span><br><span class="line"><span class="code">    Promise.all()/Promise.race()</span></span><br></pre></td></tr></table></figure>
<hr>
<hr>
<hr>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>这里来枚举一下forEach中的this情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    arrFunc1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,_arr</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 普通函数，普通回调，【检查】thisArg，this-&gt;arr</span></span><br><span class="line">            <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>) </span><br><span class="line">        &#125;,arr)</span><br><span class="line">    &#125;,</span><br><span class="line">    arrFunc2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function">(<span class="params">item,index,_arr</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 普通函数，箭头回调，【忽视】thisArg，this-&gt;obj</span></span><br><span class="line">            <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>) </span><br><span class="line">        &#125;,arr)</span><br><span class="line">    &#125;,</span><br><span class="line">    arrFunc3:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,_arr</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 箭头函数，普通回调，【检查】thisArg，this-&gt;arr</span></span><br><span class="line">            <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>) </span><br><span class="line">        &#125;,arr)</span><br><span class="line">    &#125;,</span><br><span class="line">    arrFunc4:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function">(<span class="params">item,index,_arr</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 箭头函数，箭头回调，【忽视】thisArg，this-&gt;window</span></span><br><span class="line">            <span class="built_in">console</span>.log(item,index,_arr,<span class="keyword">this</span>) </span><br><span class="line">        &#125;,arr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.arrFunc1()</span><br></pre></td></tr></table></figure>

<pre><code class="js"></code></pre>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>最近在看</title>
    <url>/2020/06/12/%E6%9C%80%E8%BF%91%E5%9C%A8%E7%9C%8B/</url>
    <content><![CDATA[<blockquote>
<p>想知道我最近关注什么 点进来看看<br>←👈猜猜出副标题里的诗句数量 左上角</p>
</blockquote>
<!-- > 找工作中 T-T....base上海，[查看cv](http://www.leow.net.cn/resume/) -->
<a id="more"></a>
<!-- 正在做 - 2020/6 -->
<p><code>uniapp v2.7</code><br><code>ECharts v4.8</code><br><code>vue-element-admin v4</code><br><code>Element ui</code> (维护频率变低，要流失到ant了- -)</p>
<p>小目标 - 2020<br>更新博客-&gt;github标绿/天</p>
<!-- 计划项 - 2020 -->
<p><code>docker+jenkins</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">周边同事都在用的自动部署方案</span><br></pre></td></tr></table></figure>

<p><code>quasar</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">ui库吧</span><br></pre></td></tr></table></figure>

<p><code>vue stable v3</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">API解构，更hooks了</span><br></pre></td></tr></table></figure>

<p><code>webpack stable v5</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">微前端的模块化</span><br><span class="line">服务暴露独立编译的模块，宿主远程引用</span><br><span class="line">避免重复加载</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>如果你有更有意思的推荐，可以在下方留言给我~</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>通过await在definePorperty中的表现重新认识async</title>
    <url>/2020/06/12/%E9%80%9A%E8%BF%87await%E5%9C%A8definePorperty%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86async/</url>
    <content><![CDATA[<blockquote>
<p>defineProperty中无法获取await get()的值<br>再来看看async/await</p>
</blockquote>
<a id="more"></a>
<p>群里聊天时看到抛出的一个问题和相关代码，<code>Object.defineProperty</code>中的get使用await为啥不能同步获取到值<br>用这俩语法糖执行同步任务也有一段时间了，看到这个问题还是有点懵，经过实践解决了这个问题<br>那通过<code>MDN</code>重新再了解一下async/await  </p>
<hr>
<h2 id="异步转同步的发展过程"><a href="#异步转同步的发展过程" class="headerlink" title="异步转同步的发展过程"></a>异步转同步的发展过程</h2><ul>
<li>ajax需要在callback中获取结果，当有请求结果和请求参数有相互依赖时需要多层嵌套，出现回调地狱的代码问题  </li>
<li>而Promise可以在then()中拿到结果，让每步调用写法更清晰，解决回调地狱  </li>
<li>async更简洁，更优雅的错误处理，易于调试  </li>
</ul>
<p><code>async</code>定义一个返回Promise对象的异步函数<br><code>await</code>会暂停异步函数的执行,并等待Promise执行，然后继续执行异步函数，并返回结果<br>是generator生成器的语法糖  </p>
<h2 id="通过俩例子了解一下async-await"><a href="#通过俩例子了解一下async-await" class="headerlink" title="通过俩例子了解一下async/await"></a>通过俩例子了解一下async/await</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'异步结果'</span>, val)</span><br><span class="line">            res(val)</span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'异步getData'</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getVal</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> getData(val)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'正常的异步转同步'</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'getVal'</span>, getVal(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>会发现打印的是一个Promise对象 pending状态，这也符合async的返回，而内部的函数是正常同步执行的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData2</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'异步2结果'</span>, val)</span><br><span class="line">            res(val)</span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'异步2getData2'</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getVal2</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> getData2(val)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'依旧正常的异步转同步'</span>, result)</span><br><span class="line">&#125;</span><br><span class="line">getVal2(<span class="number">33</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'这行还是会先于getVal2执行的哦'</span>)</span><br></pre></td></tr></table></figure>
<p>原来，async/await 保证的是，同一个作用域中存在同步代码和异步代码时，等待获取到promise结果后再执行后续代码</p>
<h2 id="如何解决get中的await取值"><a href="#如何解决get中的await取值" class="headerlink" title="如何解决get中的await取值"></a>如何解决get中的await取值</h2><p>定义一个函数，改变对象的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">target, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="comment">// console.log('执行get', val)</span></span><br><span class="line">            <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    res(<span class="string">'success'</span>)</span><br><span class="line">                &#125;, <span class="number">2000</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// console.log('结束执行Promise', res, val)</span></span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'设置新的值'</span>, newVal)</span><br><span class="line">            val = newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为什么get()中使用async不会生效呢</span></span><br><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</span><br><span class="line">def(a, <span class="string">'id'</span>, <span class="number">1</span>);</span><br><span class="line">a.id = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.id---'</span>, a.id) <span class="comment">// 可以看到返回的是 Promise &#123; &lt;pending&gt; &#125;</span></span><br></pre></td></tr></table></figure>
<p>通过上文关于async/await的语法含义，解决这个问题就很简单了<br>目的是获取get中的await返回val而不是promise<br>通过代理包装一层async/await，就能正常获取get()的值  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取指定对象的当前值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myProxy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对指定对象执行加法运算</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myProxyAddition</span>(<span class="params">obj, key, num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> myProxy(obj[key])</span><br><span class="line">    <span class="keyword">let</span> new_result = result + num;</span><br><span class="line">    obj[key] = new_result;</span><br><span class="line">    <span class="keyword">return</span> new_result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对指定对象执行加法运算</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myProxySubtraction</span>(<span class="params">obj, key, num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> myProxy(obj[key])</span><br><span class="line">    <span class="keyword">let</span> new_result = result - num;</span><br><span class="line">    obj[key] = new_result;</span><br><span class="line">    <span class="keyword">return</span> new_result;</span><br><span class="line">&#125;</span><br><span class="line">myProxyAddition(a, <span class="string">'id'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// myProxySubtraction(a, 'id', 3);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计时器的结果,每隔1秒返回</span></span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> myProxy(a.id)</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        clearInterval(timer)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    myProxyAddition(a, <span class="string">'id'</span>, <span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环的结果,2秒后一起返回</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>].map(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    myProxyAddition(a, <span class="string">'id'</span>, <span class="number">1</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>虽然实际开发中不会遇到defineProperty中await get()的情况，但是通过这次的例子可以加深对语法糖的理解~</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>接口返回10万条数据前端如何加载</title>
    <url>/2020/06/11/%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E10%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<blockquote>
<p>震惊！后端大哥偷懒不分页，前端如何在不影响性能时加载大量数据</p>
</blockquote>
<a id="more"></a>

<p>原文:<a href="https://zhuanlan.zhihu.com/p/147178478" target="_blank" rel="noopener">刘小夕</a></p>
<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"appScrollData"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"poll"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="初级方案，直接渲染"><a href="#初级方案，直接渲染" class="headerlink" title="初级方案，直接渲染"></a>初级方案，直接渲染</h2><p>数据量庞大将导致页面性能极具降低, 造成页面卡顿</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处直接使用了原文中的获取数据方式，只做了同步转换</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">way1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'开始创建'</span>)</span><br><span class="line">        <span class="built_in">console</span>.time(<span class="string">'普通创建对象'</span>)</span><br><span class="line">        <span class="keyword">let</span> box = <span class="built_in">document</span>.createElement(<span class="string">"ul"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">            div1.innerHTML = <span class="string">`<span class="subst">$&#123;res.data[i].title&#125;</span> <span class="subst">$&#123;res.data[i].name&#125;</span> <span class="subst">$&#123;res.data[i].text&#125;</span>`</span></span><br><span class="line">            box.appendChild(div1)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(box, res.data)</span><br><span class="line">        app.appendChild(box)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">'普通创建对象'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 文档碎片创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">way2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'开始创建'</span>)</span><br><span class="line">        <span class="built_in">console</span>.time(<span class="string">'文档碎片创建对象'</span>)</span><br><span class="line">        <span class="keyword">var</span> box = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">            div1.innerHTML = <span class="string">`<span class="subst">$&#123;res.data[i].title&#125;</span> <span class="subst">$&#123;res.data[i].name&#125;</span> <span class="subst">$&#123;res.data[i].text&#125;</span>`</span></span><br><span class="line">            box.appendChild(div1)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(box, res.data)</span><br><span class="line">        app.appendChild(box)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">'文档碎片创建对象'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// way1();</span></span><br><span class="line"><span class="comment">// way2();</span></span><br></pre></td></tr></table></figure>

<p>这里用到了 console.time/console.timeEnd 计算函数运行时长<br>注意为什么<code>console.timeEnd</code>放在了<code>setTimeout</code>中？<br>事件循环先宏任务，再微任务，最后更新ui<br>setTimeout属于宏任务<br>这里需要得到能够渲染数据后的运行时长，所以放在了下一轮宏任务中，能够准确获取总</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 10w数据  普通                    文档碎片</span><br><span class="line">&#x2F;&#x2F; chrome   10521.47412109375ms     12217.3671875ms</span><br><span class="line">&#x2F;&#x2F; edge     8409.425048828125ms     8900.69287109375ms</span><br><span class="line">&#x2F;&#x2F; firefox  828ms                   卡崩溃了</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(createDocumentFragment真的更快吗？大家可以测试告诉我)</p>
</blockquote>
<h2 id="中级方案，懒加载-分页"><a href="#中级方案，懒加载-分页" class="headerlink" title="中级方案，懒加载+分页"></a>中级方案，懒加载+分页</h2><p>渲染首屏，后续窗口滚动时防抖优化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getApiData = [];</span><br><span class="line"><span class="keyword">let</span> way3Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分页</span></span><br><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line"><span class="keyword">let</span> curPage = <span class="number">1</span>; <span class="comment">// 当前的页数</span></span><br><span class="line"><span class="keyword">let</span> pageSize = <span class="number">30</span>; <span class="comment">// 每一页展示的数量 * data 传入的数据量</span></span><br><span class="line"><span class="keyword">let</span> prevY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">way3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        getApiData = res.data;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> time = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        clearTimeout(time);</span><br><span class="line">        time = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听scroll事件，使用getBoundingClientRect获取底部空占位元素相对于可视窗口的距离进行懒加载</span></span><br><span class="line"><span class="comment">// 回滚时需要单向锁</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollAndLoading</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.scrollY &gt; prevY) &#123; <span class="comment">// 判断用户是否向下滚动</span></span><br><span class="line">        prevY = <span class="built_in">window</span>.scrollY; <span class="comment">// 在向下滚动并且滚动高度大于上一次时更新</span></span><br><span class="line">        <span class="keyword">if</span> (poll.getBoundingClientRect().top &lt;= <span class="built_in">window</span>.innerHeight) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getApiData.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'getApiData数据还未请求返回'</span>);</span><br><span class="line">            <span class="comment">// 请求下一页数据,每次渲染量为pageSize</span></span><br><span class="line">            curPage++;</span><br><span class="line">            way3Data = getApiData.slice(pageSize * (curPage - <span class="number">1</span>), pageSize * curPage)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'开始创建'</span>, way3Data.length / getApiData.length)</span><br><span class="line">            <span class="built_in">console</span>.time(<span class="string">'文档碎片创建对象'</span>)</span><br><span class="line">            <span class="keyword">var</span> box = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; way3Data.length; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">                div1.innerHTML = <span class="string">`<span class="subst">$&#123;way3Data[i].title&#125;</span> <span class="subst">$&#123;way3Data[i].name&#125;</span> <span class="subst">$&#123;way3Data[i].text&#125;</span>`</span></span><br><span class="line">                box.appendChild(div1)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(box, way3Data)</span><br><span class="line">            app.appendChild(box)</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.timeEnd(<span class="string">'文档碎片创建对象'</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// way3();</span></span><br><span class="line"><span class="comment">// const getWay3Data = debounce(scrollAndLoading, 300)</span></span><br><span class="line"><span class="comment">// window.addEventListener('scroll', getWay3Data, false)</span></span><br></pre></td></tr></table></figure>

<h2 id="高级方案，更优雅的实现方式"><a href="#高级方案，更优雅的实现方式" class="headerlink" title="高级方案，更优雅的实现方式"></a>高级方案，更优雅的实现方式</h2><ul>
<li>js缓冲器来分片处理</li>
<li>虚拟长列表 核心思路就是每次只渲染可视区域的列表数,当滚动后动态的追加元素并通过顶部padding来撑起整个滚动内容</li>
<li>web worker来将需要在前端进行大量计算的逻辑移入进去, 保证js主进程的快速响应, 让web worker线程在后台计算</li>
<li>模糊搜索，二分法优化</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的写法每轮是取数组第一项，并执行添加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multistep</span>(<span class="params">steps, taskHandle, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// var tasks = steps.concat();</span></span><br><span class="line">    <span class="keyword">var</span> tasks = steps;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> task = tasks.shift(); <span class="comment">// 每次执行一步</span></span><br><span class="line">        <span class="comment">// task.apply(null, args || []); //调用Apply参数必须是数组</span></span><br><span class="line">        taskHandle(task);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// arguments.callee代表multistep函数</span></span><br><span class="line">            setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">25</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">25</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">way4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        getApiData = res.data;</span><br><span class="line">        multistep(getApiData, <span class="function"><span class="keyword">function</span>(<span class="params">_arr</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// console.time('文档碎片创建对象')</span></span><br><span class="line">            <span class="keyword">let</span> box = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">            <span class="keyword">let</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">            div1.innerHTML = <span class="string">`<span class="subst">$&#123;_arr.title&#125;</span> <span class="subst">$&#123;_arr.name&#125;</span> <span class="subst">$&#123;_arr.text&#125;</span>`</span>;</span><br><span class="line">            box.appendChild(div1);</span><br><span class="line">            app.appendChild(box);</span><br><span class="line">            <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">            <span class="comment">//     console.timeEnd('文档碎片创建对象')</span></span><br><span class="line">            <span class="comment">// &#125;)</span></span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'way4完成'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// way4()</span></span><br></pre></td></tr></table></figure>
<p>这里用分片处理，每个事件循环周期处理几十条数据,每轮5ms<br>步骤的集合，每次执行的依赖参数，完成结果回调</p>
<hr>
<p>无论采取什么方案，最终目的是释放主线程，让用户可进行交互操作时，无卡顿感知</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>创建新的window隔离沙箱</title>
    <url>/2020/06/11/%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84window%E9%9A%94%E7%A6%BB%E6%B2%99%E7%AE%B1/</url>
    <content><![CDATA[<blockquote>
<p>一起来了解下~<br><code>target=&quot;_blank</code>的安全隐患<br>当window下的全局方法被污染了，如何获取到原本的全局方法getComputedStyle</p>
</blockquote>
<a id="more"></a>

<p>前情提要<br>  1、 <code>target=&quot;_blank&quot;</code>的安全/性能隐患<br>  2、window被污染后当前网页找到一个新的window</p>
<hr>
<p>看到一篇文章，讲的是<code>&lt;a/&gt;</code>标签的<code>target=&quot;_blank&quot;</code>的安全/性能隐患<br>众所周知，这个操作会打开一个新窗口</p>
<ul>
<li>有数据表面国外站点倾向于当前页跳转，有连贯性，减少窗口数量</li>
<li>而国内站点倾向于打开新窗口，优化搜索结果及返回页</li>
</ul>
<h2 id="那会有什么安全-性能隐患呢？"><a href="#那会有什么安全-性能隐患呢？" class="headerlink" title="那会有什么安全/性能隐患呢？"></a>那会有什么安全/性能隐患呢？</h2><p>window.opener获取到来源页面的window对象，即时跨域也不受影响 <code>excuse me?</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父 http://xx.xx.xx.xx:8000/父.html</span></span><br><span class="line">&lt;a href=<span class="string">"http://localhost:8000/子.html"</span> target=<span class="string">"_blank"</span>&gt;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子 http:/</span><span class="regexp">/localhost:8000/</span>子.html</span><br><span class="line"><span class="built_in">window</span>.opener.location = <span class="string">'https://www.baidu.com'</span></span><br></pre></td></tr></table></figure>
<p>在ip跨域时，竟然真的触发了父跳转，这被钓鱼可咋办</p>
<p><code>target=&quot;_blank&quot;</code>的窗口和父窗口公用一个进程，so资源占用你懂的</p>
<blockquote>
<p>如何保障你的网站外链合规</p>
</blockquote>
<ul>
<li>为了防止CSRF攻击<ul>
<li>父页面跳转到钓鱼登录页</li>
<li>发送带参get请求</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父 在a标签上加属性</span></span><br><span class="line">&lt;a rel=<span class="string">"noopener"</span> /&gt;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">&lt;a rel=<span class="string">"noreferrer"</span>/&gt;</span><br><span class="line"><span class="comment">/////////////////////////////</span></span><br><span class="line"><span class="comment">// 或者重写open()</span></span><br><span class="line"><span class="keyword">var</span> window_open = <span class="built_in">window</span>.open();</span><br><span class="line">window_open.opener = <span class="literal">null</span>;</span><br><span class="line">window_open.location = <span class="string">'yourUrl'</span>;</span><br><span class="line">window_open.target = <span class="string">"_blank"</span>;</span><br></pre></td></tr></table></figure>
<p>这样子窗口就是独立的进程了</p>
<p>hexo的主题已经支持这个方案了，不过插件生态好像并没有，（比如文末的本文链接- -,可以提issue了）</p>
<h2 id="如何找到新的window"><a href="#如何找到新的window" class="headerlink" title="如何找到新的window"></a>如何找到新的window</h2><p>回忆起遇到了这么一题，getComputedStyle方法被重写了，要获取css伪元素的content中的文字，当前页面的window被污染了，从哪里得到新的window呢</p>
<blockquote>
<p>iframe和open</p>
</blockquote>
<p>以getComputedStyle举例，这里就放部分代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父</span></span><br><span class="line">#t1::before &#123;content: '我是父t1';&#125;</span><br><span class="line"><span class="built_in">window</span>.getComputedStyle = <span class="string">""</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'通过子获取父style'</span>, <span class="built_in">window</span>.frames[<span class="string">'iframe1'</span>].contentWindow.getComputedStyle(<span class="built_in">document</span>.getElementById(<span class="string">'t1'</span>), <span class="string">':before'</span>).content)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'调用子方法'</span>,<span class="built_in">window</span>.frames[<span class="string">'iframe1'</span>].contentWindow.funcLeo_c())</span><br><span class="line"><span class="comment">// 子</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'从子获取父style'</span>, <span class="built_in">window</span>.getComputedStyle(<span class="built_in">window</span>.parent.document.getElementById(<span class="string">'t1'</span>), <span class="string">':before'</span>).content)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'调用父方法'</span>,<span class="built_in">window</span>.parent.funcLeo_p())</span><br></pre></td></tr></table></figure>

<p>当然还有上文提到的open()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="built_in">window</span>.open(<span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.log(win.getComputedStyle(<span class="built_in">document</span>.getElementById(<span class="string">'t1'</span>), <span class="string">':before'</span>).content)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>不一样的console-log</title>
    <url>/2020/06/10/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84console-log/</url>
    <content><![CDATA[<blockquote>
<p>来看看 控制台中console的各种实现~</p>
</blockquote>
<a id="more"></a>

<ul>
<li>console.log 用于输出普通信息</li>
<li>console.info 用于输出提示性信息</li>
<li>console.error 用于输出错误信息</li>
<li>console.warn 用于输出警示信息</li>
<li>console.group&amp;console.groupEnd 输出一组信息</li>
<li>console.table 信息通过表格展示</li>
<li>console.count 函数执行次数</li>
<li>console.dir将Dom 树结构输出</li>
<li>console.time 计时开始</li>
<li>console.timeEnd 计时结束</li>
<li>console.profile&amp;console.profileEnd 查看CPU使用相关信息、</li>
<li>console.timeLine&amp;console.timeLineEnd 记录一段时间轴</li>
<li>console.trace 堆栈跟踪相关的调试</li>
</ul>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>复制代码贴入console中试试看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 换行</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第一行\n第二行'</span>);</span><br><span class="line"><span class="comment">// 样式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'%c换个颜色'</span>,<span class="string">'color:blue;'</span>);</span><br><span class="line"><span class="comment">// 图片</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"%c "</span>,<span class="string">"background: url(https://gitby-leo.github.io/images/avatar.jpg) no-repeat center;padding-left:80px;padding-bottom: 80px;"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="字符画"><a href="#字符画" class="headerlink" title="字符画"></a>字符画</h2><p>打开<a href="http://patorjk.com/" target="_blank" rel="noopener">http://patorjk.com/</a>找到<a href="http://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type%20Something%20" target="_blank" rel="noopener">Text to ASCII Art Generator</a></p>
<p>目前支持315种英文字符样式</p>
<p>字符生成复制后直接放console</p>
<p>npm包，如<a href="https://www.npmjs.com/package/figlet" target="_blank" rel="noopener">figlet</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开控制台可见</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`</span></span><br><span class="line"><span class="string"> __    ____  _____ </span></span><br><span class="line"><span class="string">(  )  ( ___)(  _  )</span></span><br><span class="line"><span class="string"> )(__  )__)  )(_)( </span></span><br><span class="line"><span class="string">(____)(____)(_____)</span></span><br><span class="line"><span class="string">`</span>)</span><br></pre></td></tr></table></figure>
<script>
console.log(`
 __    ____  _____ 
(  )  ( ___)(  _  )
 )(__  )__)  )(_)( 
(____)(____)(_____)
`) 
</script>

<pre><code class="js">&lt;script&gt;
<span class="built_in">console</span>.log(<span class="string">`</span>
<span class="string">          _____            _____                   _______         </span>
<span class="string">         /\    \          /\    \                 /::\    \        </span>
<span class="string">        /::\____\        /::\    \               /::::\    \       </span>
<span class="string">       /:::/    /       /::::\    \             /::::::\    \      </span>
<span class="string">      /:::/    /       /::::::\    \           /::::::::\    \     </span>
<span class="string">     /:::/    /       /:::/\:::\    \         /:::/~~\:::\    \    </span>
<span class="string">    /:::/    /       /:::/__\:::\    \       /:::/    \:::\    \   </span>
<span class="string">   /:::/    /       /::::\   \:::\    \     /:::/    / \:::\    \  </span>
<span class="string">  /:::/    /       /::::::\   \:::\    \   /:::/____/   \:::\____\ </span>
<span class="string"> /:::/    /       /:::/\:::\   \:::\    \ |:::|    |     |:::|    |</span>
<span class="string">/:::/____/       /:::/__\:::\   \:::\____\|:::|____|     |:::|    |</span>
<span class="string">\:::\    \       \:::\   \:::\   \::/    / \:::\    \   /:::/    / </span>
<span class="string"> \:::\    \       \:::\   \:::\   \/____/   \:::\    \ /:::/    /  </span>
<span class="string">  \:::\    \       \:::\   \:::\    \        \:::\    /:::/    /   </span>
<span class="string">   \:::\    \       \:::\   \:::\____\        \:::\__/:::/    /    </span>
<span class="string">    \:::\    \       \:::\   \::/    /         \::::::::/    /     </span>
<span class="string">     \:::\    \       \:::\   \/____/           \::::::/    /      </span>
<span class="string">      \:::\    \       \:::\    \                \::::/    /       </span>
<span class="string">       \:::\____\       \:::\____\                \::/____/        </span>
<span class="string">        \::/    /        \::/    /                 ~~              </span>
<span class="string">         \/____/          \/____/                                  </span>
<span class="string"></span>
<span class="string">`</span>) </code></pre>
<p></script></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>用Web Components写摄像头组件</title>
    <url>/2020/06/08/%E7%94%A8Web%20Components%E5%86%99%E6%91%84%E5%83%8F%E5%A4%B4%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>Web Components中最佳特性就是shadow DOM的防污染封装<br>来看看怎么实现一个摄像头组件吧~</p>
</blockquote>
<a id="more"></a>

<p>原文:<a href="https://www.w3cplus.com/javascript/how-to-build-the-simple-camera-component.html" target="_blank" rel="noopener">大漠w3c</a></p>
<hr>
<ul>
<li>使用MediaDevices API获取相机访问权限</li>
<li>使用video元素播放MediaStream</li>
<li>使用canvas元素以blob或base64形式拍照</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;simple-camera&gt;&lt;/simple-camera&gt;</span></span><br><span class="line"><span class="comment">// &lt;button id="btnPhoto"&gt;拍一张&lt;/button&gt;</span></span><br><span class="line"><span class="comment">// &lt;button id="btnBase64Photo"&gt;转为base64&lt;/button&gt;</span></span><br><span class="line"><span class="comment">// &lt;img id="base64Img" src="#" alt=""&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCamera</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125; <span class="comment">// 当元素连接到DOM时调用这个函数</span></span><br><span class="line">    connectedCallback() &#123; </span><br><span class="line">        <span class="comment">// shadow样式保持 </span></span><br><span class="line">        <span class="keyword">const</span> shadow = <span class="keyword">this</span>.attachShadow(&#123;</span><br><span class="line">            mode: <span class="string">'open'</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.videoElement = <span class="built_in">document</span>.createElement(<span class="string">'video'</span>);</span><br><span class="line">        <span class="keyword">this</span>.canvasElement = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">        <span class="keyword">this</span>.videoElement.setAttribute(<span class="string">'playsinline'</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.canvasElement.style.display = <span class="string">'none'</span>;</span><br><span class="line"></span><br><span class="line">        shadow.appendChild(<span class="keyword">this</span>.videoElement);</span><br><span class="line">        shadow.appendChild(<span class="keyword">this</span>.canvasElement)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配给目标元素执行</span></span><br><span class="line">    open(constraints) &#123;</span><br><span class="line">        <span class="comment">// 本地测试不要使用ip，要用localhost，否则没有navigator.mediaDevices</span></span><br><span class="line">        <span class="keyword">return</span> navigator.mediaDevices.getUserMedia(constraints)</span><br><span class="line">            .then(<span class="function">(<span class="params">mediaStream</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 分配MediaStream </span></span><br><span class="line">                <span class="keyword">this</span>.videoElement.srcObject = mediaStream;</span><br><span class="line">                <span class="comment">// 加载时播放流 </span></span><br><span class="line">                <span class="keyword">this</span>.videoElement.onloadedmetadata = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.videoElement.play()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从video元素中绘制帧</span></span><br><span class="line">    _drawImage() &#123;</span><br><span class="line">        <span class="keyword">const</span> imageWidth = <span class="keyword">this</span>.videoElement.videoWidth;</span><br><span class="line">        <span class="keyword">const</span> imageHeight = <span class="keyword">this</span>.videoElement.videoHeight;</span><br><span class="line">        <span class="keyword">this</span>.canvasElement.width = imageWidth;</span><br><span class="line">        <span class="keyword">this</span>.canvasElement.height = imageHeight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> context = <span class="keyword">this</span>.canvasElement.getContext(<span class="string">'2d'</span>);</span><br><span class="line">        context.drawImage(<span class="keyword">this</span>.videoElement, <span class="number">0</span>, <span class="number">0</span>, imageWidth, imageHeight);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            imageHeight,</span><br><span class="line">            imageWidth</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// canvas的toBlob()转为同步</span></span><br><span class="line">    takeBlobPhoto() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">            imageHeight,</span><br><span class="line">            imageWidth</span><br><span class="line">        &#125; = <span class="keyword">this</span>._drawImage();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.canvasElement.toBlob(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">                resolve(&#123;</span><br><span class="line">                    blob,</span><br><span class="line">                    imageHeight,</span><br><span class="line">                    imageWidth</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// canvase转base64</span></span><br><span class="line">    takeBase64Photo(&#123;</span><br><span class="line">        type,</span><br><span class="line">        quality</span><br><span class="line">    &#125; = &#123;</span><br><span class="line">        type: <span class="string">'png'</span>,</span><br><span class="line">        quality: <span class="number">1</span></span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">            imageHeight,</span><br><span class="line">            imageWidth</span><br><span class="line">        &#125; = <span class="keyword">this</span>._drawImage();</span><br><span class="line">        <span class="keyword">const</span> base64 = <span class="keyword">this</span>.canvasElement.toDataURL(<span class="string">'image/'</span> + type, quality);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            base64,</span><br><span class="line">            imageHeight,</span><br><span class="line">            imageWidth</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用自定义元素了</span></span><br><span class="line">customElements.define(<span class="string">'simple-camera'</span>, SimpleCamera)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> camera = <span class="built_in">document</span>.querySelector(<span class="string">'simple-camera'</span>)</span><br><span class="line">    <span class="keyword">const</span> btnBlobPhoto = <span class="built_in">document</span>.querySelector(<span class="string">'#btnBlobPhoto'</span>)</span><br><span class="line">    <span class="keyword">const</span> btnBase64Photo = <span class="built_in">document</span>.querySelector(<span class="string">'#btnBase64Photo'</span>)</span><br><span class="line">    <span class="keyword">const</span> base64Img = <span class="built_in">document</span>.getElementById(<span class="string">'base64Img'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> camera.open(&#123;</span><br><span class="line">        video: &#123;</span><br><span class="line">            facingMode: <span class="string">'user'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'摄像头开启失败'</span>, err)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    btnPhoto.addEventListener(<span class="string">'click'</span>, <span class="keyword">async</span> event =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> photo = <span class="keyword">await</span> camera.takeBlobPhoto()</span><br><span class="line">        <span class="built_in">console</span>.log(photo)</span><br><span class="line">        base64Img.src = URL.createObjectURL(photo.blob);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    btnBase64Photo.addEventListener(<span class="string">'click'</span>, <span class="keyword">async</span> event =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> photo = camera.takeBase64Photo(&#123;</span><br><span class="line">            type: <span class="string">'jpeg'</span>,</span><br><span class="line">            quality: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(photo)</span><br><span class="line">        base64Img.src = photo.base64;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>javascript</category>
        <category>Web Component</category>
      </categories>
      <tags>
        <tag>Web Component</tag>
      </tags>
  </entry>
  <entry>
    <title>js中var/let/const的区别</title>
    <url>/2020/05/31/js%E4%B8%ADvar/let/const%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>三种变量声明很常见，就来说点不一样的  </p>
<ul>
<li>原来还有全局对象和顶层对象  </li>
<li>为什么我定义的变量和函数无法delete</li>
</ul>
</blockquote>
<a id="more"></a>

<p>刚接触js时，声明一个变量会用var或者function，共2种</p>
<ul>
<li>var声明的全局变量</li>
<li>var在函数范围内声明的局部变量</li>
<li>eval中声明的全局变量。</li>
</ul>
<p>在es6中，新增了let/const/import/class，共6种</p>
<hr>
<h2 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h2><p>浏览器环境中顶层对象是window，Node中是global对象</p>
<ul>
<li>ES5中，顶层对象的属性等价于全局变量</li>
<li>ES6中，var、function声明的全局变量<strong>属于</strong>顶层对象，其他4个则<strong>不属于</strong>顶层对象<br>,所以es6中的全局变量和顶层对象的属性分离。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.info(<span class="built_in">window</span>.b);  <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.info(<span class="built_in">window</span>.c);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.info(<span class="keyword">this</span>.len)</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// undefined,此时this为window</span></span><br><span class="line"><span class="keyword">let</span> Person = &#123;</span><br><span class="line">	len: <span class="number">5</span>,</span><br><span class="line">	say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		fn(); <span class="comment">// undefined 此时this为window</span></span><br><span class="line">		<span class="built_in">arguments</span>[<span class="number">0</span>](); <span class="comment">// undefined 此时调用fn方法，arguments对象里没有len属性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.say(fn);<span class="comment">// this为Person</span></span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>arguments.length表示传入函数的实参数量</li>
<li>函数本身的length属性代表的是函数定义时给出的参数个数</li>
</ul>
<hr>
<h2 id="变量删除"><a href="#变量删除" class="headerlink" title="变量删除"></a>变量删除</h2><ul>
<li>var全局声明的变量是<strong>无法删除</strong>的，configurable=false</li>
<li>var函数作用域内声明的变量是<strong>无法删除</strong>的，没有依赖的父对象</li>
<li>eval()会创建属性，configurable=true,所以可以删除</li>
</ul>
<p>同理，函数也是对象，声明的函数也会遵循var的方式，判断是否可以删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">window</span>, <span class="string">'a'</span>));      <span class="comment">// delete b =&gt; false</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">2</span>; <span class="comment">// delete b =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// delete aa =&gt; false</span></span><br><span class="line">(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bb</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">delete</span> bb; <span class="comment">// false</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>所以如果要删除已定义的变量，可以赋值覆盖掉它，或者是在局部作用域中创建，等待内存回收</p>
<p>垃圾回收有2大条件</p>
<ul>
<li>未被引用的对象会被自动回收</li>
<li>不可访问的对象会被自动回收，比如虽然2对象互相引用，但是外部不可访问也会被回收</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>33行实现react</title>
    <url>/2020/05/30/33%E8%A1%8C%E5%AE%9E%E7%8E%B0react/</url>
    <content><![CDATA[<blockquote>
<p>一种简易的类react架构的实现，了解react，<br>全文添加中文注释，方便理解</p>
</blockquote>
<a id="more"></a>

<ul>
<li>取得状态并返回虚拟dom</li>
<li>状态改变，返回新的虚拟dom</li>
<li>将虚拟dom渲染为真实dom</li>
<li>更新真实dom</li>
</ul>
<p>前置知识点</p>
<ul>
<li><a href="http://www.mithriljs.net/" target="_blank" rel="noopener">Mithril</a> 现代化的 JS 轻量框架,内置了路由和 XHR 工具<ul>
<li>m() 函数可以描述任何 HTML 结构</li>
<li>m.render(root, ‘’) 挂载</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 结构args =&gt; tag, attrs, classes</span></span><br><span class="line">    <span class="keyword">let</span> [attrs, [head, ...tail]] = [&#123;&#125;, args]</span><br><span class="line">    <span class="keyword">let</span> [tag, ...classes] = head.split(<span class="string">'.'</span>)</span><br><span class="line">    <span class="keyword">if</span> (tail.length &amp;&amp; !m.isRenderable(tail[<span class="number">0</span>])) [attrs, ...tail] = tail</span><br><span class="line">    <span class="comment">// 合并class</span></span><br><span class="line">    <span class="keyword">if</span> (attrs.class) classes = [...classes, ...attrs.class]</span><br><span class="line">    <span class="comment">// 把已经使用的attrs做浅拷贝，删除class的值</span></span><br><span class="line">    attrs = &#123;...attrs&#125;; <span class="keyword">delete</span> attrs.class</span><br><span class="line">    <span class="comment">// 创建子数组，递归地将嵌套项拍平到该数组中，并忽略空值</span></span><br><span class="line">    <span class="keyword">const</span> children = []</span><br><span class="line">    <span class="keyword">const</span> addChildren = <span class="function"><span class="params">v</span>=&gt;</span>v === <span class="literal">null</span>? <span class="literal">null</span> : <span class="built_in">Array</span>.isArray(v)? v.map(addChildren) : children.push(v)</span><br><span class="line">    addChildren(tail)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">__m</span>: <span class="literal">true</span>, <span class="attr">tag</span>: tag || <span class="string">'div'</span>, attrs, classes, children&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否可以渲染null,字符串，数字，虚拟节点，数组</span></span><br><span class="line">m.isRenderable = <span class="function"><span class="params">v</span> =&gt;</span>v === <span class="literal">null</span> || [<span class="string">'string'</span>, <span class="string">'number'</span>].includes(<span class="keyword">typeof</span> v) || v.__m || <span class="built_in">Array</span>.isArray(v)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收真实dom和虚拟dom</span></span><br><span class="line"><span class="comment">// 把所需的虚拟dom的属性和类更新到真实dom</span></span><br><span class="line">m.update = <span class="function">(<span class="params">el, v</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 如果是文本元素，需要设置数据</span></span><br><span class="line">    <span class="keyword">if</span> (!v.__m) <span class="keyword">return</span> el.data === <span class="string">`<span class="subst">$&#123;v&#125;</span>`</span> || (el.data = v)</span><br><span class="line">    <span class="comment">// 设置添加class</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> v.classes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!el.classList.contains(name)) el.classList.add(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> el.classList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!v.classes.includes(name)) el.classList.remove(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置添加attributes</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> <span class="built_in">Object</span>.keys(v.attrs))&#123;</span><br><span class="line">        <span class="keyword">if</span> (el[name] !== v.attrs[name]) el[name] = v.attrs[name]</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> &#123;name&#125; <span class="keyword">of</span> el.attributes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(v.attrs).includes(name) &amp;&amp; name !== <span class="string">'class'</span>) el.removeAttribute(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定一个虚拟DOM节点，生成一个真实dom节点，否则生成一个真实textNode值。</span></span><br><span class="line">m.makeEl = <span class="function"><span class="params">v</span>=&gt;</span>v.__m? <span class="built_in">document</span>.createElement(v.tag) : <span class="built_in">document</span>.createTextNode(v)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染，真实Dom和虚拟Dom</span></span><br><span class="line"><span class="comment">// a) 获取新老节点的子项</span></span><br><span class="line"><span class="comment">// b) 清除多余的旧节点</span></span><br><span class="line"><span class="comment">// c) 遍历每个新虚拟节点</span></span><br><span class="line"><span class="comment">//  1、通过index获取匹配的旧节点，如果没有则新增节点</span></span><br><span class="line"><span class="comment">//  2、如果没有匹配的旧元素，创建一个新元素加入父级</span></span><br><span class="line"><span class="comment">//  3、如果不匹配(标签名/节点)，就替换父级上的匹配项为新元素</span></span><br><span class="line"><span class="comment">//  4、更新节点的属性/类</span></span><br><span class="line"><span class="comment">//  5、递归子节点</span></span><br><span class="line"><span class="comment">// 高效追加到元素列表,耗时O(n)</span></span><br><span class="line">m.render = <span class="function">(<span class="params">parent, v</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> olds = parent.childNodes || []</span><br><span class="line">    <span class="keyword">const</span> news = v.children || [] </span><br><span class="line">    <span class="comment">// 遍历次数是新旧节点的属性长度之差</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> _ <span class="keyword">of</span> <span class="built_in">Array</span>(<span class="built_in">Math</span>.max(<span class="number">0</span>, olds.length - news.length))) &#123;</span><br><span class="line">        parent.removeChild(parent.lastChild)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// entries返回可枚举属性的键值对数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [i, child] <span class="keyword">of</span> news.entries())&#123; </span><br><span class="line">        <span class="keyword">let</span> el = olds[i] || m.makeEl(child) </span><br><span class="line">        <span class="comment">// 旧的属性的值存在</span></span><br><span class="line">        <span class="keyword">if</span> (!olds[i])&#123;</span><br><span class="line">            parent.appendChild(el)  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">const</span> mismatch = (el.tagName || <span class="string">''</span>) !== (child.tag || <span class="string">''</span>).toUpperCase()</span><br><span class="line">        <span class="keyword">if</span> (mismatch) &#123;</span><br><span class="line">            (el = m.makeEl(child)) &amp;&amp; parent.replaceChild(el, olds[i])</span><br><span class="line">        &#125;</span><br><span class="line">        m.update(el, child) </span><br><span class="line">        m.render(el, child) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原文：<a href="https://leontrolski.github.io/33-line-react.html" target="_blank" rel="noopener">https://leontrolski.github.io/33-line-react.html</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex getter</title>
    <url>/2020/05/24/vuex%20getter/</url>
    <content><![CDATA[<blockquote>
<p>Vuex的5大属性，state，getters，mutations，actions和modules<br>getters到底能做什么</p>
</blockquote>
<a id="more"></a>

<hr>
<p>写业务时没有太在意state/getter读值的区别，直到面试时遇到了这样一个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue中computed和vuex中getters有什么相同点</span><br></pre></td></tr></table></figure>
<p>leo：纳尼，这两者还有关联？<br>面试官：你真的用过vuex?<br>leo：emmm</p>
<hr>
<p>vuex嘛，大家都知道是中心化的状态管理模式，单向数据流，如图  </p>
<div style="width: 50%; margin: auto">

<p><img src="state-view-actions.png" alt="单向数据流"></div></p>
<p>state保存状态，getters获取state，mutations同步执行改变state，actions异步执行</p>
<h2 id="如何获取state状态"><a href="#如何获取state状态" class="headerlink" title="如何获取state状态"></a>如何获取state状态</h2><p>方案一</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.state.aaa</span><br><span class="line"><span class="keyword">this</span>.$store.getter.bbb</span><br></pre></td></tr></table></figure>
<p>方案二</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">'aaa'</span>]),</span><br><span class="line">    ...mapGetters([<span class="string">'bbb'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么提供了2种方法获取state，他们有什么区别呢"><a href="#为什么提供了2种方法获取state，他们有什么区别呢" class="headerlink" title="为什么提供了2种方法获取state，他们有什么区别呢"></a>为什么提供了2种方法获取state，他们有什么区别呢</h2><ul>
<li>state获取时直接返回</li>
<li>getter可以在获取state时，对state进行操作后返回</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">    getMyListGreaterThanNum(state, getters) &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123; <span class="comment">// 把属性变成函数属性</span></span><br><span class="line">        <span class="keyword">return</span> state.myList.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; num) </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$store.getters[<span class="string">"getMyListGreaterThanNum"</span>](<span class="number">1</span>)</span><br><span class="line"><span class="keyword">this</span>.$store.getters.getMyListGreaterThanNum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="computed和getters相同点"><a href="#computed和getters相同点" class="headerlink" title="computed和getters相同点"></a>computed和getters相同点</h2><ul>
<li>缓存，和computed一样，当依赖的state改变才会重新计算</li>
</ul>
<p>在getters中是属性不是函数,不能直接传参</p>
<h2 id="mapGetters-是什么"><a href="#mapGetters-是什么" class="headerlink" title="mapGetters 是什么"></a>mapGetters 是什么</h2><ul>
<li>mapGetters辅助函数，直接返回一个对象，仅仅是将 store 中的 getter 映射到局部计算属性</li>
</ul>
<p>每次调用都需要this.$store.getters.xxx，非常麻烦，可以用mapGetters语法糖直接合并入computed</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">'getMyListGreaterThanNum'</span>]),</span><br><span class="line">    ...mapGetters(<span class="string">"myStore2"</span>, [<span class="string">"getMyListGreaterThanNum"</span>]);<span class="comment">// 分模块</span></span><br><span class="line">    ...mapGetters(<span class="string">"myStore2"</span>, &#123;<span class="attr">getMyList</span>: <span class="string">"getMyListGreaterThanNum"</span>&#125;);<span class="comment">// 重命名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$storestore.getters[<span class="string">"myStore2/getMyListGreaterThanNum"</span>]</span><br></pre></td></tr></table></figure>

<h2 id="mapGetters源码实现"><a href="#mapGetters源码实现" class="headerlink" title="mapGetters源码实现"></a>mapGetters源码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reduce the code which written in Vue.js for getting the getters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>[namespace] - Module's namespace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object|Array&#125;</span> <span class="variable">getters</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mapGetters = normalizeNamespace(<span class="function"><span class="keyword">function</span> (<span class="params">namespace, getters</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!isValidMap(getters)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'[vuex] mapGetters: mapper parameter must be either an Array or an Object'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    normalizeMap(getters).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ref</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> key = ref.key;</span><br><span class="line">      <span class="keyword">var</span> val = ref.val;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The namespace has been mutated by normalizeNamespace</span></span><br><span class="line">      val = namespace + val;</span><br><span class="line">      res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (namespace &amp;&amp; !getModuleByNamespace(<span class="keyword">this</span>.$store, <span class="string">'mapGetters'</span>, namespace)) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(val <span class="keyword">in</span> <span class="keyword">this</span>.$store.getters)) &#123;</span><br><span class="line">          <span class="built_in">console</span>.error((<span class="string">"[vuex] unknown getter: "</span> + val));</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters[val]</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// mark vuex getter for devtools</span></span><br><span class="line">      res[key].vuex = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeNamespace</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">namespace, map</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> namespace !== <span class="string">'string'</span>) &#123;</span><br><span class="line">        map = namespace;</span><br><span class="line">        namespace = <span class="string">''</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namespace.charAt(namespace.length - <span class="number">1</span>) !== <span class="string">'/'</span>) &#123;</span><br><span class="line">        namespace += <span class="string">'/'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fn(namespace, map)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeMap</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidMap(map)) &#123;</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(map)</span><br><span class="line">      ? map.map(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123; <span class="keyword">return</span> (&#123; <span class="attr">key</span>: key, <span class="attr">val</span>: key &#125;); &#125;)</span><br><span class="line">      : <span class="built_in">Object</span>.keys(map).map(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123; <span class="keyword">return</span> (&#123; <span class="attr">key</span>: key, <span class="attr">val</span>: map[key] &#125;); &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>normalizeNamespace函数将传入的改成namespace/getters的分割样式，如果没有namespace，那么直接返回getters</li>
<li>normalizeMap函数将输入的getters对应成store的内部属性，可以使用对象来更改函数的名称</li>
<li>查找属性，找到返回this.$store.getters[val]</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vuex</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3预览</title>
    <url>/2020/05/17/vue3%E9%A2%84%E8%A7%88/</url>
    <content><![CDATA[<p>vue3 的api及语法有哪些改变</p>
<a id="more"></a>

<img src="/images/vue3预览/1.jpg" />
<img src="/images/vue3预览/2.jpg" />
<img src="/images/vue3预览/3.jpg" />
<img src="/images/vue3预览/4.jpg" />
<img src="/images/vue3预览/all.png" />





]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>reduce用法详解</title>
    <url>/2020/04/14/reduce%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<p>reduce()累加器，数组中的每个元素依次执行回调函数callback（初始值(或者上次回调函数的返回值)，当前元素值，当前索引，调用reduce的数组）<br>arr.reduce(callback, [initialValue])</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pre, cur, index);</span><br><span class="line">    <span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, sum); <span class="comment">// [1, 2, 3, 4] 10   初始值为1,循环3次</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pre, cur, index);</span><br><span class="line">    <span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr, sum); <span class="comment">// [1, 2, 3, 4] 10   初始值为0,循环4次</span></span><br></pre></td></tr></table></figure>

<p>求和或求积</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;<span class="comment">// 10</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> mul = arr.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x * y;<span class="comment">// 24</span></span><br><span class="line">&#125;, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>计算数组中每个元素出现的次数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Tiff'</span>, <span class="string">'Alice'</span>];</span><br><span class="line"><span class="keyword">var</span> nameNum = names.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (cur <span class="keyword">in</span> pre) &#123;</span><br><span class="line">		pre[cur]++</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pre[cur] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre  </span><br><span class="line">&#125;, &#123;&#125;) <span class="comment">// &#123; Alice: 2, Bob: 1, Tiff: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>对象属性求和</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">	&#123;<span class="attr">subject</span>: <span class="string">'math'</span>, <span class="attr">score</span>: <span class="number">10</span>&#125;,</span><br><span class="line">	&#123;<span class="attr">subject</span>: <span class="string">'chinese'</span>, <span class="attr">score</span>: <span class="number">10</span>&#125;,</span><br><span class="line">	&#123;<span class="attr">subject</span>: <span class="string">'english'</span>, <span class="attr">score</span>: <span class="number">10</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cur.score + pre</span><br><span class="line">&#125;, <span class="number">0</span>) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>数组去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!pre.includes(cur)) &#123;</span><br><span class="line">		<span class="keyword">return</span> pre.concat(cur)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> pre</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, [])  <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>数组对象去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">	&#123;<span class="attr">id</span>: <span class="number">0</span>, <span class="attr">name</span>: <span class="string">"小明"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">"小张"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">"小李"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">"小孙"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">"小周"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">"小陈"</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	obj[cur.id] ? <span class="string">''</span> : obj[cur.id] = <span class="literal">true</span> &amp;&amp; pre.push(cur);</span><br><span class="line">	<span class="keyword">return</span> pre</span><br><span class="line">&#125;, []) <span class="comment">// [ &#123;id: 0, name: “小明”&#125;, &#123;id: 1, name: “小张”&#125;,&#123;id: 2, name: “小李”&#125;,&#123;id: 3, name: “小孙”&#125;]</span></span><br></pre></td></tr></table></figure>

<p>数组拍平</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pre.concat(cur)  <span class="comment">// [0,1,2,3,4,5]</span></span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<p>数组多维拍平</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]]]</span><br><span class="line"><span class="keyword">var</span> newArr = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">		pre.concat(<span class="built_in">Array</span>.isArray(cur) ? newArr(cur) : cur)</span><br><span class="line">	&#125;, [])</span><br><span class="line">&#125; <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>React</category>
        <category>Reduce</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react useMemo&amp;useCallback</title>
    <url>/2020/04/01/react%20useMemo&amp;useCallback/</url>
    <content><![CDATA[<blockquote>
<p>useMemo和useCallback都会在组件第一次渲染的时候执行</p>
</blockquote>
<blockquote>
<p>之后会在其依赖的变量发生改变时再次执行</p>
</blockquote>
<blockquote>
<p>useMemo返回缓存的变量，useCallback返回缓存的函数</p>
</blockquote>
<p>多个state改变会重渲染多此，借助useMemo可以在指定state改变时才执行对应的方法</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expensive</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">改为</span><br><span class="line"><span class="keyword">const</span> expensive = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,[count])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>useCallback返回的是缓存的函数</p>
</blockquote>
<ul>
<li>将我们传递给它的函数fnB返回，并且将这个结果缓存；当依赖a变更时，会返回新的函数。</li>
<li>既然返回的是函数，我们无法很好的判断返回的函数是否变更，</li>
<li>所以我们可以借助ES6新增的数据类型Set来判断<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fnA = useCallback(fnB, [a])</span><br></pre></td></tr></table></figure>
如果存在父子组件，如果父更新，子也会更新，可以把useCallback返回的函数传给子props,这样就缓存不更新<br>等返回的函数更新后字才会更新</li>
</ul>
<p>所有依赖本地状态或props来创建函数，需要使用到缓存函数的地方，都是useCallback的应用场景</p>
<p>useEffect、useMemo、useCallback都是自带闭包的。也就是说，每一次组件的渲染，其都会捕获当前组件函数上下文中的状态(state, props)，所以每一次这三种hooks的执行，反映的也都是当前的状态，你无法使用它们来捕获上一次的状态。对于这种情况，我们应该使用ref来访问</p>
<p>类组件的shouldComponentUpdate和 PureComponent,为了减少重新 render 的次数，主要是减少父组件更新而子组件也更新的情况</p>
<p>React.memo是对标类组件PureComponent<br>子组件如果在 props 没有变化的情况下，就算父组件重新渲染了，子组件也不应该渲染<br>React.memo其实是一个高阶函数，传递一个组件进去，返回一个可以记忆的组件</p>
<p>如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myComponent(props) &#123;</span><br><span class="line">   &#x2F;* 使用 props 渲染 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--  prevProps !&#x3D; nextProps时返回false会重渲 --&gt;</span><br><span class="line">funtion areEqual(prevProps,nextProps)&#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">const MyComponent &#x3D; React.memo(myComponent,areEqual);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个组件重新重新渲染，一般三种情况：</p>
</blockquote>
<ul>
<li>要么是组件自己的状态改变</li>
<li>要么是父组件重新渲染，导致子组件重新渲染，但是父组件的 props 没有改版</li>
<li>要么是父组件重新渲染，导致子组件重新渲染，但是父组件传递的 props 改变</li>
</ul>
<blockquote>
<p>React 的性能优化方向主要是两个：</p>
</blockquote>
<ul>
<li>一个是减少重新 render 的次数(或者说减少不必要的渲染)，</li>
<li>另一个是减少计算的量</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
        <category>Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react-useEffect&amp;useReducer</title>
    <url>/2020/03/30/react-useEffect&amp;useReducer/</url>
    <content><![CDATA[<blockquote>
<p>use*** 格式定义的函数是react hooks的规范</p>
</blockquote>
<p>useEffect用于处理组件中的effect，通常用于请求数据，事件处理，订阅等相关操作</p>
<blockquote>
<p>最后return的【返回函数】可以作为状态切换的默认执行函数，执行下一个effect之前执行上一个effect【返回的函数】</p>
</blockquote>
<a id="more"></a>
<hr>
<ul>
<li><p>状态和状态更新函数来自与useState这个hooks，通过调用useState，来创建App组件的内部状态。初始状态是一个object，其中的hits为一个空数组</p>
</li>
<li><p>axios发起请求,使用useEffect来隔离副作用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> fetchData = <span class="keyword">async</span>()&#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> axios(<span class="string">'xxx'</span>);</span><br><span class="line">            setData(result.data);</span><br><span class="line">        &#125;</span><br><span class="line">        fetchData()</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">        &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">                &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">         &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>useEffect在组件mount时执行，但也会在组件更新时执行</p>
</blockquote>
</li>
<li><p>如果在useEffect中请求数据并setData会触发渲染,导致死循环<br>所以需要传递一个空数组作为参数，避免在更新时触发useEffect,只会在mount挂载时执行一次</p>
</li>
<li><p>第二参数用于监听指定变量的更新<br>如果参数中定义的变量更新了，则useEffect会再次执行</p>
</li>
<li><p>async函数会隐式返回promise，但是useEffect不返回内容，所以需要用方法包装async</p>
</li>
</ul>
<hr>
<blockquote>
<p>响应更新的例子，用户输入</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">    <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'redux'</span>);</span><br><span class="line">    <span class="keyword">const</span> [search, setSearch] = useState(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">const</span> [url, setUrl] = useState(<span class="string">'http://localhost/api/v1/search?query=redux'</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> fetchData = <span class="keyword">async</span>()=&gt;&#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> axios(<span class="string">'xxx?query='</span> + query);</span><br><span class="line">            setData(result.data);</span><br><span class="line">        &#125;</span><br><span class="line">        fetchData()</span><br><span class="line">    &#125;,[search])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> value=&#123;query&#125;</span><br><span class="line">                onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">            &lt;button type=<span class="string">"button"</span> onClick=&#123;() =&gt; setSearch(query)&#125;&gt;</span><br><span class="line">                Search</span><br><span class="line">            &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">                &lt;li key=&#123;item.objectID&#125;&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/</span>a&gt;</span><br><span class="line">                &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            ))&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/u</span>l&gt;</span><br><span class="line">        &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>query的任何一次变动都会请求后端，这样会带来比较大的访问压力。这个时候我们需要引入一个按钮，点击这个按钮再发起请求(query改为search)</p>
</li>
<li><p>每次点击按钮时，会把search的值设置为query，这个时候我们需要修改useEffect中的依赖项为search，这样每次点击按钮，search值变更，useEffect就会重新执行，避免不必要的变更</p>
</li>
<li><p>因为组件首先会在mount时获取数据。所以简单点，直接将的要请求的后端URL设置为search state的初始值</p>
</li>
<li><p>如果useEffect中出现其他外部变量也需要放入依赖数组中，所以btn依赖的query也提取到btn中，不转入useEffect</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'redux'</span>);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(</span><br><span class="line">    <span class="string">'http://localhost/api/v1/search?query=redux'</span>,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        value=&#123;query&#125;</span><br><span class="line">        onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"button"</span> onClick=&#123;() =&gt; setUrl(<span class="string">`http://localhost/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>)&#125;&gt;</span><br><span class="line">            Search</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li key=&#123;item.objectID&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/</span>a&gt;</span><br><span class="line">          &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>处理Loading和error</p>
</blockquote>
</li>
<li><p>在请求后端数据,展现loading的状态</p>
</li>
<li><p>不需要再loading变更时重新调用useEffect</p>
</li>
<li><p>处理错误,使用useState来创建一个新的state，然后在useEffect中特定的位置来更新这个state</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">    const [isLoading, setIsLoading] &#x3D; useState(false);</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        const fetchData &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">            setIsLoading(true);</span><br><span class="line">        </span><br><span class="line">            const result &#x3D; await axios(url);</span><br><span class="line">        </span><br><span class="line">            setData(result.data);</span><br><span class="line">            setIsLoading(false);</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        fetchData();</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &#123;isLoading ? (</span><br><span class="line">                &lt;div&gt;Loading ...&lt;&#x2F;div&gt;</span><br><span class="line">            ) : (</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                &#123;data.hits.map(item &#x3D;&gt; (</span><br><span class="line">                    &lt;li key&#x3D;&#123;item.objectID&#125;&gt;</span><br><span class="line">                    &lt;a href&#x3D;&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;&#x2F;li&gt;</span><br><span class="line">                ))&#125;</span><br><span class="line">                &lt;&#x2F;ul&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">        &lt;&#x2F;Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同名目录内有抽离自定义hooks组件的例子<br>使用useReducer整合逻辑</p>
</blockquote>
</li>
<li><p>使用了各种通过分离的state hooks来管理分散的：数据、状态，为了有关联的状态整合到一起，我们需要用到useReducer</p>
</li>
<li><p>useReducer 是一个轻量的redux，返回一个状态对象和一个可以改变状态对象的dispatch函数,dispatch函数接受action作为参数，action包含type和payload属性</p>
</li>
<li><p>useReducer将reducer函数和初始状态对象作为参数,即同时定义多个hooks</p>
</li>
<li><p>type属性告诉reducer需要应用哪个状态转换，并且reducer可以使用payload来创建新的状态</p>
</li>
<li><p>例子中的state是对象，导出时可以解构分离原有状态</p>
</li>
<li><p>取消数据请求,在请求还没有返回的时候卸载了组件会报错</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dataFetchReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'FETCH_INIT'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                isLoading: <span class="literal">true</span>,</span><br><span class="line">                isError: <span class="literal">false</span></span><br><span class="line">            &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">    isError: <span class="literal">false</span>,</span><br><span class="line">    data: initialData,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch(&#123; <span class="attr">type</span>: <span class="string">'FETCH_INIT'</span> &#125;);</span><br><span class="line">dispatch(&#123; <span class="attr">type</span>: <span class="string">'FETCH_SUCCESS'</span>, <span class="attr">payload</span>: result.data &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在没有hooks时，创建class组件，性能的优化通过immutable比较，</span><br><span class="line">1、在不相等的时候调用setState,</span><br><span class="line">2、在shouldComponentUpdate中判断前后的props和state，如果没有变化，则返回false来阻止更新</span><br><span class="line"></span><br><span class="line">在hooks出来后，无法通过判断前后状态来决定是否更新，每一次调用都会执行其内部的所有逻辑，可以发现每次改变都会触发父子组件渲染</span><br><span class="line">性能损耗通过useMemo 和useCallback解决</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>React</category>
        <category>Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>追踪用户关闭网页</title>
    <url>/2020/03/30/%E8%BF%BD%E8%B8%AA%E7%94%A8%E6%88%B7%E5%85%B3%E9%97%AD%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<blockquote>
<p>异步ajax、img标签上传数据、beacon API比较</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>1、异步ajax</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">'post'</span>, <span class="string">'/log'</span>, <span class="literal">true</span>);</span><br><span class="line">    xhr.setRequestHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">    xhr.send(<span class="string">'foo=bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unload'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    log();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">1</span>; m &lt; <span class="number">10000</span>; m++) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2、img标签上传数据<br>后缀img.jpg?c=xxxx</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reportData = <span class="function">(<span class="params">url, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">    <span class="keyword">const</span> params = [];</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        params.push(key+<span class="string">'='</span>+<span class="built_in">encodeURIComponent</span>(data[key]));</span><br><span class="line">    &#125;);</span><br><span class="line">    img.onload = <span class="function"><span class="params">()</span> =&gt;</span> img = <span class="literal">null</span>;</span><br><span class="line">    img.src = url+<span class="string">'?'</span>+params.join(<span class="string">'&amp;'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3、beacon API<br>70%不到的成功率</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.sendBeacon(<span class="string">'/log'</span>, <span class="string">'foo=bar'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<hr>
<p>beforeunload不能准确的判断刷新和关闭<br>navigator.sendBeacon不能捕捉直接关闭浏览器或任务管理器结束任务<br>还是后端监听心跳做比较好</p>
<hr>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>koa2简易实现</title>
    <url>/2020/03/27/koa2%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>核心功能洋葱模型</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Application http server 基本服务器框架</span><br><span class="line">Context 上下文 服务器框架基本数据结构的封装，解析响应http请求</span><br><span class="line">Middleware 中间件，洋葱模型机制</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>启动一个简单的http服务</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.end(<span class="string">'- -'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p>app.listen处理请求和端口监听</p>
<p>app.use处理中间件和请求</p>
<blockquote>
<p>myKoa</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware=<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    listen(...args)&#123;</span><br><span class="line">        <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.middleware);</span><br><span class="line">        server.listen(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    use(middleware)&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware = middleware</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line"><span class="comment">// const app = new Application()</span></span><br><span class="line"><span class="comment">// app.use((req,res)=&gt;&#123;res.end('- -')&#125;)</span></span><br><span class="line"><span class="comment">// app.listen(3000)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>构建Context</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此时app.use的回调函数是原生的req,res，而koa中是一个Context对象</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware=<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    listen(...args)&#123;</span><br><span class="line">        <span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 创建Context对象</span></span><br><span class="line">            <span class="keyword">const</span> ctx = <span class="keyword">new</span> Context(req,res);</span><br><span class="line">            <span class="comment">// 处理 app.use</span></span><br><span class="line">            <span class="keyword">this</span>.middleware(ctx);</span><br><span class="line">            <span class="comment">// 响应内容</span></span><br><span class="line">            ctx.res.end(ctx.body);</span><br><span class="line">        &#125;);</span><br><span class="line">        server.listen(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    use(middleware)&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware = middleware</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(req,res)&#123;</span><br><span class="line">        <span class="keyword">this</span>.req=req;</span><br><span class="line">        <span class="keyword">this</span>.res=res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line"><span class="comment">// const app = new Application()</span></span><br><span class="line"><span class="comment">// app.use(ctx=&gt;&#123;ctx.body('- -')&#125;)</span></span><br><span class="line"><span class="comment">// app.listen(3000)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>中间件</p>
</blockquote>
<p>手机中间件回调函数数组，并使用compose串联起来<br>对所有中间件函数通过compose函数来达到抽象效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middlewares);</span><br><span class="line"><span class="keyword">await</span> fn(ctx);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">await</span> compose(<span class="keyword">this</span>.middlwares,ctx);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.middlewares=[]</span><br><span class="line">    &#125;</span><br><span class="line">    listen(...args)&#123;</span><br><span class="line">        <span class="keyword">const</span> server = http.createServer(<span class="keyword">async</span> (req,res)=&gt;&#123;</span><br><span class="line">            <span class="keyword">const</span> ctx = <span class="keyword">new</span> Context(req,res);</span><br><span class="line">            <span class="comment">// 对中间件回调函数串联，洋葱模型</span></span><br><span class="line">            <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middlewares);</span><br><span class="line">            <span class="keyword">await</span> fn(ctx);</span><br><span class="line"></span><br><span class="line">            ctx.res.end(ctx.body);</span><br><span class="line">        &#125;);</span><br><span class="line">        server.listen(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    use(middleware)&#123;</span><br><span class="line">        <span class="keyword">this</span>.middlewares.push(middleware)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">    constructo(req,res)&#123;</span><br><span class="line">        <span class="keyword">this</span>.req=req;</span><br><span class="line">        <span class="keyword">this</span>.res=res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个中间件将会执行。后续每个会通过next执行<br>使用递归完成中间件的改造,实现洋葱模型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch=<span class="function">(<span class="params">i</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> middlewares[i](ctx,()=&gt;&#123;</span><br><span class="line">        dispatch(i+<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">dispatch(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch=<span class="function">(<span class="params">i</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> middleware = middlewares[i];</span><br><span class="line">    <span class="keyword">if</span>(i === middlewares.length)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> middleware(ctx,()=&gt;&#123;</span><br><span class="line">        dispatch(i+<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">dispatch(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>最后的compose</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middlewares</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">ctx</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> dispatch=<span class="function">(<span class="params">i</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> middleware = middlewares[i];</span><br><span class="line">            <span class="keyword">if</span>(i === middlewares.length)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> middleware(ctx,()=&gt;&#123;</span><br><span class="line">                dispatch(i+<span class="number">1</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// const app = new Application()</span></span><br><span class="line"><span class="comment">// app.use(async(ctx)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//    ctx.body('- -')</span></span><br><span class="line"><span class="comment">//    await next()</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// app.use(async (ctxnext)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//    ctx.body('- -')</span></span><br><span class="line"><span class="comment">//    await next()</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// app.use(async (ctx,next)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//    ctx.body='富士山</span></span><br><span class="line"><span class="comment">//    await next()</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// app.listen(3000)</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>label语法</title>
    <url>/2020/03/10/label%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>使用label语法在多层循环中精确返回指定位置</p>
</blockquote>
<a id="more"></a>
<p>主要用于break和continue的跳出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span> )&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        num++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// 95 循环在 i 为5，j 为5的时候跳出 j循环，但会继续执行 i 循环</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outPoint:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span> )&#123;</span><br><span class="line">                <span class="keyword">break</span> outPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        num++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// 55 循环在 i 为5，j 为5的时候跳出双循环，返回到outPoint层继续执行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i === <span class="number">5</span> &amp;&amp; j === <span class="number">5</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span> outermost;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// 95 continue outermost;语句的作用是跳出当前循环，并跳转到outermost（标签）下的for循环继续执行</span></span><br></pre></td></tr></table></figure>
<p>实际场景下应该不会出现三层及以上循环</p>
]]></content>
      <categories>
        <category>label</category>
      </categories>
      <tags>
        <tag>label</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Component</title>
    <url>/2020/02/28/Web%20Component/</url>
    <content><![CDATA[<blockquote>
<p>Web Component</p>
</blockquote>
<a id="more"></a>

<p><a href="https://segmentfault.com/a/1190000012440318" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012440318</a></p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>Web Component</category>
      </categories>
      <tags>
        <tag>Web Component</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtual Dom</title>
    <url>/2020/02/28/Virtual%20Dom/</url>
    <content><![CDATA[<blockquote>
<p>什么是Virtual Dom</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.jianshu.com/p/a036eaa2263a" target="_blank" rel="noopener">https://www.jianshu.com/p/a036eaa2263a</a><br><a href="https://www.jianshu.com/p/b189b2949b33" target="_blank" rel="noopener">https://www.jianshu.com/p/b189b2949b33</a></p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>Virtual Dom</category>
      </categories>
      <tags>
        <tag>Virtual Dom</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组拍平 扁平化的方式</title>
    <url>/2020/02/28/js%E6%95%B0%E7%BB%84%E6%8B%8D%E5%B9%B3%20%E6%89%81%E5%B9%B3%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>六种方式 拍平数组 扁平化数组</p>
</blockquote>
<a id="more"></a>
<p><code>var arr = [1,2,[3,4,5,[6,7,8],9],10,[11,12]];</code></p>
<blockquote>
<p>递归实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">let</span> arr1 = [];</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">            arr1 = arr1.concat(fn(val))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr1.push(val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arr1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>reduce实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev,cur</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prev.concat(<span class="built_in">Array</span>.isArray(cur)?fn(cur):cur)</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>flat</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.flat(<span class="literal">Infinity</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>扩展运算符</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr1 = [];</span><br><span class="line">    <span class="keyword">let</span> bStop = <span class="literal">true</span>;</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(val))&#123;</span><br><span class="line">            arr1.push(...val);</span><br><span class="line">            bStop = <span class="literal">false</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr1.push(val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(bStop)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(arr1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>toString</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = arr.toString().split(<span class="string">','</span>).map(<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(val)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>apply</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item)))&#123;</span><br><span class="line">           arr =  [].concat.apply([],arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>curl</title>
    <url>/2020/02/28/curl/</url>
    <content><![CDATA[<blockquote>
<p>curl使用指南<br><a href="https://www.jianshu.com/p/fc0eb6c60816" target="_blank" rel="noopener">https://www.jianshu.com/p/fc0eb6c60816</a></p>
</blockquote>
<a id="more"></a>
<p>curl 的用法指南 阮一峰<br><a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a><br>学习笔记之 curl 命令用法详解<br><a href="https://www.cnblogs.com/doseoer/p/7044344.html" target="_blank" rel="noopener">https://www.cnblogs.com/doseoer/p/7044344.html</a></p>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2020/02/27/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>markdown语法</p>
</blockquote>
<a id="more"></a>

<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># h1 代表标题级数，最多6级标题</span><br></pre></td></tr></table></figure>
<h1 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h1><p>末尾加2个空格表示换行</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 无序列表</span><br><span class="line">    +次级</span><br><span class="line">    -次级</span><br><span class="line">    次级</span><br><span class="line">最后空行</span><br></pre></td></tr></table></figure>
<ul>
<li>列表<br>  +次级<br>  -次级<br>  次级</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.有序列表</span><br><span class="line">    1.次级</span><br><span class="line">    2.次级</span><br><span class="line">2.有序列表</span><br></pre></td></tr></table></figure>
<p>1.有序列表<br>    1.次级<br>    2.次级<br>2.有序列表</p>
<h1 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 一级引用</span><br><span class="line">&gt;&gt; 二级引用</span><br><span class="line">&gt;&gt;&gt; 三级引用</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一级引用</p>
<blockquote>
<p>二级引用</p>
<blockquote>
<p>三级引用</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<hr>
<h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[百度](https:&#x2F;&#x2F;www.baidu.com)</span><br></pre></td></tr></table></figure>
<p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![百度](https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;bd_logo1.png?where&#x3D;super)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.baidu.com/img/bd_logo1.png?where=super" alt="百度"></p>
<h1 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h1><p><code>代码框</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'123'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体*          _斜体_</span><br><span class="line">**加粗**        __加粗__</span><br><span class="line">***斜体加粗***  ___斜体加粗___</span><br></pre></td></tr></table></figure>
<p><em>斜体</em> <em>斜体</em><br><strong>加粗</strong> <strong>加粗</strong><br><strong><em>斜体加粗</em></strong> <strong><em>斜体加粗</em></strong></p>
<h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><p><code>~~待删除~~</code><br><del>待删除</del></p>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p><code>默认左对齐(:-)，右对齐(-:)，居中对齐(:-:)</code></p>
<table>
<thead>
<tr>
<th align="center">head</th>
<th align="left">head</th>
<th align="right">head</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">2</td>
<td align="right">3</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="right">head</th>
<th align="center">head</th>
<th>head</th>
</tr>
</thead>
<tbody><tr>
<td align="right">1</td>
<td align="center">2</td>
<td>3</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>head</th>
<th align="right">head</th>
<th align="center">head</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="right">2</td>
<td align="center">3</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>模板语法</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>hello hexo,你好 hexo</title>
    <url>/2020/02/22/hello-hexo/</url>
    <content><![CDATA[<blockquote>
<p>新建文章、创建标签和分类、阅读全文、搜索功能<br>next主题的使用方法</p>
</blockquote>
<a id="more"></a>
<h1 id="next主题的使用方法"><a href="#next主题的使用方法" class="headerlink" title="next主题的使用方法"></a>next主题的使用方法</h1><!-- 
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&auto=0&id=1386946644&height=66"></iframe> -->


<p>Hexo<br><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a><br>NexT<br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a><br>Hexo框架下用NexT(v7.0+)主题美化博客<br><a href="https://blog.csdn.net/weixin_39345384/article/details/80785373" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39345384/article/details/80785373</a><br>HEXO-NexT-V7-Gemini主题优化篇<br><a href="https://yangyang188.coding.me/archives/3575fa23/" target="_blank" rel="noopener">https://yangyang188.coding.me/archives/3575fa23/</a></p>
<!-- 复制粘贴工程师小程序
https://tj-xiajiahao.github.io/
git document
http://iissnan.com/progit/
主页
https://gitby-leo.github.io/ -->

<!-- ps导出精度会影响图片色彩，最好是导出最佳精度后压缩
NIM 调试扩展 nodejs
安装vscode .swig扩展支持
Parcel
MobX
https://cn.mobx.js.org/
web-cell
https://web-cell.dev/
😆 -->

<hr>
<h2 id="hexo的特点"><a href="#hexo的特点" class="headerlink" title="hexo的特点"></a>hexo的特点</h2><p>pjax：依赖jq的pushState+ajax库<br>无切换、高性能加载显示html，又能跟普通url兼容，而ajax引入hash会影响seo</p>
<hr>
<h3 id="启用数据目录"><a href="#启用数据目录" class="headerlink" title="启用数据目录"></a>启用数据目录</h3><p>在 hexo/source/_data 目录下新建 next.yml 文件，把 Next 的主题配置文件 next/_config.yml 内容全部复制到 next.yml，然后修改override为true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建额外目录文件：</span><br><span class="line">1、custom_file_path中增加一个路径，</span><br><span class="line">2、next&#x2F;scripts&#x2F;events&#x2F;lib&#x2F;injects-point.js中增加对应变量</span><br><span class="line">3、引用文件&#123;&#123;- next_inject(&#39;xxx&#39;) &#125;&#125;</span><br><span class="line">4、新建文件</span><br></pre></td></tr></table></figure>

<h2 id="定义-CSS-路径"><a href="#定义-CSS-路径" class="headerlink" title="定义 CSS 路径"></a>定义 CSS 路径</h2><p>Next 7.2 版本后取消了 \themes\next\source\css_custom\custom.styl，怪不得这个路径一直找不到，需要在配置文件里重新定义。此处的配置项基于数据目录功能，所以必须完成前面的「启用数据目录」才能生效。<br>next.yml中的custom_file_path，解注style并新建对应文件</p>
<h2 id="配置激活-失活时的网页标题"><a href="#配置激活-失活时的网页标题" class="headerlink" title="配置激活/失活时的网页标题"></a>配置激活/失活时的网页标题</h2><p>custom-script<br>yml配置文件里新建title_trick {enable,leave,enter}</p>
<h2 id="关联文章"><a href="#关联文章" class="headerlink" title="关联文章"></a>关联文章</h2><p>hexo-related-popular-posts 报错- -<br>lib/list-json.js中 要加try catch : ret.path  = pathFn.join(config.root , list.path)</p>
<h2 id="列表页添加可配置图片"><a href="#列表页添加可配置图片" class="headerlink" title="列表页添加可配置图片"></a>列表页添加可配置图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layout&#x2F;_macro&#x2F;post.swig中添加2处代码</span><br><span class="line">&lt;!--noindex--&gt;</span><br><span class="line">&#123;% if post.descriptionImage %&#125;</span><br><span class="line">  &lt;div class&#x3D;&quot;out-img-topic-descriptionImage&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&#123;&#123; post.descriptionImage &#125;&#125; class&#x3D;&quot;img-topic-descriptionImage&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">每个文章页头部添加需要显示的图片路径</span><br><span class="line">descriptionImage: &#39;&#39;</span><br><span class="line">&lt;!--&#x2F;noindex--&gt;</span><br></pre></td></tr></table></figure>
<h2 id="背景动态图片"><a href="#背景动态图片" class="headerlink" title="背景动态图片"></a>背景动态图片</h2><p>jquery-backstretch<br>可以放到bodyEnd中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;jquery-backstretch&#x2F;2.0.4&#x2F;jquery.backstretch.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  $(&quot;body&quot;).backstretch(&quot;https:&#x2F;&#x2F;背景图.jpg&quot;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="rating评分"><a href="#rating评分" class="headerlink" title="rating评分"></a>rating评分</h2><p>注册后填写网站的id</p>
<p>1) 可以配置评分方式，侧栏 &gt; Rating &gt; Setting，建议用 IP address 或 Device (cookie)，免登录，毕竟 Socials 里面的选项几乎都被墙，不适合国内网络环境。<br>2）建议在侧栏 &gt; Site &gt; Setting 中勾选 Private 选项，这样只能域名下使用</p>
<hr>
<h2 id="看板娘-桌宠"><a href="#看板娘-桌宠" class="headerlink" title="看板娘/桌宠"></a>看板娘/桌宠</h2><p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</a><br><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">https://github.com/xiazeyu/live2d-widget-models</a><br>npm install –save hexo-helper-live2d</p>
<p><del>/themes/next/layout/_layout.swig</del><br><del>body里添加{live2d()}</del><br>3.0不需要包含live2d(),只需安装依赖,models放入node_models内和站点文件配置live2d:</p>
<p>高定版本（高级定制<br><a href="https://github.com/stevenjoezhang/live2d-widget" target="_blank" rel="noopener">https://github.com/stevenjoezhang/live2d-widget</a><br>下载后放到目录/source/live2d-widget下，和_post同级<br>替换autoload.js中的live2d_path值和本地目录名称live2d-widget一致</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_layout.swig</span><br><span class="line">线上</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;stevenjoezhang&#x2F;live2d-widget@latest&#x2F;autoload.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">本地</span><br><span class="line">&lt;script src&#x3D;&quot;&#x2F;live2d-widget&#x2F;autoload.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p>首行缩进：空两格<br>&#160; &#160; &#160; &#160;开头<br><span style="background-color:#eee">字体高亮</span><br><code>字体高亮</code></p>

<table>
   <tr>
      <td colspan="6"><b>表格</b></td>
   </tr>
   <tr>
      <td>class</td><td>interface</td><td>byte</td><td>short</td><td>int</td><td>long</td>
   </tr>
   <tr>
      <td>class</td><td>interface</td><td>byte</td><td>short</td><td>int</td><td>long</td>
   </tr>
</table>



<hr>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图片根路径默认是source&#x2F;images</span><br><span class="line">![](&#x2F;images&#x2F;avatar.jpg)</span><br><span class="line">&#123;% img &#x2F;images&#x2F;avatar.jpg &quot;图片&quot; %&#125;</span><br><span class="line"></span><br><span class="line">fancybox放大预览，安装依赖后在配置页打开</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fancybox3 source&#x2F;lib&#x2F;fancybox</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;images&#x2F;avatar.jpg&quot; title&#x3D;&quot;放大预览&quot; alt&#x3D;&quot;放大预览&quot;&#x2F;&gt;</span><br><span class="line">&#123;% img &#x2F;images&#x2F;vi-vim-cheat-sheet.gif 600 600 &quot;点击查看大图:vi&#x2F;vim-cheat-sheet&quot; %&#125;</span><br><span class="line"></span><br><span class="line">themes&#x2F;next&#x2F;js&#x2F;utils内添加拦截，实现imageHref和imageTitle</span><br><span class="line">if ($image.hasClass(&#39;nofancybox&#39;)) &#123;</span><br><span class="line">  var imageHref &#x3D; $image.attr(&#39;href&#39;) </span><br><span class="line">  if(imageHref)&#123;</span><br><span class="line">    var imageWrapLink &#x3D; $image.wrap(&#96;&lt;a href&#x3D;$&#123;imageHref&#125; target&#x3D;&quot;_blank&quot;&gt;&lt;&#x2F;a&gt;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">  var imageTitle &#x3D; $image.attr(&#39;title&#39;) || $image.attr(&#39;alt&#39;);</span><br><span class="line">  if (imageTitle) &#123;</span><br><span class="line">    $image.after(&#96;&lt;p class&#x3D;&quot;image-caption&quot;&gt;$&#123;imageTitle&#125;&lt;&#x2F;p&gt;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;images&#x2F;avatar.jpg&quot; title&#x3D;&quot;不需要放大预览&quot; alt&#x3D;&quot;不需要放大预览&quot; class&#x3D;&quot;nofancybox&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<div style="display:flex;">
  <div style="flex:1">
    <img src="/images/avatar.jpg" title="放大预览" alt="放大预览"/>
  </div>
  <div style="flex:1">
    <img src="/images/avatar.jpg" title="不需要放大预览" alt="不需要放大预览" class="nofancybox"/>
  </div>
  <div style="flex:1">
    <img src="/images/avatar.jpg" title="跳转链接" alt="跳转链接" class="nofancybox" href="https://www.baidu.com" />
  </div>
</div>

<hr>
<h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br><span class="line"></span><br><span class="line">.md中top:true 或者true: 2控制多篇顺序</span><br><span class="line"></span><br><span class="line">添加样式themes&#x2F;hexo-theme-next&#x2F;layout&#x2F;_macr中&lt;div class&#x3D;&quot;post-meta&quot;&gt;里</span><br><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="随机副标题文案"><a href="#随机副标题文案" class="headerlink" title="随机副标题文案"></a>随机副标题文案</h2><p>站点_config.yml中：subtitle用-添加文案<br>/next/layout/_partials/header/brand.swig分割,数组随机显示</p>
<hr>
<h2 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h2><hr>
<h2 id="live2d"><a href="#live2d" class="headerlink" title="live2d"></a>live2d</h2><hr>
<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>如果没指定<code>[layout]</code>就使用<code>default_layout</code>中的默认模板</p>
<p>hexo new 文章名     // 简写新建<br>hexo new “文章名 1”  // 空格需要用引号<br>hexo new post 文章名 // 用post模板新建文章</p>
<p>npm install –save hexo-generator-index hexo-generator-archive hexo-generator-tag</p>
<hr>
<h2 id="个性化页面"><a href="#个性化页面" class="headerlink" title="个性化页面"></a>个性化页面</h2><p>站点_config.yml中skip_render配置过滤source下的指定目录或文件</p>
<hr>
<h2 id="创建标签和分类"><a href="#创建标签和分类" class="headerlink" title="创建标签和分类"></a>创建标签和分类</h2><p>hexo new page tags</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在tags&#x2F;index.md中加入</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<p>hexo new page categories</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories&#x2F;index.md中加入</span><br><span class="line">tags: &quot;categories&quot;</span><br></pre></td></tr></table></figure>

<p>文章页加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories: </span><br><span class="line">- Axx</span><br><span class="line">tags:</span><br><span class="line">- Bxx</span><br></pre></td></tr></table></figure>

<p>可以在scaffolds/post.md模板中加入categories:和tags:<br>每次hexo new 文章名时会自动包含分类和标签</p>
<hr>
<h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h2><p>npm install hexo-symbols-count-time –save</p>
<hr>
<h2 id="阅读全文"><a href="#阅读全文" class="headerlink" title="阅读全文"></a>阅读全文</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、md中手动&lt;!-- more --&gt;</span><br><span class="line">2、md中头部front-matter中使用description</span><br><span class="line">3、auto_excerpt功能在新版中弃用，换成npm包</span><br><span class="line">npm install hexo-excerpt --save</span><br><span class="line">主题_config.yml中&#96;添加&#96;:</span><br><span class="line">excerpt:</span><br><span class="line">  depth: 1</span><br><span class="line">  excerpt_excludes: []</span><br><span class="line">  more_excludes: []</span><br><span class="line">  hideWholePostExcerpts: false</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>引用algolia search:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、npm install --save hexo-algolia</span><br><span class="line">2、站点_config.yml中</span><br><span class="line">algolia:</span><br><span class="line">    applicationID: &#39;applicationID&#39;</span><br><span class="line">    indexName: &#39;indexName&#39;</span><br><span class="line">    chunkSize: 5000</span><br><span class="line"></span><br><span class="line">3、git bash中：</span><br><span class="line">$ export HEXO_ALGOLIA_INDEXING_KEY&#x3D;your Search key</span><br><span class="line">$ hexo algolia</span><br><span class="line">4、主题_config.yml中:</span><br><span class="line">algolia_search:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure>
<p>引用local search:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、npm install hexo-generator-searchdb --save</span><br><span class="line">2、站点_config.yml中</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line">4、主题_config.yml中:</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">5、hexo generate生成search.xml</span><br><span class="line">6、hexo server查看效果</span><br></pre></td></tr></table></figure>

<h2 id="hexo-admin后台管理"><a href="#hexo-admin后台管理" class="headerlink" title="hexo-admin后台管理"></a>hexo-admin后台管理</h2><p><code>DeprecationWarning: fs.SyncWriteStream is deprecated.</code>报错是因为node8.0+移除了方法，某插件依赖了这个方法<br>通过hexo –debug找到<br>在hexo-admin的依赖中找到hexo-fs/lib/fs.js并注释下面这行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.SyncWriteStream = fs.SyncWriteStream;</span><br></pre></td></tr></table></figure>

<!-- 发布配置局部信息
git config user.name xxx -->
]]></content>
      <categories>
        <category>hexo教程</category>
        <category>hexo入门</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World 欢迎来到hexo</title>
    <url>/2020/02/21/hello-world/</url>
    <content><![CDATA[<blockquote>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
</blockquote>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
